{"version":3,"file":"static/js/16290.d4420b50.chunk.js","mappings":"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","sources":["njslab/Workshop/workshop-curve/renderer/index.ts","njslab/Workshop/workshop-curve/workshop-01-line-interpolation.ts"],"sourcesContent":["export class Canvas3DWireframe {\n  public div: HTMLElement;\n  public renderer: RendererCanvas3DWireframe;\n  public pts = [];\n  public lns = [];\n  public t = 0.0;\n  constructor(id: string) {\n    this.div = document.getElementById(id);\n    this.renderer = new RendererCanvas3DWireframe(id);\n    this.renderer.pts = this.pts;\n\n    this.init();\n    this.update();\n    this.render();\n  }\n  public init() {\n    // TODO\n  }\n  public update() {\n    // TODO\n  }\n  public render() {\n    requestAnimationFrame(() => {\n      this.render();\n    });\n    this.update();\n    this.renderer.render();\n  }\n  public destroy() {\n    // this.renderer.destroy();\n    try {\n      while (this.div && this.div.lastElementChild) {\n        const lastChild = this.div.lastElementChild as Node;\n        this.div.removeChild(lastChild);\n      }\n    } catch (error) {\n      console.error(\"Error removing child elements:\", error);\n    }\n  }\n}\n\nexport class RendererCanvas3DWireframe {\n  public render: () => void;\n\n  public vecs = [];\n  public pts = [];\n  public cps = [];\n  public circle = [];\n  public polylines = [];\n\n  public showFrame = false;\n  public showPoint = true;\n  \n  constructor(id) {\n    const div = document.getElementById(id);\n    const bounding = div.getBoundingClientRect();\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = bounding.width;\n    canvas.height = bounding.height;\n    div.appendChild(canvas);\n\n    const ctx = canvas.getContext(\"2d\");\n\n    let angleX = -Math.PI / 2;\n    let angleY = 0;\n    let dragging = false;\n    let panning = false;\n    let zoom = 1;\n    let lastMouseX = 0;\n    let lastMouseY = 0;\n    let offsetX = 0;\n    let offsetY = 0;\n    let panStartX = 0;\n    let panStartY = 0;\n    let fov = 500;\n\n\n    const rotate = (point, angleX, angleY) => {\n      const cosX = Math.cos(angleX);\n      const sinX = Math.sin(angleX);\n      const cosY = Math.cos(angleY);\n      const sinY = Math.sin(angleY);\n\n      // (swap Y and Z for Z-up)\n      let x = point.x * cosY - point.y * sinY;\n      let y = point.x * sinY + point.y * cosY;\n\n      let z = point.z * cosX - y * sinX;\n      y = point.z * sinX + y * cosX;\n\n      return { x, y, z };\n    };\n\n    const project = (point) => {\n      const scale = (fov / (fov + point.y)) * zoom; // Z-axis is now vertical\n      return {\n        x: point.x * scale + canvas.width / 2 + offsetX,\n        y: -point.z * scale + canvas.height / 2 + offsetY, // Invert Z for canvas Y-axis\n      };\n    };\n\n    const projectionToView = (p) => {\n      let rotated = rotate(p, angleX, angleY);\n      return project(rotated);\n    }\n\n    const rendering = () => {\n      // requestAnimationFrame(() => {\n      //   rendering();\n      // });\n      // console.log('rendering...', this.pts)\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n\n      for(let i = 0; i < this.polylines.length; ++i) {\n        let col = \"red\";\n        if (i % 3 === 1) {\n          col = \"green\";\n        } else if (i % 3 === 2) {\n          col = \"blue\";\n        }\n        ctx.strokeStyle = col;\n        ctx.beginPath();\n        for(let j = 0; j < this.polylines[i].length; ++j) {\n          let projectPt = projectionToView(this.polylines[i][j])\n          if (j === 0 ) {\n            ctx.moveTo(projectPt.x, projectPt.y)\n          } else {\n            ctx.lineTo(projectPt.x, projectPt.y)\n          }\n        }\n        ctx.stroke();\n      }\n\n\n      const vsForLine = [];\n\n      if (this.showPoint) {\n        this.pts.forEach((point) => {\n          const rotated = rotate(point, angleX, angleY);\n          const projected = project(rotated);\n  \n          const depthScale = (fov / (fov + rotated.y)) * zoom;\n          let radius = point.size * depthScale;\n          radius = radius < 0.1 ? 0.1 : radius;\n  \n          ctx.beginPath();\n          ctx.arc(projected.x, projected.y, radius, 0, Math.PI * 2);\n          ctx.fillStyle = point.color ? point.color : \"#f00\";\n          ctx.fill();\n        });\n      }\n\n      let count = 0;\n\n      // console.log(this.vecs.length)\n\n      if (this.showFrame) {\n        this.vecs.forEach((vs) => {\n          // console.log(vs)\n\n          const rotated = rotate(vs[0], angleX, angleY);\n          const projected = project(rotated);\n\n          vsForLine.push(projected);\n\n          const rotated2 = rotate(vs[1], angleX, angleY);\n          const projected2 = project(rotated2);\n\n          let col = \"red\";\n          if (count % 3 === 1) {\n            col = \"green\";\n          } else if (count % 3 === 2) {\n            col = \"blue\";\n          }\n\n          drawVector(ctx, projected, projected2, col);\n          // console.log(count)\n          count++;\n        });\n      }\n      // drawCurve(ctx, vsForLine);\n\n\n\n\n\n      this.cps.forEach((point) => {\n        const rotated = rotate(point, angleX, angleY);\n        const projected = project(rotated);\n\n        const depthScale = (fov / (fov + rotated.y)) * zoom;\n        let radius = 3 * depthScale;\n        radius = radius < 0.1 ? 0.1 : radius;\n\n        ctx.beginPath();\n        ctx.arc(projected.x, projected.y, radius, 0, Math.PI * 2);\n        ctx.fillStyle = \"#000\";\n        ctx.fill();\n      });\n\n      ctx.beginPath();\n      for (let i = 0; i < this.cps.length; ++i) {\n        const rotated = rotate(this.cps[i], angleX, angleY);\n        const projected = project(rotated);\n\n        if (i === 0) {\n          ctx.moveTo(projected.x, projected.y);\n        } else {\n          ctx.lineTo(projected.x, projected.y);\n        }\n      }\n      ctx.lineWidth = 1;\n      ctx.strokeStyle = \"rgba(0,0,0, 0.75)\";\n      ctx.stroke();\n\n      if (this.circle[0]) {\n\n        drawCircle(ctx, this.circle[0], this.circle[1], projectionToView)\n       \n      }\n    };\n    this.render = () => rendering();\n\n    canvas.addEventListener(\"mousedown\", (e) => {\n      if (e.button === 2) {\n        dragging = true;\n      } else if (e.button === 0) {\n        if (e.altKey) {\n          dragging = true;\n        } else {\n          panning = true;\n          panStartX = e.clientX - offsetX;\n          panStartY = e.clientY - offsetY;\n        }\n      }\n      lastMouseX = e.clientX;\n      lastMouseY = e.clientY;\n    });\n\n    canvas.addEventListener(\"mousemove\", (e) => {\n      if (dragging) {\n        const dx = e.clientX - lastMouseX;\n        const dy = e.clientY - lastMouseY;\n        angleX -= dy * 0.01;\n        angleY += dx * 0.01;\n        lastMouseX = e.clientX;\n        lastMouseY = e.clientY;\n        //   rendering();\n      } else if (panning) {\n        offsetX = e.clientX - panStartX;\n        offsetY = e.clientY - panStartY;\n        //   rendering();\n      }\n    });\n\n    canvas.addEventListener(\"mouseup\", () => {\n      dragging = false;\n      panning = false;\n    });\n\n    canvas.addEventListener(\"contextmenu\", (e) => {\n      e.preventDefault();\n    });\n\n    canvas.addEventListener(\"wheel\", (e) => {\n      const mouseX = e.clientX - canvas.getBoundingClientRect().left;\n      const mouseY = e.clientY - canvas.getBoundingClientRect().top;\n\n      const prevZoom = zoom;\n      const zoomSpeed = Math.max(0.001, zoom * 0.02); // zoom speed based on zoom level\n\n      zoom += e.deltaY * -zoomSpeed;\n      zoom = Math.min(Math.max(zoom, 0.1), 50);\n\n      const scaleChange = zoom / prevZoom;\n\n      offsetX -= (mouseX - canvas.width / 2 - offsetX) * (scaleChange - 1);\n      offsetY -= (mouseY - canvas.height / 2 - offsetY) * (scaleChange - 1);\n\n      // rendering();\n    });\n\n    rendering();\n  }\n}\n\nconst drawVector = (ctx, origin, vector, color = \"black\") => {\n  const start = origin;\n  const end = vector;\n  // console.log(color)\n  ctx.beginPath();  \n  ctx.moveTo(start.x, start.y);\n  ctx.lineTo(end.x, end.y);\n  ctx.closePath();\n  \n  ctx.strokeStyle = color;\n  ctx.lineWidth = 2;\n  ctx.stroke();\n};\n\nconst drawCurve = (ctx, vs) => {\n  ctx.beginPath();\n  ctx.strokeStyle = \"blue\";\n  ctx.lineWidth = 2;\n\n  // const steps = 100;\n  for (let i = 0; i < vs.length; i++) {\n    if (i === 0) {\n      ctx.moveTo(vs[i].x, vs[i].y);\n    } else {\n      ctx.lineTo(vs[i].x, vs[i].y);\n    }\n  }\n  ctx.stroke();\n};\n\nconst drawCircle = (ctx, cp, radius, projectionToView ) => {\n\n  ctx.beginPath();\n  for (let angle = 0; angle <= 360; angle++) {\n\n    const radians = (angle * Math.PI) / 180;\n\n    const x = cp.x + radius * Math.cos(radians);\n    const y = cp.y + radius * Math.sin(radians);\n    const z = cp.z\n\n    let projected = projectionToView({x,y,z})\n    if (angle === 0) {\n      ctx.moveTo(projected.x, projected.y);\n    } else {\n      ctx.lineTo(projected.x, projected.y);\n    }\n  }\n  ctx.closePath();\n  ctx.stroke();\n};\n","import { RendererCanvas3DWireframe  } from './renderer';\r\n\r\n\r\ntype Point = [number, number, number];\r\n\r\n// NURBS Curve Class\r\nclass NURBSCurve {\r\n  private controlPoints: Point[];\r\n  private knots: number[];\r\n  private weights: number[];\r\n  private degree: number;\r\n\r\n  constructor(controlPoints: Point[], knots: number[], weights: number[], degree: number) {\r\n    if (controlPoints.length !== weights.length) {\r\n      throw new Error(\"The number of control points must match the number of weights.\");\r\n    }\r\n\r\n    this.controlPoints = controlPoints;\r\n    this.knots = knots;\r\n    this.weights = weights;\r\n    this.degree = degree;\r\n  }\r\n\r\n  // Basis function (recursive definition)\r\n  private basisFunction(i: number, k: number, t: number): number {\r\n    if (k === 0) {\r\n      return this.knots[i] <= t && t < this.knots[i + 1] ? 1 : 0;\r\n    }\r\n\r\n    const denom1 = this.knots[i + k] - this.knots[i];\r\n    const denom2 = this.knots[i + k + 1] - this.knots[i + 1];\r\n\r\n    const term1 = denom1 !== 0 ? ((t - this.knots[i]) / denom1) * this.basisFunction(i, k - 1, t) : 0;\r\n    const term2 = denom2 !== 0 ? ((this.knots[i + k + 1] - t) / denom2) * this.basisFunction(i + 1, k - 1, t) : 0;\r\n\r\n    return term1 + term2;\r\n  }\r\n\r\n  // Evaluate the NURBS curve at parameter t\r\n  public evaluate(t: number) {\r\n    const n = this.controlPoints.length;\r\n    const numerator: Point = [0, 0, 0];\r\n    let denominator = 0;\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      const weightBasis = this.weights[i] * this.basisFunction(i, this.degree, t);\r\n      denominator += weightBasis;\r\n\r\n      numerator[0] += weightBasis * this.controlPoints[i][0];\r\n      numerator[1] += weightBasis * this.controlPoints[i][1];\r\n      numerator[2] += weightBasis * this.controlPoints[i][2];\r\n    }\r\n\r\n    return new Vector3(\r\n      numerator[0] / denominator,\r\n      numerator[1] / denominator,\r\n      numerator[2] / denominator,\r\n    );\r\n  }\r\n}\r\n\r\n\r\n\r\n// export class Solution extends Canvas3DWireframe {\r\n//   _curvess: any;\r\n//   constructor(id: string) {\r\n//     super(id)\r\n//   }\r\n\r\n//   get curvess () {\r\n//     return this._curvess\r\n//   }\r\n//   set curvess (v) {\r\n//     console.trace()\r\n//     this._curvess = v\r\n//   }\r\n\r\n//   public init () {\r\n\r\n//     this.t = 0.0;\r\n//     this.pts.push(...genGridPt());\r\n\r\n//     // Example Usage\r\n//     const controlPoints: Point[] = [\r\n//       [0, 0, 0],\r\n//       [1, 2, 0],\r\n//       [3, 3, 0],\r\n//       [4, 0, 0],\r\n//       // [4, 5, 5],\r\n//       // [2, 1, 8],\r\n//     ];\r\n//     const knots = [0, 0, 0, 1, 2, 2, 2];\r\n//     const weights = [1, 1, 1, 1];\r\n//     const degree = 2;\r\n\r\n//     const nurbsCurve = new NURBSCurve(controlPoints, knots, weights, degree);\r\n//     // Evaluate the curve at various t values\r\n//     const tValues = [0, 0.25, 0.5, 0.75, 1];\r\n//     const results = tValues.map((t) => nurbsCurve.evaluate(t));\r\n    \r\n//     console.log(\"1 Curve points:\", results);\r\n    \r\n    \r\n    \r\n//     this.curvess = [1,2,3]\r\n\r\n//   }\r\n//   public update() {\r\n\r\n//     console.log(this.curvess, this.pts.length)\r\n\r\n//     for (let i = 0; i < this.pts.length; ++i) {\r\n//       // const offset = Math.cos((this.pts[i].x + this.pts[i].y) * this.t) * 2\r\n//       // this.pts[i].z+= offset\r\n\r\n//       this.pts[i].z = Math.cos(i * this.t * 0.1)\r\n//     }\r\n\r\n\r\n  \r\n\r\n\r\n//     this.t += 0.01;\r\n//   }\r\n\r\n// }\r\n\r\n\r\n\r\nexport class Solution {\r\n  public div: HTMLElement;\r\n  public renderer: RendererCanvas3DWireframe;\r\n  public pts = [];\r\n  public lns = [];\r\n  public t = 0.0;\r\n  curve;\r\n  constructor(id: string) {\r\n    this.div = document.getElementById(id);\r\n    this.renderer = new RendererCanvas3DWireframe(id);\r\n    this.renderer.pts = this.pts;\r\n\r\n    this.init();\r\n    this.update();\r\n    this.render();\r\n  }\r\n  public init() {\r\n    // this.pts.push(...genGridPt());\r\n\r\n\r\n    const controlPoints: Point[] = [\r\n      [50, 300, 0],\r\n      [150, 100, 0],\r\n      [250, 500, 0],\r\n      [350, 200, 0],\r\n      [450, 400, 0],\r\n    ];\r\n    const knots = [0, 0, 0, 0, 1, 2, 3, 3, 3, 3];\r\n    const weights = [1, 1, 1, 1, 1];\r\n    const degree = 3;\r\n\r\n    const nurbsCurve = new NURBSCurve(controlPoints, knots, weights, degree);\r\n    // Evaluate the curve at various t values\r\n    const tValues = [0, 0.25, 0.5, 0.75, 1];\r\n    const results = tValues.map((t) => nurbsCurve.evaluate(t));\r\n\r\n    const pts = []\r\n    for(let i = 0; i < 100; ++i) {\r\n      const tval = i * 0.01\r\n      const vv = nurbsCurve.evaluate(tval)\r\n      pts.push(vv)\r\n    }\r\n    this.pts.push(...pts);\r\n\r\n    \r\n    console.log(\"1 Curve points:\", results);\r\n    this.curve = nurbsCurve\r\n\r\n\r\n  }\r\n  public update() {\r\n\r\n    for (let i = 0; i < this.pts.length; ++i) {\r\n        // const offset = Math.cos((this.pts[i].x + this.pts[i].y) * this.t) * 2\r\n        // this.pts[i].z+= offset\r\n  \r\n        // this.pts[i].z = Math.cos(i * this.t * 0.1)\r\n      }\r\n\r\n      console.log(this.pts)\r\n\r\n\r\n    \r\n    this.t += 0.01;\r\n  }\r\n  public render() {\r\n    requestAnimationFrame(() => {\r\n      this.render();\r\n    });\r\n    this.update();\r\n    this.renderer.render();\r\n  }\r\n  public destroy() {\r\n    // this.renderer.destroy();\r\n    try {\r\n      while (this.div && this.div.lastElementChild) {\r\n        const lastChild = this.div.lastElementChild as Node;\r\n        this.div.removeChild(lastChild);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error removing child elements:\", error);\r\n    }\r\n  }\r\n}\r\n\r\n\r\nclass Vector3 {\r\n  public x: number = 0.0;\r\n  public y: number = 0.0;\r\n  public z: number = 0.0;\r\n  public r: number = 10\r\n  public color = '#f0f'\r\n  constructor(x, y, z) {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n  }\r\n  public render(ctx: CanvasRenderingContext2D) {\r\n      ctx.fillStyle = this.color;\r\n      ctx.beginPath();\r\n      ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2.0);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n  }\r\n}\r\n\r\n\r\nconst genRandomPt = (numPoints = 100) => {\r\n  const pts = [];\r\n  for (let i = 0; i < numPoints; i++) {\r\n    // const p = {\r\n    //   x: (Math.random() - 0.5) * 500,\r\n    //   y: (Math.random() - 0.5) * 500,\r\n    //   z: (Math.random() - 0.5) * 500,\r\n    // }\r\n    const p = new Vector3((Math.random() - 0.5) * 500, (Math.random() - 0.5) * 500, (Math.random() - 0.5) * 500)\r\n    pts.push(p);\r\n  }\r\n  return pts;\r\n};\r\n\r\nconst genGridPt = (numPoints = 5) => {\r\n  const scale = 20;\r\n  const pts = [];\r\n  for (let j = -numPoints; j < numPoints; j++) {\r\n    for (let i = -numPoints; i < numPoints; i++) {\r\n      // pts.push({\r\n      //   x: i * scale,\r\n      //   y: j * scale,\r\n      //   z: 0.0,\r\n      // });\r\n      const p = new Vector3(i * scale, j * scale, 0.0)\r\n      pts.push(p);\r\n    }\r\n  }\r\n  return pts;\r\n};\r\n\r\n\r\n"],"names":["RendererCanvas3DWireframe","constructor","id","render","vecs","pts","cps","circle","polylines","showFrame","showPoint","div","document","getElementById","bounding","getBoundingClientRect","canvas","createElement","width","height","appendChild","ctx","getContext","angleX","Math","PI","angleY","dragging","panning","zoom","lastMouseX","lastMouseY","offsetX","offsetY","panStartX","panStartY","fov","rotate","point","cosX","cos","sinX","sin","cosY","sinY","x","y","z","project","scale","projectionToView","p","rotated","rendering","clearRect","i","this","length","col","strokeStyle","beginPath","j","projectPt","moveTo","lineTo","stroke","vsForLine","forEach","projected","depthScale","radius","size","arc","fillStyle","color","fill","count","vs","push","rotated2","projected2","drawVector","lineWidth","drawCircle","addEventListener","e","button","altKey","clientX","clientY","dx","dy","preventDefault","mouseX","left","mouseY","top","prevZoom","zoomSpeed","max","deltaY","min","scaleChange","origin","vector","start","end","closePath","cp","angle","radians","NURBSCurve","controlPoints","knots","weights","degree","Error","basisFunction","k","t","denom1","denom2","evaluate","n","numerator","denominator","weightBasis","Vector3","Solution","renderer","lns","curve","init","update","nurbsCurve","results","map","tval","vv","console","log","requestAnimationFrame","destroy","lastElementChild","lastChild","removeChild","error","r"],"sourceRoot":""}
{"version":3,"file":"static/js/20803.e054b04d.chunk.js","mappings":"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","sources":["njslab/Tools/Sound-viz-frequency/index.ts"],"sourcesContent":["import { RendererCanvas } from '../../../lib'\r\n\r\nexport class Solution {\r\n    public divHost: HTMLElement;\r\n    public renderer: Renderer;\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id)\r\n\r\n        // Center align\r\n        this.divHost.style.display = 'flex';\r\n        this.divHost.style.alignItems = 'center';\r\n\r\n        const div = document.createElement('div');\r\n        div.style.marginLeft = 'auto';\r\n        div.style.marginRight = 'auto';\r\n        div.style.backgroundColor = '#555';\r\n        div.style.width = '1000px';\r\n        div.style.height = '600px';\r\n\r\n        this.divHost.appendChild(div);\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n\r\n        this.renderer = new Renderer(div);\r\n\r\n        // console.log(this.renderer);\r\n        // !! you should execute it for rendering\r\n        // this.start();\r\n    }\r\n    public destroy() {\r\n        if (this.divHost) {\r\n            try {\r\n                while (this.divHost.firstChild) {\r\n                    this.divHost.removeChild(this.divHost.firstChild);\r\n                }\r\n            } catch (error) {\r\n                console.error('Error in destroy method:', error);\r\n            }\r\n        } else {\r\n            console.warn('divHost is undefined in destroy method');\r\n        }\r\n    }\r\n}\r\n\r\nexport class Renderer extends RendererCanvas {\r\n\r\n    constructor(div: any) {\r\n        super(div);\r\n        this.canvas.style.position = 'relative';\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n        // \r\n\r\n\r\n        this.start();\r\n\r\n\r\n\r\n\r\n        const canvas = this.canvas\r\n        const ctx = this.ctx\r\n    \r\n        // const canvasWidth = canvas.width;\r\n        // const canvasHeight = canvas.height;\r\n        // const centerY = canvasHeight / 2;\r\n    \r\n        // const amplitude = canvasHeight / 4; // 파형 높이\r\n        // const timeScale = 0.01; // 시간 배율\r\n    \r\n        // // 브라우저에서 마이크 접근\r\n        // navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {\r\n        //   const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n        //   const analyser = audioContext.createAnalyser();\r\n        //   const source = audioContext.createMediaStreamSource(stream);\r\n    \r\n        //   // 마이크 입력을 AnalyserNode에 연결\r\n        //   source.connect(analyser);\r\n    \r\n        //   analyser.fftSize = 1024; // FFT 크기\r\n        //   const bufferLength = analyser.frequencyBinCount; // fftSize / 2\r\n        //   const frequencyData = new Uint8Array(bufferLength); // 주파수 데이터를 저장할 배열\r\n    \r\n        //   function drawWave() {\r\n        //     requestAnimationFrame(drawWave);\r\n    \r\n        //     // AnalyserNode에서 주파수 데이터 가져오기\r\n        //     analyser.getByteFrequencyData(frequencyData);\r\n    \r\n        //     // 가장 강한 주파수를 찾기\r\n        //     const maxAmplitude = Math.max(...frequencyData);\r\n        //     const peakFrequencyIndex = frequencyData.indexOf(maxAmplitude);\r\n        //     const nyquist = audioContext.sampleRate / 2;\r\n        //     const frequency = (peakFrequencyIndex / bufferLength) * nyquist; // 주파수 계산\r\n    \r\n        //     // 캔버스 초기화\r\n        //     ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n        //     ctx.fillStyle = '#000';\r\n        //     ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n    \r\n        //     // 축 그리기\r\n        //     ctx.strokeStyle = '#555';\r\n        //     ctx.lineWidth = 1;\r\n        //     ctx.beginPath();\r\n        //     ctx.moveTo(0, centerY);\r\n        //     ctx.lineTo(canvasWidth, centerY);\r\n        //     ctx.stroke();\r\n    \r\n        //     // 사인파 그리기\r\n        //     ctx.strokeStyle = '#ff0000';\r\n        //     ctx.lineWidth = 2;\r\n        //     ctx.beginPath();\r\n        //     for (let x = 0; x < canvasWidth; x++) {\r\n        //       const t = x * timeScale; // 시간 계산\r\n        //       const y = centerY - Math.sin(2 * Math.PI * frequency * t) * amplitude;\r\n        //       if (x === 0) ctx.moveTo(x, y);\r\n        //       else ctx.lineTo(x, y);\r\n        //     }\r\n        //     ctx.stroke();\r\n    \r\n        //     // 코사인파 그리기\r\n        //     ctx.strokeStyle = '#00ff00';\r\n        //     ctx.lineWidth = 2;\r\n        //     ctx.beginPath();\r\n        //     for (let x = 0; x < canvasWidth; x++) {\r\n        //       const t = x * timeScale; // 시간 계산\r\n        //       const y = centerY - Math.cos(2 * Math.PI * frequency * t) * amplitude;\r\n        //       if (x === 0) ctx.moveTo(x, y);\r\n        //       else ctx.lineTo(x, y);\r\n        //     }\r\n        //     ctx.stroke();\r\n    \r\n        //     // 주파수 정보 표시\r\n        //     ctx.fillStyle = '#ffffff';\r\n        //     ctx.font = '16px Arial';\r\n        //     ctx.fillText(`Frequency: ${frequency.toFixed(2)} Hz`, 10, 20);\r\n        //   }\r\n    \r\n        //   drawWave(); // 시각화 함수 호출\r\n        // }).catch((err) => {\r\n        //   console.error('마이크 접근 실패:', err);\r\n        // });\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        \r\n    \r\n        const canvasWidth = canvas.width;\r\n        const canvasHeight = canvas.height;\r\n        const centerY = canvasHeight / 2;\r\n    \r\n        const timeScale = 0.01; // 시간 단위 (X축)\r\n        const amplitude = canvasHeight / 4; // 파형 높이\r\n    \r\n        const frequenciesOverTime = []; // 시간 흐름에 따른 주파수 데이터 저장\r\n    \r\n        // 마이크 입력 가져오기\r\n        navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {\r\n          const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n          const analyser = audioContext.createAnalyser();\r\n          const source = audioContext.createMediaStreamSource(stream);\r\n    \r\n          source.connect(analyser);\r\n          analyser.fftSize = 1024;\r\n          const bufferLength = analyser.frequencyBinCount;\r\n          const frequencyData = new Uint8Array(bufferLength);\r\n    \r\n          function drawWave() {\r\n            requestAnimationFrame(drawWave);\r\n    \r\n            // 주파수 데이터 가져오기\r\n            analyser.getByteFrequencyData(frequencyData);\r\n            const maxAmplitude = Math.max(...frequencyData); // 가장 큰 진폭\r\n            const peakFrequencyIndex = frequencyData.indexOf(maxAmplitude); // 가장 큰 진폭의 인덱스\r\n            const nyquist = audioContext.sampleRate / 2; // Nyquist 주파수 (샘플레이트 절반)\r\n            const frequency = (peakFrequencyIndex / bufferLength) * nyquist; // 현재 프리퀀시\r\n    \r\n            // 새 주파수 데이터 추가\r\n            frequenciesOverTime.push(frequency);\r\n            if (frequenciesOverTime.length > canvasWidth) {\r\n              frequenciesOverTime.shift(); // 캔버스를 넘으면 왼쪽 데이터를 제거\r\n            }\r\n    \r\n            // 캔버스 초기화\r\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n            ctx.fillStyle = '#000';\r\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n    \r\n            // 축 그리기\r\n            ctx.strokeStyle = '#555';\r\n            ctx.lineWidth = 1;\r\n            ctx.beginPath();\r\n            ctx.moveTo(0, centerY);\r\n            ctx.lineTo(canvasWidth, centerY);\r\n            ctx.stroke();\r\n    \r\n            // 시간 흐름에 따른 사인파 그리기\r\n            ctx.strokeStyle = '#ff0000';\r\n            ctx.lineWidth = 2;\r\n            ctx.beginPath();\r\n            for (let x = 0; x < frequenciesOverTime.length; x++) {\r\n              const t = x * timeScale; // 시간 계산\r\n              const y = centerY - Math.sin(2 * Math.PI * frequenciesOverTime[x] * t) * amplitude;\r\n              if (x === 0) ctx.moveTo(x, y);\r\n              else ctx.lineTo(x, y);\r\n            }\r\n            ctx.stroke();\r\n    \r\n            // 시간 흐름에 따른 코사인파 그리기\r\n            ctx.strokeStyle = '#00ff00';\r\n            ctx.lineWidth = 2;\r\n            ctx.beginPath();\r\n            for (let x = 0; x < frequenciesOverTime.length; x++) {\r\n              const t = x * timeScale; // 시간 계산\r\n              const y = centerY - Math.cos(2 * Math.PI * frequenciesOverTime[x] * t) * amplitude;\r\n              if (x === 0) ctx.moveTo(x, y);\r\n              else ctx.lineTo(x, y);\r\n            }\r\n            ctx.stroke();\r\n    \r\n            // 현재 주파수 정보 표시\r\n            ctx.fillStyle = '#ffffff';\r\n            ctx.font = '16px Arial';\r\n            ctx.fillText(`Current Frequency: ${frequency.toFixed(2)} Hz`, 10, 20);\r\n          }\r\n    \r\n          drawWave(); // 시각화 함수 호출\r\n        }).catch((err) => {\r\n          console.error('마이크 접근 실패:', err);\r\n        });\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D): void {\r\n        // TODO\r\n        // You code goes here for the rending loop\r\n\r\n\r\n        // !! can stop render after this frame.\r\n        // this.isStatic = true;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n    // const canvas = document.getElementById('waveCanvas');\r\n    // const ctx = canvas.getContext('2d');\r\n    // const input = document.getElementById('frequency-input');\r\n\r\n    // const canvasWidth = canvas.width;\r\n    // const canvasHeight = canvas.height;\r\n\r\n    // // 기본 설정\r\n    // let frequency = 5; // Hz\r\n    // const amplitude = canvasHeight / 4; // 파형 높이\r\n    // const timeScale = 0.01; // 시간 배율\r\n\r\n    // // 사인/코사인 파형 그리기\r\n    // function drawWave() {\r\n    //   ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n    //   // 캔버스 중심 좌표\r\n    //   const centerY = canvasHeight / 2;\r\n\r\n    //   // 배경 설정\r\n    //   ctx.fillStyle = '#000';\r\n    //   ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n    //   // 축 그리기\r\n    //   ctx.strokeStyle = '#555';\r\n    //   ctx.lineWidth = 1;\r\n    //   ctx.beginPath();\r\n    //   ctx.moveTo(0, centerY);\r\n    //   ctx.lineTo(canvasWidth, centerY);\r\n    //   ctx.stroke();\r\n\r\n    //   // 사인파 그리기\r\n    //   ctx.strokeStyle = '#ff0000';\r\n    //   ctx.lineWidth = 2;\r\n    //   ctx.beginPath();\r\n    //   for (let x = 0; x < canvasWidth; x++) {\r\n    //     const t = x * timeScale; // 시간(t) 계산\r\n    //     const y = centerY - Math.sin(2 * Math.PI * frequency * t) * amplitude;\r\n    //     if (x === 0) ctx.moveTo(x, y);\r\n    //     else ctx.lineTo(x, y);\r\n    //   }\r\n    //   ctx.stroke();\r\n\r\n    //   // 코사인파 그리기\r\n    //   ctx.strokeStyle = '#00ff00';\r\n    //   ctx.lineWidth = 2;\r\n    //   ctx.beginPath();\r\n    //   for (let x = 0; x < canvasWidth; x++) {\r\n    //     const t = x * timeScale; // 시간(t) 계산\r\n    //     const y = centerY - Math.cos(2 * Math.PI * frequency * t) * amplitude;\r\n    //     if (x === 0) ctx.moveTo(x, y);\r\n    //     else ctx.lineTo(x, y);\r\n    //   }\r\n    //   ctx.stroke();\r\n\r\n    //   // 주파수 간격 표시\r\n    //   ctx.fillStyle = '#ffffff';\r\n    //   ctx.font = '14px Arial';\r\n    //   for (let x = 0; x < canvasWidth; x += (1 / frequency) / timeScale) {\r\n    //     ctx.beginPath();\r\n    //     ctx.moveTo(x, centerY - 10);\r\n    //     ctx.lineTo(x, centerY + 10);\r\n    //     ctx.stroke();\r\n\r\n    //     const freqText = `${(x * timeScale).toFixed(2)}s`;\r\n    //     ctx.fillText(freqText, x - 10, centerY + 25);\r\n    //   }\r\n    // }\r\n\r\n    // // 입력값이 변경될 때 주파수 갱신\r\n    // input.addEventListener('input', (e) => {\r\n    //   frequency = parseFloat(e.target.value) || 5; // 기본값: 5Hz\r\n    //   drawWave();\r\n    // });\r\n\r\n    // // 초기 그리기\r\n    // drawWave();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // const startAudioVisualization = async () => {\r\n    //     try {\r\n    //       const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n          \r\n    //       // Create audio context and analyser\r\n    //       const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n    //       const analyser = audioContext.createAnalyser();\r\n    //       const source = audioContext.createMediaStreamSource(stream);\r\n    //       source.connect(analyser);\r\n          \r\n    //       // Configure analyser\r\n    //       analyser.fftSize = 2048;\r\n    //       const bufferLength = analyser.frequencyBinCount;\r\n    //       const dataArray = new Uint8Array(bufferLength);\r\n          \r\n    //       audioContextRef.current = audioContext;\r\n    //       analyserRef.current = analyser;\r\n          \r\n    //       setIsRecording(true);\r\n          \r\n    //       // Start visualization\r\n    //       const canvas = canvasRef.current;\r\n    //       const canvasCtx = canvas.getContext('2d');\r\n          \r\n    //       const drawVisualization = () => {\r\n    //         // Clear canvas\r\n    //         canvasCtx.clearRect(0, 0, canvas.width, canvas.height);\r\n            \r\n    //         // Get frequency data\r\n    //         analyser.getByteFrequencyData(dataArray);\r\n            \r\n    //         // Draw background\r\n    //         canvasCtx.fillStyle = 'rgb(0, 0, 0)';\r\n    //         canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\r\n            \r\n    //         // Draw sine wave visualization\r\n    //         const centerY = canvas.height / 2;\r\n    //         canvasCtx.lineWidth = 2;\r\n    //         canvasCtx.strokeStyle = 'rgb(0, 255, 0)';\r\n            \r\n    //         canvasCtx.beginPath();\r\n            \r\n    //         const sliceWidth = canvas.width / bufferLength;\r\n    //         let x = 0;\r\n            \r\n    //         for (let i = 0; i < bufferLength; i++) {\r\n    //           const v = dataArray[i] / 128.0;\r\n    //           const y = v * centerY;\r\n              \r\n    //           // Sine wave representation of frequency\r\n    //           const frequency = i * audioContext.sampleRate / analyser.fftSize;\r\n    //           const amplitude = y;\r\n              \r\n    //           if (i === 0) {\r\n    //             canvasCtx.moveTo(x, centerY);\r\n    //           } else {\r\n    //             canvasCtx.lineTo(x, centerY + amplitude * Math.sin(x / 20 * Math.PI * frequency / 1000));\r\n    //           }\r\n              \r\n    //           x += sliceWidth;\r\n    //         }\r\n            \r\n    //         canvasCtx.stroke();\r\n            \r\n    //         // Continue animation\r\n    //         animationFrameRef.current = requestAnimationFrame(drawVisualization);\r\n    //       };\r\n          \r\n    //       drawVisualization();\r\n\r\n\r\n    "],"names":["Solution","constructor","id","divHost","renderer","this","document","getElementById","style","display","alignItems","div","createElement","marginLeft","marginRight","backgroundColor","width","height","appendChild","Renderer","destroy","firstChild","removeChild","error","console","warn","RendererCanvas","super","canvas","position","start","ctx","canvasWidth","canvasHeight","centerY","timeScale","amplitude","frequenciesOverTime","navigator","mediaDevices","getUserMedia","audio","then","stream","audioContext","window","AudioContext","webkitAudioContext","analyser","createAnalyser","createMediaStreamSource","connect","fftSize","bufferLength","frequencyBinCount","frequencyData","Uint8Array","drawWave","requestAnimationFrame","getByteFrequencyData","maxAmplitude","Math","max","peakFrequencyIndex","indexOf","nyquist","sampleRate","frequency","push","length","shift","clearRect","fillStyle","fillRect","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","x","t","y","sin","PI","cos","font","fillText","toFixed","catch","err","render"],"sourceRoot":""}
{"version":3,"file":"static/js/32587.350b1e37.chunk.js","mappings":"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","sources":["njslab/LabStarter/AppNGL3d/NGL3dApp_08/Geometry/Core/Base.ts","njslab/LabStarter/AppNGL3d/NGL3dApp_08/Geometry/CustomGeometry/RectScreen.ts","njslab/LabStarter/AppNGL3d/NGL3dApp_08/Utility/GLShaderCommon.ts"],"sourcesContent":["import { Scene } from '../../Core/Scene';\r\n\r\nexport class GeometryBase {\r\n    scene: Scene;\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.add(this);\r\n    }\r\n    render() {\r\n        //\r\n    }\r\n}","import { GLShaderCommon } from '../../Utility/GLShaderCommon';\r\n\r\nimport { GeometryBase } from '../Core/Base';\r\nimport { NGL3dApp } from '../..';\r\n\r\nexport class RectScreen extends GeometryBase {\r\n\r\n    v = `#version 300 es\r\n\r\n    in vec2 a_position;\r\n    uniform vec2 u_resolution;\r\n\r\n    void main() {\r\n        gl_Position = vec4(a_position , 0, 1);\r\n    }\r\n    `;\r\n\r\n    f = `#version 300 es\r\n\r\n    precision mediump float;\r\n    uniform vec4 u_color;\r\n\r\n    out vec4 outColor;\r\n\r\n    void main() {\r\n        outColor = u_color;\r\n    }\r\n    `;\r\n\r\n    app: NGL3dApp;\r\n\r\n    gl: WebGL2RenderingContext;\r\n    program: WebGLProgram | null;\r\n\r\n    positionAttributeLocation: number;\r\n\r\n    resolutionUniformLocation: WebGLUniformLocation | null;\r\n    colorLocation: WebGLUniformLocation | null;\r\n\r\n    positionBuffer: WebGLBuffer | null;\r\n    vao: WebGLVertexArrayObject | null;\r\n\r\n    translation: number[] = [];\r\n    color: number[] = [];\r\n    width: number;\r\n    height: number;\r\n\r\n    mesh: Float32Array;\r\n\r\n    constructor(app: NGL3dApp) {\r\n        super(app.scene);\r\n        this.gl = app.canvas.gl;\r\n\r\n        this.program = GLShaderCommon.getShaderProgram(this.gl, this.v, this.f);\r\n\r\n        if (this.program) {\r\n            this.positionAttributeLocation = this.gl.getAttribLocation(this.program, 'a_position');\r\n\r\n            this.resolutionUniformLocation = this.gl.getUniformLocation(this.program, 'u_resolution');\r\n            this.colorLocation = this.gl.getUniformLocation(this.program, 'u_color');\r\n        }\r\n        this.positionBuffer = this.gl.createBuffer();\r\n        this.vao = this.gl.createVertexArray();\r\n        this.gl.bindVertexArray(this.vao);\r\n\r\n        this.gl.enableVertexAttribArray(this.positionAttributeLocation);\r\n\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\r\n\r\n        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n        var size = 2;          // 2 components per iteration\r\n        var type = this.gl.FLOAT;   // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n        var offset = 0;        // start at the beginning of the buffer\r\n        this.gl.vertexAttribPointer(this.positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        // First let's make some variables\r\n        // to hold the translation, width and height of the rectangle\r\n        this.translation = [-1, -1];\r\n        this.color = [Math.random(), Math.random(), Math.random(), 1];\r\n        this.width = 0.5;\r\n        this.height = 0.5;\r\n\r\n        this.mesh = new Float32Array(this.getRectangle(this.translation[0], this.translation[1], this.width, this.height));\r\n\r\n        this.gl.useProgram(this.program);\r\n        this.gl.uniform2f(this.resolutionUniformLocation, this.gl.canvas.width, this.gl.canvas.height);\r\n        this.gl.uniform4fv(this.colorLocation, this.color);\r\n        this.gl.useProgram(null);\r\n\r\n    }\r\n    getRectangle(x: number, y: number, width: number, height: number) {\r\n        let x1 = x;\r\n        let x2 = x + width;\r\n        let y1 = y;\r\n        let y2 = y + height;\r\n\r\n        return [\r\n            x1, y1,\r\n            x2, y1,\r\n            x1, y2,\r\n            x1, y2,\r\n            x2, y1,\r\n            x2, y2,\r\n        ];\r\n    }\r\n    render() {\r\n        this.gl.useProgram(this.program);\r\n\r\n        this.gl.bindVertexArray(this.vao);\r\n\r\n        // Pass in the canvas resolution so we can convert from\r\n        // pixels to clipspace in the shader\r\n\r\n        // Update the position buffer with rectangle positions\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\r\n\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.mesh, this.gl.STATIC_DRAW);\r\n\r\n        // Draw the rectangle.\r\n        var primitiveType = this.gl.TRIANGLES;\r\n        var offset = 0;\r\n        var count = 6;\r\n        this.gl.drawArrays(primitiveType, offset, count);\r\n\r\n    }\r\n\r\n}","\r\nexport class GLShaderCommon {\r\n\r\n    static getShaderProgram(gl: WebGL2RenderingContext, vertexShader: string, fragmentShader: string, needValidate: boolean = true) {\r\n        let vShader = GLShaderCommon.createShader(gl, gl.VERTEX_SHADER as unknown as WebGLShader, vertexShader);\r\n        let fShader = GLShaderCommon.createShader(gl, gl.FRAGMENT_SHADER as unknown as WebGLShader, fragmentShader);\r\n        if (vShader && fShader) {\r\n            let program = GLShaderCommon.createProgram(gl, vShader, fShader, needValidate);\r\n\r\n            if (program) {\r\n                return program;\r\n            } else {\r\n                console.error('vertex fragment shader error'); return null;\r\n            }\r\n        } else {\r\n            console.error('vertex fragment shader error'); return null;\r\n        }\r\n    }\r\n    static getShader(gl: WebGL2RenderingContext, type: number, source: string) {\r\n        const shader = gl.createShader(type);\r\n        if (shader === null) { return null; }\r\n        gl.shaderSource(shader, source);\r\n        gl.compileShader(shader);\r\n\r\n        // Check if compiled successfully\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n            console.log('An error occurred compiling the shaders:' + gl.getShaderInfoLog(shader));\r\n            gl.deleteShader(shader);\r\n            return null;\r\n        }\r\n        // Set the attributes, varying, and uniform to shader\r\n        // shader.attributes = this.attributesFromSource(source);\r\n        // shader.varyings = this.varyingsFromSource(source);\r\n        // shader.uniforms = this.uniformsFromSource(source);\r\n        return shader;\r\n    }\r\n    static createProgram(gl: WebGL2RenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader, needValidate: boolean = true): WebGLProgram | null {\r\n        const program = gl.createProgram();\r\n        if (program === null) { return null; }\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n\r\n        // gl.bindAttribLocation(program,ATTR_POSITION_LOC,ATTR_POSITION_NAME);\r\n        // gl.bindAttribLocation(program,ATTR_NORMAL_LOC,ATTR_NORMAL_NAME);\r\n        // gl.bindAttribLocation(program,ATTR_UV_LOC,ATTR_UV_NAME);\r\n\r\n        gl.linkProgram(program);\r\n\r\n        // Check that shader program was able to link to WebGL\r\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n            const error = gl.getProgramInfoLog(program);\r\n            console.log('Failed to link program: ' + error);\r\n            gl.deleteProgram(program);\r\n            gl.deleteShader(fragmentShader);\r\n            gl.deleteShader(vertexShader);\r\n            return null;\r\n        }\r\n        if (needValidate) {\r\n            gl.validateProgram(program);\r\n            if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\r\n                console.error('Failed to validate program', gl.getProgramInfoLog(program));\r\n                gl.deleteProgram(program);\r\n                gl.deleteShader(fragmentShader);\r\n                gl.deleteShader(vertexShader);\r\n                return null;\r\n            }\r\n        }\r\n        gl.deleteShader(fragmentShader);\r\n        gl.deleteShader(vertexShader);\r\n        return program;\r\n    }\r\n\r\n    // ...............................\r\n\r\n    // static CreateShader(gl: WebGL2RenderingContext, type: WebGLShader, shaderString: string) {\r\n    //     let shader = gl.createShader(type as number);\r\n    //     gl.shaderSource(shader, shaderString);\r\n    //     gl.compileShader(shader);\r\n    //     gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    //     return shader as Webglsh;\r\n    //     // console.log(gl.getShaderInfoLog(shader));\r\n    //     // gl.deleteShader(shader);\r\n    //     // return null;\r\n    // }\r\n    static createShader(gl: WebGL2RenderingContext, type: WebGLShader, shaderString: string) {\r\n        // console.log(type);\r\n        const shader = gl.createShader(type as unknown as number);\r\n        if (shader === null) { return null; }\r\n        gl.shaderSource(shader, shaderString);\r\n        gl.compileShader(shader);\r\n        const suc = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if (suc) { return shader; }\r\n        console.log(gl.getShaderInfoLog(shader));\r\n        gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n    static createShaderFromPath(gl: WebGL2RenderingContext, type: WebGLShader, url: string) {\r\n        const shader = gl.createShader(type as unknown as number);\r\n        if (shader === null) { return null; }\r\n        gl.shaderSource(shader, GLShaderCommon.getSourceSynch(url) as string);\r\n        gl.compileShader(shader);\r\n        const suc = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if (suc) { return shader; }\r\n        console.log(gl.getShaderInfoLog(shader));\r\n        gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n\r\n    static getSourceSynch(url: string) {\r\n        const req = new XMLHttpRequest();\r\n        req.open('GET', url, false);\r\n        req.send(null);\r\n        return (req.status === 200) ? req.responseText : null;\r\n    }\r\n\r\n    // static LoadTextResource(url: string, callback:(data: any, d2:any) => void ) {\r\n    //     let request = new XMLHttpRequest();\r\n    //     request.open('GET', url + '?please-dont-cache=' + Math.random(), true);\r\n    //     request.onload = function () {\r\n    //         if (request.status < 200 || request.status > 299) {\r\n    //             callback('Error: HTTP Status ' + request.status + ' on resource ' + url);\r\n    //         } else {\r\n    //             callback(null, request.responseText);\r\n    //         }\r\n    //     };\r\n    //     request.send();\r\n    // }\r\n    // static LoadShader(url: string, callback:(data: null, callback:string) => void ) {\r\n    //     GLUtility.LoadTextResource(url, callback);\r\n    // }\r\n    static loadImage(url: string, callback: (data: null, image: HTMLElement) => void) {\r\n        const image = new Image();\r\n        image.onload = function () {\r\n            callback(null, image);\r\n        };\r\n        image.src = url;\r\n    }\r\n    // static LoadJSONResource(url: string, callback:(data: string, callback:string) => void ) {\r\n    //     GLUtility.LoadTextResource(url, function (err: Error, result) {\r\n    //         if (err) {\r\n    //             callback(err);\r\n    //         } else {\r\n    //             try {\r\n    //                 callback(null, JSON.parse(result));\r\n    //             } catch (e) {\r\n    //                 callback(e);\r\n    //             }\r\n    //         }\r\n    //     });\r\n    // }\r\n}\r\n"],"names":["GeometryBase","constructor","scene","this","add","render","RectScreen","app","super","v","f","gl","program","positionAttributeLocation","resolutionUniformLocation","colorLocation","positionBuffer","vao","translation","color","width","height","mesh","canvas","GLShaderCommon","getAttribLocation","getUniformLocation","createBuffer","createVertexArray","bindVertexArray","enableVertexAttribArray","bindBuffer","ARRAY_BUFFER","type","FLOAT","vertexAttribPointer","Math","random","Float32Array","getRectangle","useProgram","uniform2f","uniform4fv","x","y","x2","y2","bufferData","STATIC_DRAW","primitiveType","TRIANGLES","drawArrays","static","vertexShader","fragmentShader","needValidate","vShader","createShader","VERTEX_SHADER","fShader","FRAGMENT_SHADER","createProgram","console","error","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","log","getShaderInfoLog","deleteShader","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","validateProgram","VALIDATE_STATUS","shaderString","url","getSourceSynch","req","XMLHttpRequest","open","send","status","responseText","callback","image","Image","onload","src"],"sourceRoot":""}
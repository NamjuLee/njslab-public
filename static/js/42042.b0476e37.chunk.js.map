{"version":3,"file":"static/js/42042.b0476e37.chunk.js","mappings":"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","sources":["njslab/GIS/Clustering/ClusteringCollisionBasedGraph/lib/index.ts","njslab/GIS/Clustering/ClusteringCollisionBasedGraph/Core/PointCluster.ts","njslab/GIS/Clustering/ClusteringCollisionBasedGraph/Core/Renderer.ts","njslab/GIS/Clustering/ClusteringCollisionBasedGraph/Core/GraphClustering.ts","njslab/GIS/Clustering/ClusteringCollisionBasedGraph/index.ts","njslab/GIS/Clustering/MapboxGLWrapper/index.ts","njslab/GIS/Clustering/index.ts"],"sourcesContent":["\nexport const AABBintersect2D = (v0: NVector3[], v1: NVector3[]): boolean => {\n    const v0minX = v0[0].x;\n    const v0maxX = v0[1].x;\n    const v1minX = v1[0].x;\n    const v1maxX = v1[1].x;\n    const v0minY = v0[0].y;\n    const v0maxY = v0[1].y;\n    const v1minY = v1[0].y;\n    const v1maxY = v1[1].y;\n    // const v0minZ = 0;\n    // const v0maxZ = 0;\n    // const v1minZ = 0;\n    // const v1maxZ = 0;\n    return (v0minX <= v1maxX && v0maxX >= v1minX) &&\n        (v0minY <= v1maxY && v0maxY >= v1minY); // &&\n    // (v0minZ <= v1maxZ && v0maxZ >= v1minZ);\n};\nexport const distance = (v0: NVector3, v1: NVector3): number => {\n    return Math.sqrt((v0.x - v1.x) * (v0.x - v1.x) + (v0.y - v1.y) * (v0.y - v1.y) + (v0.z - v1.z) * (v0.z - v1.z));\n    // return NWebassemblyController.ctrller.Distance(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n}\n\nexport class NVector3 {\n    public x: number = 0;\n    public y: number = 0;\n    public z: number = 0;\n    public lon: number = 0;\n    public lat: number = 0;\n    public elevation: number = 0;\n\n    public d: boolean = true;\n    public isRenderable: boolean = true;\n\n    constructor(x: number = 0, y: number = 0, z: number = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\n\n\nexport class CPoint {\n    public vec: NVector3;\n    public id: string = '';\n    public numVisit: number = 0;\n    public radius: number = 10;\n\n    public isCollapse: boolean = false;\n\n    public isHidden: boolean = false;\n    public isRenderable: boolean = true;\n\n    public isSelected: boolean = false;\n    public isHover: boolean = false;\n    public collision: Collision;\n    constructor(x: number, y: number) {\n        this.vec = new NVector3(x, y, 0);\n        this.updateBounding();\n    }\n    public updateBounding() {\n        this.collision = new Collision(this);\n    }\n    public render(ctx: CanvasRenderingContext2D) {\n        ctx.beginPath();\n        ctx.arc(this.vec.x, this.vec.y, this.radius, 0, Math.PI * 2);\n        ctx.closePath();\n        if (this.isCollapse) {\n            ctx.fillStyle = '#f00';\n        } else {\n            ctx.fillStyle = '#0f0';\n        }\n        ctx.fill();\n\n        this.renderBoundingBox(ctx)\n    }\n    public renderBoundingBox(ctx: CanvasRenderingContext2D){\n        ctx.beginPath();\n        ctx.rect(\n            this.collision.minVec.x, this.collision.minVec.y, \n            (this.collision.maxVec.x - this.collision.minVec.x),\n            (this.collision.maxVec.y - this.collision.minVec.y)\n            )\n        ctx.stroke();\n    }\n}\nexport class Collision {\n    base: CPoint;\n    isCollided: boolean = false;\n\n    neighborShapes: CPoint[] = [];\n\n    minVec: NVector3;\n    maxVec: NVector3;\n\n    isVisited: boolean = false;\n    numOrder: number = -1;\n\n    constructor(base: CPoint) {\n        this.base = base;\n        const r = this.base.radius;\n        this.minVec = new NVector3(this.base.vec.x - r, this.base.vec.y - r, 0);\n        this.maxVec = new NVector3(this.base.vec.x + r, this.base.vec.y + r, 0);\n    }\n    public Reset(){\n        this.neighborShapes = [];\n        this.numOrder = -1;\n        this.base.numVisit = 0;\n        this.base.isCollapse = false;\n        this.isCollided = false;\n        this.isVisited = false;\n    }\n}","\r\n// import { GeometryBase } from '../../../DrawingEngine/Geometry/Base';\r\n// import { GTYPE } from '../../../../../../../lib/Enumeration';\r\nimport { distance, NVector3, CPoint} from '../lib';\r\n// import { NVector3 } from '../../../../../../../lib/NVector3';\r\nimport { Renderer } from './Renderer';\r\n\r\nexport class PointCluster {\r\n    renderer: Renderer;\r\n    points: CPoint[];\r\n    r0: number = 32 * 0.5;\r\n    r1: number = 48 * 0.5;\r\n    isHover: boolean = false;\r\n    isVisited: boolean = false;\r\n    boundingBoxMin: NVector3 = new NVector3(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\n    boundingBoxMax: NVector3 = new NVector3(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);\r\n    minVec: NVector3;\r\n    maxVec: NVector3;\r\n    vec = new NVector3(0, 0, 0);\r\n    private t: number = 1.0;\r\n    private GridResolution = 85;\r\n    private tempVecGridList: NVector3[] = [];\r\n    private tempGeoGridList: CPoint[][][] = [];\r\n\r\n    constructor(renderer: Renderer, geometries: CPoint[]) {\r\n        this.renderer = renderer;\r\n        this.points = geometries;\r\n        for(let i = 0; i < this.points.length; ++i) {\r\n            this.vec.x += this.points[i].vec.x;\r\n            this.vec.y += this.points[i].vec.y;\r\n            this.UpdateBoundingBox(this.points[i].vec);\r\n        }\r\n        this.vec.x /= this.points.length;\r\n        this.vec.y /= this.points.length;\r\n        this.minVec = new NVector3(this.vec.x - this.r1, this.vec.y - this.r1, 0);\r\n        this.maxVec = new NVector3(this.vec.x + this.r1, this.vec.y + this.r1, 0);\r\n        // for(let i = 0; i < this.geometries.length; ++i) {\r\n        // this.geometries[i].isAniEasing = true;\r\n        // this.geometries[i].tVec = this.vec;\r\n        // }\r\n    }\r\n    public IsInside(m: NVector3) {\r\n        if(distance(this.vec, m ) < this.r1) {\r\n            this.isHover = true;\r\n            // this.points[0].scene.annotationInstance.activeCommandController.activeMouseCursor.SetActiveCursorHovering();\r\n            // this.points[0].scene.annotationInstance.renderer.needFocus = true;\r\n            // this.points[0].scene.annotationInstance.activeCommandController.acProperties.hasHovering = true;\r\n            return true;\r\n        } else {\r\n            this.isHover = false;\r\n            return false;\r\n        }\r\n    }\r\n    public AddPost(geo: CPoint) {\r\n        // @ts-ignore\r\n        if(this.points.includes(geo)) { return; }\r\n        this.points.push(geo);\r\n        this.vec = new NVector3(0, 0, 0);\r\n        for(let i = 0; i < this.points.length; ++i) {\r\n        this.vec.x += this.points[i].vec.x;\r\n        this.vec.y += this.points[i].vec.y;\r\n        this.UpdateBoundingBox(this.points[i].vec);\r\n        }\r\n        this.vec.x /= this.points.length;\r\n        this.vec.y /= this.points.length;\r\n        this.minVec = new NVector3(this.vec.x - this.r1, this.vec.y - this.r1, 0);\r\n        this.maxVec = new NVector3(this.vec.x + this.r1, this.vec.y + this.r1, 0);\r\n    }\r\n    public NeedDecompose() {\r\n        if (this.boundingBoxMax.x - this.boundingBoxMin.x > this.GridResolution) { return true; }\r\n        if (this.boundingBoxMax.y - this.boundingBoxMin.y > this.GridResolution) { return true; }\r\n        return false;\r\n    }\r\n    public Split() {\r\n        this.DeepRemove();\r\n        const xNum = (this.boundingBoxMax.x - this.boundingBoxMin.x) / this.GridResolution < 1 ? 1: (this.boundingBoxMax.x - this.boundingBoxMin.x) / this.GridResolution;\r\n        const yNum = (this.boundingBoxMax.y - this.boundingBoxMin.y) / this.GridResolution < 1 ? 1: (this.boundingBoxMax.y - this.boundingBoxMin.y) / this.GridResolution;\r\n        const grid = this.buildGrid(xNum, yNum);\r\n        this.BuildSubCluster(grid, xNum, yNum);\r\n    }\r\n    public Merge(other: PointCluster){\r\n        this.points.concat(other.points);\r\n        this.vec = new NVector3(0, 0, 0);\r\n        for(let i = 0; i < this.points.length; ++i) {\r\n            this.vec.x += this.points[i].vec.x;\r\n            this.vec.y += this.points[i].vec.y;\r\n            this.UpdateBoundingBox(this.points[i].vec);\r\n        }\r\n        this.vec.x /= this.points.length;\r\n        this.vec.y /= this.points.length;\r\n        this.minVec = new NVector3(this.vec.x - this.r1, this.vec.y - this.r1, 0);\r\n        this.maxVec = new NVector3(this.vec.x + this.r1, this.vec.y + this.r1, 0);\r\n        other.DeepRemove();\r\n    }\r\n    public DeepRemove(){\r\n        this.renderer.RemoveCluster(this);\r\n    }\r\n    public buildGrid(xNum: number, yNum: number) {\r\n        this.tempGeoGridList = []\r\n        let gridList = [];;\r\n        for(let y = 0; y < yNum; ++y) {\r\n            const theY = this.boundingBoxMin.y + y * this.GridResolution;\r\n            const geoMat: CPoint[][] = [];\r\n            for(let x = 0; x < xNum; ++x) {\r\n                const theX = this.boundingBoxMin.x + x * this.GridResolution;\r\n                gridList.push(new NVector3(theX, theY));\r\n                const geoList: CPoint[]= [];\r\n                geoMat.push(geoList);\r\n            }\r\n            this.tempGeoGridList.push(geoMat);\r\n        }\r\n        this.tempVecGridList = gridList;\r\n        return gridList;\r\n    }\r\n    public BuildSubCluster(vs: NVector3[], xNum: number, yNum: number){\r\n        for(let i = 0 ; i < this.points.length; ++i) {\r\n            this.GetCellAtPoint(this.points[i].vec, xNum, yNum).push(this.points[i]);\r\n        }\r\n        for(let y = 0; y < this.tempGeoGridList.length; ++y) {\r\n            for(let x = 0; x < this.tempGeoGridList[y].length; ++x) {\r\n            if(this.tempGeoGridList[y][x]) {\r\n                if (this.tempGeoGridList[y][x].length === 1) {\r\n                    this.tempGeoGridList[y][x][0].collision.Reset();\r\n                } else if(this.tempGeoGridList[y][x].length > 1) {\r\n                    this.renderer.clustersRPoint.push(new PointCluster(this.renderer, this.tempGeoGridList[y][x]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private GetCellAtPoint(tv: NVector3, xNum: number, yNum: number) {\r\n        let dp: NVector3 = new NVector3(tv.x - this.boundingBoxMin.x, tv.y - this.boundingBoxMin.y);\r\n        // let dp: NVector3 = new NVector3(this.boundingBoxMin.x - tv.x, this.boundingBoxMin.y - tv.y);\r\n        let i: number = Math.round(dp.x / this.GridResolution);\r\n        let j: number = Math.round(dp.y / this.GridResolution);\r\n        if (i >= xNum) { i = xNum - 1; }\r\n        if (j >= yNum) { j = yNum - 1; }\r\n        if (i < 0) { i = 0; }\r\n        if (j < 0) { j = 0; }\r\n        i = Math.round(i);\r\n        j = Math.round(j);\r\n        // console.log(j, i);\r\n        // console.log(this.tempGeoGridList)\r\n        return this.tempGeoGridList[j][i];\r\n    }\r\n    public Draw(ctx: CanvasRenderingContext2D, renderer: Renderer, isPanning: boolean, toScreen: (x: number, y: number) => number[]) {\r\n        this.UpdateTimeer();\r\n\r\n        if (isPanning) {\r\n            this.vec = new NVector3(0, 0, 0);\r\n            this.boundingBoxMin = new NVector3(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\n            this.boundingBoxMax = new NVector3(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);\r\n            for(let i = 0; i < this.points.length; ++i) {\r\n                this.vec.x += this.points[i].vec.x;\r\n                this.vec.y += this.points[i].vec.y;\r\n                this.UpdateBoundingBox(this.points[i].vec);\r\n            }\r\n            this.vec.x /= this.points.length;\r\n            this.vec.y /= this.points.length;\r\n            this.minVec = new NVector3(this.vec.x - this.r1, this.vec.y - this.r1, 0);\r\n            this.maxVec = new NVector3(this.vec.x + this.r1, this.vec.y + this.r1, 0);\r\n            // this.vec.y -= this.r * 0.5 // offset the ghost center along y\r\n        }\r\n\r\n        // const sp = toScreen(this.vec.x, this.vec.y)\r\n        // this.vec.x = sp[0];\r\n        // this.vec.y = sp[1];\r\n\r\n        drawingPresetClustering(ctx, this.points, this.vec, this.r0, this.r1, this.isHover, this.t);\r\n        \r\n        if(renderer.optimizer.inspection) {\r\n            ctx.beginPath();\r\n            ctx.rect(this.minVec.x, this.minVec.y, this.maxVec.x - this.minVec.x, this.maxVec.y - this.minVec.y)\r\n            ctx.closePath();\r\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\r\n            ctx.fill();\r\n            ctx.lineWidth = 0.5;\r\n            ctx.beginPath();\r\n            ctx.rect(this.boundingBoxMin.x, this.boundingBoxMin.y, this.boundingBoxMax.x - this.boundingBoxMin.x, this.boundingBoxMax.y - this.boundingBoxMin.y)\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n            if (this.tempVecGridList.length > 0) {\r\n                for(let i = 0 ; i < this.tempVecGridList.length; ++i) {\r\n                    ctx.beginPath();\r\n                    ctx.rect(this.tempVecGridList[i].x, this.tempVecGridList[i].y, this.GridResolution, this.GridResolution);\r\n                    ctx.closePath();\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n    private UpdateTimeer(){\r\n        if (true ) {\r\n            this.t -= 0.1; // this.points[0].scene.annotationInstance.customization.themeCurrent.properties.timeTransitionA;\r\n            this.t = this.t < 0.4 ? 0.4 : this.t;\r\n        } else {\r\n            this.t += 0.1; // this.points[0].scene.annotationInstance.customization.themeCurrent.properties.timeTransitionB;\r\n            this.t = this.t > 1 ? 1 : this.t;\r\n        }\r\n    }\r\n    private UpdateBoundingBox(vec: NVector3){\r\n        this.boundingBoxMin.x = vec.x < this.boundingBoxMin.x ? vec.x : this.boundingBoxMin.x;\r\n        this.boundingBoxMin.y = vec.y < this.boundingBoxMin.y ? vec.y : this.boundingBoxMin.y;\r\n        this.boundingBoxMax.x = vec.x > this.boundingBoxMax.x ? vec.x : this.boundingBoxMax.x;\r\n        this.boundingBoxMax.y = vec.y > this.boundingBoxMax.y ? vec.y : this.boundingBoxMax.y;\r\n    }\r\n}\r\n\r\n\r\nconst drawingPresetClustering = (\r\n    ctx: CanvasRenderingContext2D,\r\n    geometries: CPoint[],\r\n    vec: NVector3,\r\n    r0: number,\r\n    r1: number,\r\n    isHover: boolean,\r\n    t = 1\r\n  ) => {\r\n\r\n    const colorFillHover = '#f00'; \r\n    const fillColor = '#0f0'; //`rgba(${geometries[0].styleComponent.renderStyle.colorInterpolatedString})`\r\n\r\n    // if (renderer.optimizer.optimizer.optimizer.renderer.annotationInstance.implementations.app.INSPECTION) {\r\n    if (isHover) {\r\n      for (let i = 0; i < geometries.length; ++i) {\r\n        ctx.lineWidth = 0.6;\r\n        ctx.strokeStyle = '#f00' // geometries[0].styleComponent.renderStyle.colorFill;\r\n        ctx.beginPath();\r\n        ctx.moveTo(vec.x, vec.y);\r\n        ctx.lineTo(geometries[i].vec.x, geometries[i].vec.y);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n\r\n        // sub points\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeStyle = 'rgba(255, 255, 255, 1)';\r\n        ctx.fillStyle = '#f00' //geometries[0].styleComponent.renderStyle.colorFill;\r\n        ctx.beginPath();\r\n        ctx.arc(geometries[i].vec.x, geometries[i].vec.y, 4, 0, Math.PI * 2);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.stroke();\r\n      }\r\n    }\r\n\r\n    // center point\r\n    if (isHover) {\r\n      ctx.fillStyle = '#f00' // geometries[0].styleComponent.renderStyle.colorFill;\r\n      ctx.beginPath();\r\n      ctx.arc(vec.x, vec.y, 1.5, 0, Math.PI * 2);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n    } else {\r\n      // if(this.type === GTYPE.POINT_NUMBERED) {\r\n      //   ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\r\n      // } else if(this.type === GTYPE.POINT_REGULAR) {\r\n      //   ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\r\n      // }\r\n      ctx.beginPath();\r\n      ctx.arc(vec.x, vec.y, r1, 0, Math.PI * 2);\r\n      ctx.closePath();\r\n      ctx.fillStyle = colorFillHover;\r\n      ctx.fill();\r\n      ctx.beginPath();\r\n      ctx.arc(vec.x, vec.y, r0, 0, Math.PI * 2);\r\n      ctx.closePath();\r\n      ctx.fillStyle = fillColor;\r\n      ctx.fill();\r\n\r\n      ctx.fillStyle = `rgba(255, 255, 255, 1)`;\r\n      ctx.font = 'bold 11px Arial';\r\n      // ctx.font='bold 9px NotoSerif-Bold';\r\n      ctx.textAlign = 'center';\r\n      ctx.fillText(`${geometries.length}`, vec.x, vec.y + 4);\r\n    }\r\n  };","import { PointCluster } from './PointCluster';\r\nimport { CPoint } from '../lib';\r\nimport { ClusteringCollisionBasedGraph } from '../';\r\n\r\nexport class Renderer {\r\n\r\n    clustersRPoint: PointCluster[] = [];\r\n    optimizer: ClusteringCollisionBasedGraph;\r\n    constructor(optimizer: ClusteringCollisionBasedGraph) {\r\n        this.optimizer = optimizer;\r\n    }\r\n    public InitGeometry(){\r\n        this.clustersRPoint = [];\r\n    }\r\n    public addClusterByGeometries(geo: CPoint[][] ) {\r\n        for(let i = 0; i < geo.length; ++i) {\r\n            this.clustersRPoint.push(new PointCluster(this, geo[i]));\r\n        }\r\n    }\r\n    public RemoveCluster(cluster: PointCluster ){\r\n        this.clustersRPoint.splice(this.clustersRPoint.indexOf(cluster), 1);\r\n\r\n    }\r\n    public Render(ctx: CanvasRenderingContext2D, isStationary: boolean, toScreen: (x: number, y: number) => number[]): void {\r\n        // console.log(this.clustersRPoint.length);\r\n        if (this.clustersRPoint.length > 0) {\r\n            for(let i = 0 ; i < this.clustersRPoint.length; ++i) {\r\n                this.clustersRPoint[i].Draw(ctx, this, isStationary, toScreen);\r\n            }\r\n        }\r\n\r\n    }\r\n}","\r\n// import { GeometryBase } from '../../../DrawingEngine/Geometry/Base/GeometryBase';\r\nimport { PointCluster } from './PointCluster';\r\nimport { ClusteringCollisionBasedGraph } from '..';\r\n\r\nimport { distance, AABBintersect2D, CPoint } from '../lib';\r\n\r\nexport class GraphClustering {\r\n\r\n    optimizer: ClusteringCollisionBasedGraph;\r\n    pointList: CPoint[] = []\r\n    // listNPoint: CPoint[] = []\r\n\r\n    constructor(optimizer: ClusteringCollisionBasedGraph) {\r\n        this.optimizer = optimizer;\r\n    }\r\n\r\n    public update(): void {\r\n        this.updatePoints();\r\n\r\n        // 1: build connectivity based on collision\r\n        // this.listNPoint = this.BuildConnectivity(this.listNPoint);\r\n        this.pointList = this.BuildConnectivity(this.pointList);\r\n        this.initGeometry();\r\n        // 2: construct clusters graph based on the connectivity\r\n        const geoList = this.buildGraph(this.pointList);\r\n\r\n        if (geoList !== undefined){\r\n            this.addClusterByGeometries(geoList);\r\n            // // 3: recursive checking for the collision while repositioning clusters\r\n            this.PostUpdateCollisionBasedonGraph();\r\n\r\n            const graphs = this.NeedDecompose();\r\n            if (graphs.length > 0) {\r\n                // 4: tessellate big clusters based on a resolution\r\n                this.SplitClusters(graphs);\r\n                // 5: post-process for merging based on a tolerance\r\n                this.PostMergeCluster();\r\n            }\r\n        }\r\n        // console.log('update done', this.pointList)\r\n    }\r\n    public initGeometry(){\r\n        this.optimizer.renderer.InitGeometry();\r\n    }\r\n    public addClusterByGeometries(outGraphList: CPoint[][] ){\r\n        this.optimizer.renderer.addClusterByGeometries(outGraphList);\r\n    }\r\n    private updatePoints() {\r\n        this.pointList = [];\r\n\r\n        for(let i = 0; i < this.optimizer.points.length; ++i) {\r\n            if(this.optimizer.points[i].isHidden ||\r\n                !this.optimizer.points[i].isRenderable ){\r\n                continue\r\n            } else {\r\n                const pt = this.optimizer.points[i];\r\n                pt.collision.Reset();\r\n                this.pointList.push(pt)\r\n            }\r\n        }\r\n\r\n    }\r\n    private BuildConnectivity(listPoints: CPoint[]) {\r\n        for(let i = 0; i < listPoints.length; ++i) {\r\n            const pt = listPoints[i];\r\n            for(let j = i + 1 ; j < listPoints.length; ++j) {\r\n                const other = listPoints[j];\r\n                if (!other.isCollapse && other !== pt && AABBintersect2D([pt.collision.minVec, pt.collision.maxVec], [other.collision.minVec, other.collision.maxVec])) {\r\n                    pt.collision.isCollided = true;\r\n                    pt.isCollapse = true;\r\n                    pt.numVisit = 0;\r\n                    pt.collision.neighborShapes.push(other);\r\n                    other.collision.isCollided = true;\r\n                    other.isCollapse = true;\r\n                    other.numVisit = 0;\r\n                    other.collision.neighborShapes.push(pt);\r\n                    // other.collision.neighborShapes.push(pt);\r\n                    // pt.collision.numOrder = numOrder++;\r\n                    // break;\r\n                }\r\n            }\r\n        }\r\n        // console.log(listPoints)\r\n        return listPoints;\r\n    }\r\n    private buildGraph(listPoints: CPoint[]) {\r\n        let outList: CPoint[][] = [];\r\n        for(let i = 0; i < listPoints.length; ++i) {\r\n            let ptList: CPoint[] = [];\r\n            let queue = [listPoints[i]];\r\n            queue[0].collision.isVisited = true;\r\n            ptList.push(queue[0]);\r\n            let safeguard = 0;\r\n            let current = undefined;\r\n            while( (current = queue.shift()) !== undefined ) {\r\n                for(let i = 0; i < current.collision.neighborShapes.length; ++i) {\r\n                    if(!current.collision.neighborShapes[i].collision.isVisited) {\r\n                        current.collision.neighborShapes[i].collision.isVisited = true;\r\n                        queue.push(current.collision.neighborShapes[i] as CPoint);\r\n                        ptList.push(current.collision.neighborShapes[i] as CPoint);\r\n                    }\r\n                }\r\n                if(safeguard++ > 1000) { console.debug('fail to optimize'); return; }\r\n            }\r\n            if (ptList.length > 1) {\r\n                outList.push(ptList);\r\n            }\r\n        }\r\n        return outList;\r\n    }\r\n    public PostUpdateCollisionBasedonGraph() {\r\n        // for(let i = 0; i < this.optimizer.renderer.clustersNPoint.length; ++i) {\r\n        //     this.UpdateByQueue(this.optimizer.renderer.clustersNPoint[i], this.listNPoint);\r\n        // }\r\n        for(let i = 0; i < this.optimizer.renderer.clustersRPoint.length; ++i) {\r\n            this.UpdateByQueue(this.optimizer.renderer.clustersRPoint[i], this.pointList);\r\n        }\r\n    }\r\n    private UpdateByQueue(cluster: PointCluster, geometries: CPoint[]) {\r\n        let remain = 0;\r\n        const queue = [...geometries]\r\n        while(queue.length) {\r\n            const geo = queue.shift();\r\n\r\n            if (geo) {\r\n                // console.log(queue.length);\r\n                // safeguard and performance optimization\r\n                if (geo.numVisit > 100) { geo.numVisit = 0; break; }\r\n                if (queue.length === 0) {\r\n                    if(geometries.length < remain++ ) { break; }\r\n                }\r\n                // end safeguard and performance optimization\r\n                if (!geo.collision.isCollided) {\r\n                    if(AABBintersect2D([geo.collision.minVec, geo.collision.maxVec], [cluster.minVec, cluster.maxVec]) ) {\r\n                        geo.collision.isCollided = true;\r\n                        geo.isCollapse = true;\r\n                        geo.numVisit = 0;\r\n                        cluster.AddPost(geo);\r\n                    } else {\r\n                        geo.numVisit++;\r\n                        queue.push(geo);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private NeedDecompose(){\r\n        const clusterGraph = [];\r\n\r\n        for(let i = 0; i < this.optimizer.renderer.clustersRPoint.length; ++i) {\r\n            if(this.optimizer.renderer.clustersRPoint[i].NeedDecompose()) {\r\n                clusterGraph.push(this.optimizer.renderer.clustersRPoint[i]);\r\n            }\r\n        }\r\n        return clusterGraph;\r\n    }\r\n    private SplitClusters(clusters: PointCluster[]) {\r\n        for(let i = 0; i < clusters.length; ++i) {\r\n            clusters[i].Split();\r\n        }\r\n    }\r\n    private PostMergeCluster(){\r\n        this.PostMergeClusterCompute(this.optimizer.renderer.clustersRPoint);\r\n    }\r\n    private PostMergeClusterCompute(clusters: PointCluster[]){\r\n        for(let i = 0; i < clusters.length - 1; ++i) {\r\n            const cluster = clusters[i];\r\n            for(let j = i + 1; j < clusters.length; ++j) {\r\n                const other = clusters[j]\r\n                if(!other.isVisited) {\r\n                    if(distance(cluster.vec, other.vec ) < cluster.r1 + 20) {\r\n                        other.isVisited = true;\r\n                        cluster.Merge(other);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","import { NVector3, CPoint } from './lib';\r\n\r\nimport { Renderer } from './Core/Renderer';\r\nimport { GraphClustering } from './Core/GraphClustering';\r\n\r\nexport class ClusteringCollisionBasedGraph {\r\n\r\n    graphClustering: GraphClustering;\r\n    renderer: Renderer;\r\n\r\n    mv: NVector3 = new NVector3(0, 0);\r\n\r\n    inspection: boolean = true;\r\n\r\n    points: CPoint[] = [];\r\n\r\n    constructor() {\r\n        this.graphClustering = new GraphClustering(this);\r\n        this.renderer = new Renderer(this);\r\n    }\r\n    public push(x: number, y: number, lon: number, lat: number) {\r\n        const p = new CPoint(x, y);\r\n        p.vec.lon = lon;\r\n        p.vec.lat = lat;\r\n        this.points.push(p);\r\n        this.update();\r\n    }\r\n    public mouseInteraction(x: number, y: number){\r\n        // this.mv = this.optimizer.getCellAtPoint(new NVector3(x, y)).vec;\r\n    }\r\n    public extentChanging(e, toScreen: (x: number, y: number) => number[]) {\r\n        // console.log(e)\r\n\r\n        this.points.forEach((p) => {\r\n            const sp = toScreen(p.vec.lon, p.vec.lat)\r\n            p.vec.x = sp[0]\r\n            p.vec.y = sp[1]\r\n            p.updateBounding();\r\n        })\r\n\r\n        this.update();\r\n    }\r\n    public update(): void {\r\n        this.graphClustering.update();\r\n        // console.log(this.optimizer.optimizer.optimizer.renderer.annotationInstance.activeCommandController.acProperties.isZooming);\r\n        // if (this.optimizer.optimizer.optimizer.renderer.annotationInstance.activeCommandController.acProperties.isZooming) {\r\n        // this.initGrid(width, height);\r\n        // }\r\n        // console.log(this.points);\r\n    }\r\n    public getCellAtPoint(dp: NVector3) {\r\n\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D, isExtentChanging: boolean, toScreen: (x: number, y: number) => number[], toMap: (x: number, y: number) => number[] ) {\r\n        // console.log(isExtentChanging)\r\n        this.points.forEach((p) => {\r\n\r\n            if (isExtentChanging) {\r\n                const sp = toScreen(p.vec.lon, p.vec.lat);\r\n                p.vec.x = sp[0];\r\n                p.vec.y = sp[1];\r\n                p.updateBounding();\r\n            } \r\n            p.render(ctx);\r\n\r\n        })\r\n\r\n        if (isExtentChanging) {\r\n            this.update();\r\n        }\r\n\r\n\r\n        this.renderer.Render(ctx, isExtentChanging, toScreen)\r\n    }\r\n}","import mapboxgl from \"mapbox-gl\";\r\n\r\nexport class MapboxGLWrapper {\r\n    public map: mapboxgl.Map\r\n    public div: HTMLElement\r\n    constructor(id: string) {\r\n\r\n        this.initMap(id);\r\n    }\r\n    private initMap(id: string) {\r\n        // https://account.mapbox.com\r\n        // mapboxgl.accessToken = process.env.REACT_APP_MAPBOX;\r\n        mapboxgl.accessToken = process.env.REACT_APP_MAPBOX;\r\n        this.map = new mapboxgl.Map({\r\n            container: id,\r\n            zoom: 15,\r\n            // minZoom: 10,\r\n            center: [-71.093161, 42.358871],\r\n            style: 'mapbox://styles/mapbox/dark-v10' // 'mapbox://styles/mapbox/streets-v11'\r\n        });\r\n        this.map.dragRotate.disable();\r\n\r\n        // https://docs.mapbox.com/mapbox-gl-js/api/events/#mapmouseevent#type\r\n        this.map.on('mousemove', (e) => { this.mouseMove(e); });\r\n        this.map.on('click', (e) => { this.mouseClick(e); });\r\n        this.map.on('mousedown', (e) => { this.mouseDown(e); });\r\n        this.map.on('dblclick', (e) => { this.mouseDClick(e); });\r\n        this.map.on('mouseup', (e) => { this.mouseUp(e); });\r\n        this.map.on('zoom' , (e) => { this.extentChanging(e); });\r\n        this.map.on('drag' , (e) => { this.extentChanging(e); });\r\n\r\n        let div = document.getElementsByClassName('mapboxgl-canvas')[0] as HTMLDivElement;\r\n        div.style.position = 'absolute';\r\n        \r\n        div = document.getElementsByClassName('mapboxgl-control-container')[0] as HTMLDivElement;\r\n        div.style.display = 'none';\r\n        this.div = div;\r\n\r\n    }\r\n    public center = (lng: number = -99.292649, lat: number = 39.043903) => {\r\n        // const v = new mapboxgl.LngLat(lon, lat);\r\n        // console.log(v);\r\n        this.map.setCenter({ lat, lng })\r\n    }\r\n    public toMap = (x: number, y: number) => {\r\n        const p = this.map.unproject({x, y} as any)\r\n        return [p.lng, p.lat];\r\n    }\r\n    public toScreen = (lon: number, lat: number) => {\r\n        const p = this.map.project([lon, lat])\r\n        return [p.x, p.y];\r\n    }\r\n    public extentChanging = (e) => {\r\n        \r\n    }\r\n    public mouseDown = (e) => {\r\n        // console.log(this.toScreen(-71.093161, 42.358871))\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseUp = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseMove = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseClick = (e) => {\r\n        // console.log(e)\r\n        \r\n        // console.log(this.toMap(100, 100));\r\n        // console.log(e.point)\r\n        // this.center()\r\n        // this.map.zoomTo(0)\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseDClick = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public destroy() {\r\n        this.div.parentElement.removeChild(this.div);\r\n        // while (this.map. .lastElementChild) {\r\n        //     this.divHost.removeChild(this.divHost.lastElementChild);\r\n        // }\r\n    }\r\n}\r\n\r\n\r\n","// import { RendererCanvas } from '../../../lib'\r\nimport { ClusteringCollisionBasedGraph } from './ClusteringCollisionBasedGraph';\r\n\r\nimport { MapboxGLWrapper } from './MapboxGLWrapper';\r\nimport { RendererCanvas } from '../../../lib'\r\n\r\nexport class Solution {\r\n    public divHost: HTMLDivElement;\r\n    public mapboxWrapper: MapboxGLWrapper;\r\n    public renderer: Renderer;\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id) as HTMLDivElement;\r\n        this.divHost.style.position = 'relative';\r\n\r\n        this.mapboxWrapper = new MapboxGLWrapper(this.divHost.id);\r\n        this.mapboxWrapper.mouseDown = this.mouseDown\r\n        this.mapboxWrapper.mouseUp = this.mouseUp\r\n        this.mapboxWrapper.mouseClick = this.mouseClick\r\n        this.mapboxWrapper.mouseMove = this.mouseMove\r\n        this.mapboxWrapper.extentChanging = this.extentChanging\r\n\r\n        setTimeout(() => {\r\n            this.renderer = new Renderer(this.divHost, this);\r\n        }, 100);\r\n\r\n    }\r\n    public mouseDown = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseUp = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseDrag = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseClick = (e) => {\r\n        // TODO\r\n        // console.log(e);\r\n        // console.log(e['lngLat']);\r\n        this.renderer.pts.push([e['lngLat']['lng'], e['lngLat']['lat']])\r\n        \r\n        const p = this.mapboxWrapper.toScreen(e['lngLat']['lng'], e['lngLat']['lat']);\r\n        this.renderer.mouseClick(p[0], p[1]);\r\n        // console.log(p)\r\n        // this.renderer.clustering.push(p)\r\n\r\n    }\r\n    public mouseMove = (e)  =>{\r\n        // TODO\r\n    }\r\n    public keyDown(k: KeyboardEvent) {\r\n        // TODO\r\n    }\r\n    public extentChanging = (e) => {\r\n        this.renderer.extentChanging(e)\r\n    }\r\n    public destroy() {\r\n        this.mapboxWrapper.destroy()\r\n        this.renderer.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\nexport class Renderer extends RendererCanvas {\r\n    public app: Solution\r\n    public time: number = 0.0;\r\n    public pts: number[][] = [];\r\n\r\n    clustering: ClusteringCollisionBasedGraph;\r\n\r\n    constructor(div: any, app: Solution) {\r\n        super(div);\r\n        this.app = app;\r\n        this.canvas.id = 'mapboxCustom'\r\n        this.canvas.style.position = 'absolute';\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n        this.canvas.style.pointerEvents = 'none';\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n        this.pts.push([-71.093161, 42.358871]);\r\n\r\n        this.clustering = new ClusteringCollisionBasedGraph()\r\n        // const p = this.app.mapboxWrapper.toScreen(-71.093161, 42.358871);\r\n        // this.clustering.push(p)\r\n        this.start();\r\n    }\r\n    public mouseClick = (x: number, y: number): void => {\r\n        // console.log(x, y);\r\n\r\n        const mp = this.app.mapboxWrapper.toMap(x, y)\r\n        this.clustering.push(x, y, mp[0], mp[1]);\r\n    }\r\n    public extentChanging = (e) => {\r\n        // this.clustering.extentChanging(e, this.app.mapboxWrapper.toScreen);\r\n    }\r\n    public mouseUp = (x: number, y: number): void => {\r\n\r\n    }\r\n    public mouseDrag = (x: number, y: number): void => {\r\n\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D): void {\r\n        this.time += 0.1;\r\n\r\n      \r\n\r\n        // for(let i = 0 ; i < this.pts.length; ++i) {\r\n        //     const pt = this.pts[i];\r\n        //     const p = this.app.mapboxWrapper.toScreen(pt[0], pt[1]);\r\n        //     // const p = this.app.mapboxWrapper.map.unproject({x: 10, y: 10})\r\n    \r\n        //     ctx.beginPath();\r\n        //     ctx.arc(p[0], p[1], 10, 0, Math.PI * 2);\r\n        //     ctx.closePath();\r\n        //     ctx.fillStyle = '#0f0';\r\n        //     ctx.fill();\r\n        // }\r\n\r\n        this.clustering.render(ctx, this.app.mapboxWrapper.map.isMoving() || this.app.mapboxWrapper.map.isZooming(), this.app.mapboxWrapper.toScreen, this.app.mapboxWrapper.toMap);\r\n\r\n    }\r\n}"],"names":["AABBintersect2D","v0","v1","v0minX","x","v0maxX","v1minX","v1maxX","v0minY","y","v0maxY","v1minY","v1maxY","distance","Math","sqrt","z","NVector3","constructor","lon","lat","elevation","d","isRenderable","this","CPoint","vec","id","numVisit","radius","isCollapse","isHidden","isSelected","isHover","collision","updateBounding","Collision","render","ctx","beginPath","arc","PI","closePath","fillStyle","fill","renderBoundingBox","rect","minVec","maxVec","stroke","base","isCollided","neighborShapes","isVisited","numOrder","r","Reset","PointCluster","renderer","geometries","points","r0","r1","boundingBoxMin","Number","MAX_SAFE_INTEGER","boundingBoxMax","MIN_SAFE_INTEGER","t","GridResolution","tempVecGridList","tempGeoGridList","i","length","UpdateBoundingBox","IsInside","m","AddPost","geo","includes","push","NeedDecompose","Split","DeepRemove","xNum","yNum","grid","buildGrid","BuildSubCluster","Merge","other","concat","RemoveCluster","gridList","theY","geoMat","theX","geoList","vs","GetCellAtPoint","clustersRPoint","tv","dp","round","j","Draw","isPanning","toScreen","UpdateTimeer","drawingPresetClustering","optimizer","inspection","lineWidth","strokeStyle","moveTo","lineTo","font","textAlign","fillText","Renderer","InitGeometry","addClusterByGeometries","cluster","splice","indexOf","Render","isStationary","GraphClustering","pointList","update","updatePoints","BuildConnectivity","initGeometry","buildGraph","undefined","PostUpdateCollisionBasedonGraph","graphs","SplitClusters","PostMergeCluster","outGraphList","pt","listPoints","outList","ptList","queue","current","safeguard","shift","console","debug","UpdateByQueue","remain","clusterGraph","clusters","PostMergeClusterCompute","ClusteringCollisionBasedGraph","graphClustering","mv","p","mouseInteraction","extentChanging","e","forEach","sp","getCellAtPoint","isExtentChanging","toMap","MapboxGLWrapper","map","div","center","lng","setCenter","unproject","project","mouseDown","mouseUp","mouseMove","mouseClick","mouseDClick","initMap","mapboxgl","process","container","zoom","style","dragRotate","disable","on","document","getElementsByClassName","position","display","destroy","parentElement","removeChild","Solution","divHost","mapboxWrapper","mouseDrag","pts","getElementById","setTimeout","keyDown","k","lastElementChild","RendererCanvas","app","super","time","clustering","mp","canvas","width","height","pointerEvents","start","isMoving","isZooming"],"sourceRoot":""}
{"version":3,"file":"static/js/55296.ffdf8742.chunk.js","mappings":"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","sources":["njslab/LabStarter/Starter-Mapbox-Three-second/MapboxGLWrapper/index.ts","njslab/LabStarter/Starter-Mapbox-Three-second/index.ts"],"sourcesContent":["import mapboxgl from \"mapbox-gl\";\r\n\r\nexport class MapboxGLWrapper {\r\n    public map: mapboxgl.Map\r\n    constructor(id: string) {\r\n\r\n        this.initMap(id);\r\n    }\r\n    private initMap(id: string) {\r\n\r\n        // https://account.mapbox.com\r\n        // mapboxgl.accessToken = process.env.NEXT_PUBLIC_API_KEY_MAPBOX;\r\n        mapboxgl.accessToken = process.env.REACT_APP_MAPBOX;\r\n        this.map = new mapboxgl.Map({\r\n            container: id,\r\n            style: 'mapbox://styles/mapbox/dark-v10', // 'mapbox://styles/mapbox/streets-v11'\r\n            // center: [-71.093161, 42.358871],\r\n            // zoom: 15,\r\n            // zoom: 16,\r\n            pitch: 60,\r\n            bearing: -17.6,\r\n            // minZoom: 10,\r\n            antialias: true,\r\n\r\n            zoom: 18,\r\n            center: [148.9819, -35.3981],\r\n            // pitch: 60,\r\n        });\r\n        // this.map.dragRotate.disable();\r\n\r\n        // https://docs.mapbox.com/mapbox-gl-js/api/events/#mapmouseevent#type\r\n        this.map.on('mousemove', (e) => { this.mouseMove(e); });\r\n        this.map.on('click', (e) => { this.mouseClick(e); });\r\n        this.map.on('mousedown', (e) => { this.mouseDown(e); });\r\n        this.map.on('dblclick', (e) => { this.mouseDClick(e); });\r\n        this.map.on('mouseup', (e) => { this.mouseUp(e); });\r\n\r\n        let div = document.getElementsByClassName('mapboxgl-canvas')[0] as HTMLDivElement;\r\n        div.style.position = 'absolute';\r\n        \r\n        div = document.getElementsByClassName('mapboxgl-control-container')[0] as HTMLDivElement;\r\n        div.style.display = 'none';\r\n\r\n    }\r\n    public center = (lng: number = -99.292649, lat: number = 39.043903) => {\r\n        // const v = new mapboxgl.LngLat(lon, lat);\r\n        // console.log(v);\r\n        this.map.setCenter({ lat, lng })\r\n    }\r\n    public toMap = (x: number, y: number) => {\r\n        const p = this.map.unproject({x, y} as any)\r\n        return [p.lng, p.lat];\r\n    }\r\n    public toScreen = (lon: number, lat: number) => {\r\n        const p = this.map.project([lon, lat])\r\n        return [p.x, p.y];\r\n    }\r\n    public mouseDown = (e) => {\r\n        // console.log(this.toScreen(-71.093161, 42.358871))\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseUp = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseMove = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseClick = (e) => {\r\n        // console.log(e)\r\n        // console.log(this.toMap(100, 100));\r\n        // console.log(e.point)\r\n        // this.center()\r\n        // this.map.zoomTo(0)\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseDClick = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n}\r\n","import mapboxgl from \"mapbox-gl\";\r\nimport * as THREE from \"three\";\r\n\r\nimport { MapboxGLWrapper } from \"./MapboxGLWrapper\";\r\nimport { RendererCanvas } from \"../../../lib\";\r\n\r\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\r\nimport { TransformControls } from \"threejs-transformcontrols\";\r\n\r\nimport { OrbitControls } from \"three-orbitcontrols-ts\";\r\n// import {TransformControls} from 'three-addons'\r\n// import { TransformControls } from 'threejs_transformcontrols';\r\n// 'addons/controls/TransformControls.js';\r\n\r\nexport class Solution {\r\n  public divHost: HTMLDivElement;\r\n  public mapboxWrapper: MapboxGLWrapper;\r\n  scene;\r\n  // public renderer: Renderer;\r\n  constructor(id: string) {\r\n    this.divHost = document.getElementById(id) as HTMLDivElement;\r\n    this.divHost.style.position = \"relative\";\r\n\r\n    this.mapboxWrapper = new MapboxGLWrapper(this.divHost.id);\r\n    this.mapboxWrapper.mouseDown = this.mouseDown;\r\n    this.mapboxWrapper.mouseUp = this.mouseUp;\r\n    this.mapboxWrapper.mouseClick = this.mouseClick;\r\n    this.mapboxWrapper.mouseMove = this.mouseMove;\r\n\r\n    var map = this.mapboxWrapper.map;\r\n\r\n    //   // parameters to ensure the model is georeferenced correctly on the map\r\n    //   var modelOrigin = [126.735901, 37.348980];\r\n    //   var modelAltitude = 0;\r\n    //   var modelRotate = [Math.PI / 2, 0, 0];\r\n\r\n    //   var modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(modelOrigin, modelAltitude);\r\n    //   // transformation parameters to position, rotate and scale the 3D model onto the map\r\n    //   var modelTransform = {\r\n    //     translateX: modelAsMercatorCoordinate.x,\r\n    //     translateY: modelAsMercatorCoordinate.y,\r\n    //     translateZ: modelAsMercatorCoordinate.z,\r\n    //     rotateX: modelRotate[0],\r\n    //     rotateY: modelRotate[1],\r\n    //     rotateZ: modelRotate[2],\r\n    //     /* Since our 3D model is in real world meters, a scale transform needs to be\r\n    //      * applied since the CustomLayerInterface expects units in MercatorCoordinates.\r\n    //      */\r\n    //     scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()\r\n    //   };\r\n    //   var THREE = window.THREE;\r\n    //   // configuration of the custom layer for a 3D model per the CustomLayerInterface\r\n    //   const customLayer = {\r\n    //     id: '3d-model',\r\n    //     type: 'custom',\r\n    //     renderingMode: '3d',\r\n    //     onAdd: function(map, gl) {\r\n    //       this.camera = new THREE.Camera();\r\n    //       this.scene = new THREE.Scene();\r\n\r\n    //       // create two three.js lights to illuminate the model\r\n    //       var directionalLight = new THREE.DirectionalLight(0xffffff);\r\n    //       directionalLight.position.set(0, -70, 100).normalize();\r\n    //       this.scene.add(directionalLight);\r\n\r\n    //       var directionalLight2 = new THREE.DirectionalLight(0xffffff);\r\n    //       directionalLight2.position.set(0, 70, 100).normalize();\r\n    //       this.scene.add(directionalLight2);\r\n\r\n    //       var loader = new THREE.OBJLoader();\r\n    //       loader.load('maps.obj', (function(object) {\r\n    //         object.scale.set(1000, 1000, 1000);\r\n    //         object.position.set(-5420, 0, 5420);\r\n    //         //  object.position(0,0,0);\r\n    //         this.scene.add(object);\r\n    //       }).bind(this));\r\n    //       this.map = map;\r\n    //       // use the Mapbox GL JS map canvas for three.js\r\n    //       this.renderer = new THREE.WebGLRenderer({\r\n    //         canvas: map.getCanvas(),\r\n    //         context: gl,\r\n    //         antialias: true\r\n    //       });\r\n\r\n    //       this.renderer.autoClear = false;\r\n    //     },\r\n    //     render: function(gl, matrix) {\r\n    //       var rotationX = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), modelTransform.rotateX);\r\n    //       var rotationY = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), modelTransform.rotateY);\r\n    //       var rotationZ = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), modelTransform.rotateZ);\r\n\r\n    //       var m = new THREE.Matrix4().fromArray(matrix);\r\n    //       var l = new THREE.Matrix4().makeTranslation(modelTransform.translateX, modelTransform.translateY, modelTransform.translateZ)\r\n    //         .scale(new THREE.Vector3(modelTransform.scale, -modelTransform.scale, modelTransform.scale))\r\n    //         .multiply(rotationX)\r\n    //         .multiply(rotationY)\r\n    //         .multiply(rotationZ);\r\n\r\n    //       this.camera.projectionMatrix = m.multiply(l);\r\n    //       this.renderer.state.reset();\r\n    //       this.renderer.render(this.scene, this.camera);\r\n    //       this.map.triggerRepaint();\r\n    //     }\r\n    //   };\r\n\r\n    // //   const thre;\r\n\r\n    //   // 3D 씬 설정\r\n    //   const scene = new THREE.Scene();\r\n    //   const camera = new THREE.Camera();\r\n    //   const renderer = new THREE.WebGLRenderer({\r\n    //       canvas: map.getCanvas(),\r\n    //       antialias: true,\r\n    //       alpha: true\r\n    //   });\r\n\r\n    //   // 포인트 생성\r\n    //   const pointGeometry = new THREE.BufferGeometry();\r\n    //   const pointsMaterial = new THREE.PointsMaterial({\r\n    //       color: 0xff0000,\r\n    //       size: 5,\r\n    //       sizeAttenuation: false\r\n    //   });\r\n\r\n    //   console.log(mapboxgl)\r\n\r\n    //   // 랜덤 포인트 생성\r\n    //   const pointsCount = 1000;\r\n    //   const positions = new Float32Array(pointsCount * 3);\r\n\r\n    //   for (let i = 0; i < pointsCount; i++) {\r\n    //       const lon = Math.random() * 360 - 180;\r\n    //       const lat = Math.random() * 180 - 90;\r\n    //       const pos = mapboxgl.MercatorCoordinate.fromLngLat([lon, lat]);\r\n    //       console.log(pos)\r\n    //       positions[i * 3] = pos.x;\r\n    //       positions[i * 3 + 1] = pos.y;\r\n    //       positions[i * 3 + 2] = 0;\r\n    //   }\r\n\r\n    //   pointGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n    //   const points = new THREE.Points(pointGeometry, pointsMaterial);\r\n    //   scene.add(points);\r\n\r\n    //   function render() {\r\n    //     const { lng, lat } = map.getCenter();\r\n    //     const zoom = map.getZoom();\r\n    //     const scale = Math.pow(2, zoom);\r\n\r\n    //     const aspect = window.innerWidth / window.innerHeight;\r\n    //     camera.projectionMatrix = new THREE.Matrix4().makeOrthographic(\r\n    //         -scale * aspect, scale * aspect, scale, -scale, -1000, 1000\r\n    //     );\r\n\r\n    //     const mercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat([lng, lat], 0);\r\n    //     const matrixWorldInverse = new THREE.Matrix4().makeTranslation(\r\n    //         mercatorCoordinate.x, mercatorCoordinate.y, 0\r\n    //     ).scale(new THREE.Vector3(1, -1, 1));\r\n\r\n    //     camera.matrixWorldInverse.copy(matrixWorldInverse);\r\n    //     camera.matrixWorld.copy(camera.matrixWorldInverse).invert();\r\n\r\n    //     // Remove or test with and without this line\r\n    //     // renderer.state.reset();\r\n\r\n    //     // Debug camera position\r\n    //     console.log(camera.position, camera.matrixWorld);\r\n\r\n    //     renderer.render(scene, camera);\r\n    //     // map.triggerRepaint();\r\n\r\n    //     // Request next frame\r\n    //     requestAnimationFrame(render);\r\n    //      }\r\n\r\n    //          const geometry = new THREE.BoxGeometry(1, 1, 1);\r\n    // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\r\n    // const cube = new THREE.Mesh(geometry, material);\r\n    // scene.add(cube);\r\n\r\n    // parameters to ensure the model is georeferenced correctly on the map\r\n    var start = [148.9819, 38];\r\n    var startAltitude = 1000;\r\n    var startCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(\r\n      start,\r\n      startAltitude\r\n    );\r\n    // console.log(startCoordinate);\r\n    var end = [148.9819, -35.39847];\r\n    var endAltitude = 0;\r\n    var endCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(\r\n      end,\r\n      endAltitude\r\n    );\r\n    // console.log(\"end is \");\r\n    // console.log(endCoordinate);\r\n    /* Since our 3D model is in real world meters, a scale transform needs to be\r\n     * applied since the CustomLayerInterface expects units in MercatorCoordinates.\r\n     */\r\n    //var scale = modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()\r\n\r\n    const material = new THREE.LineBasicMaterial({ color: 0x0000ff });\r\n\r\n    // Create a BufferGeometry instead of Geometry\r\n    const geometry = new THREE.BufferGeometry();\r\n\r\n    // Define the start and end points as Float32Array\r\n    const positions = new Float32Array([\r\n      startCoordinate.x,\r\n      startCoordinate.y,\r\n      startCoordinate.z, // Start point\r\n      endCoordinate.x,\r\n      endCoordinate.y,\r\n      endCoordinate.z, // End point\r\n    ]);\r\n\r\n    // Set the positions attribute for the geometry\r\n    geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\r\n\r\n    // Create the line using BufferGeometry and LineBasicMaterial\r\n    const line = new THREE.Line(geometry, material);\r\n\r\n    // var customLayer = {\r\n    //     id: \"3d-model\",\r\n    //     type: \"custom\",\r\n    //     renderingMode: \"3d\",\r\n    //     onAdd: function(map, gl) {\r\n    //       this.camera = new THREE.Camera();\r\n    //       this.scene = new THREE.Scene();\r\n\r\n    //       // create two three.js lights to illuminate the model\r\n    //       var directionalLight = new THREE.DirectionalLight(0xffffff);\r\n    //       directionalLight.position.set(0, -70, 100).normalize();\r\n    //       this.scene.add(directionalLight);\r\n\r\n    //       var directionalLight2 = new THREE.DirectionalLight(0xffffff);\r\n    //       directionalLight2.position.set(0, 70, 100).normalize();\r\n    //       this.scene.add(directionalLight2);\r\n\r\n    //       this.scene.add(line);\r\n\r\n    //       this.map = map;\r\n\r\n    //       // use the Mapbox GL JS map canvas for three.js\r\n    //       this.renderer = new THREE.WebGLRenderer({\r\n    //         canvas: map.getCanvas(),\r\n    //         context: gl,\r\n    //         antialias: true\r\n    //       });\r\n\r\n    //       this.renderer.autoClear = false;\r\n\r\n    //     },\r\n    //     render: function(gl, matrix) {\r\n    //       var m = new THREE.Matrix4().fromArray(matrix);\r\n    //       this.camera.projectionMatrix = m;\r\n    //       this.renderer.state.reset();\r\n    //       this.renderer.render(this.scene, this.camera);\r\n    //       this.map.triggerRepaint();\r\n\r\n    //       console.log('re')\r\n    //     }\r\n    //   };\r\n\r\n    //       map.on('style.load', () => {\r\n    //         map.addLayer(customLayer, 'waterway-label');\r\n\r\n    //         // render();\r\n    //       });\r\n\r\n    // parameters to ensure the model is georeferenced correctly on the map\r\n    const modelOrigin = [148.9819, -35.39847];\r\n    const modelAltitude = 0;\r\n    const modelRotate = [Math.PI / 2, 0, 0];\r\n\r\n    const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(\r\n      modelOrigin,\r\n      modelAltitude\r\n    );\r\n\r\n    // transformation parameters to position, rotate and scale the 3D model onto the map\r\n    const modelTransform = {\r\n      translateX: modelAsMercatorCoordinate.x,\r\n      translateY: modelAsMercatorCoordinate.y,\r\n      translateZ: modelAsMercatorCoordinate.z,\r\n      rotateX: modelRotate[0],\r\n      rotateY: modelRotate[1],\r\n      rotateZ: modelRotate[2],\r\n      /* Since the 3D model is in real world meters, a scale transform needs to be\r\n       * applied since the CustomLayerInterface expects units in MercatorCoordinates.\r\n       */\r\n      scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits(),\r\n    };\r\n\r\n    // const THREE = window.THREE;\r\n\r\n    // configuration of the custom layer for a 3D model per the CustomLayerInterface\r\n    const customLayer = {\r\n      id: \"3d-model\",\r\n      type: \"custom\",\r\n      renderingMode: \"3d\",\r\n      onAdd: function (map, gl) {\r\n        this.camera = new THREE.Camera();\r\n        this.scene = new THREE.Scene();\r\n\r\n        // create two three.js lights to illuminate the model\r\n        const directionalLight = new THREE.DirectionalLight(0xffffff);\r\n        directionalLight.position.set(0, -70, 100).normalize();\r\n        this.scene.add(directionalLight);\r\n\r\n        const directionalLight2 = new THREE.DirectionalLight(0xffffff);\r\n        directionalLight2.position.set(0, 70, 100).normalize();\r\n        this.scene.add(directionalLight2);\r\n\r\n        // use the three.js GLTF loader to add the 3D model to the three.js scene\r\n        const loader = new GLTFLoader();\r\n        loader.load(\r\n          \"https://docs.mapbox.com/mapbox-gl-js/assets/34M_17/34M_17.gltf\",\r\n          (gltf) => {\r\n            this.scene.add(gltf.scene);\r\n          }\r\n        );\r\n        this.map = map;\r\n\r\n        this.scene.add(line);\r\n\r\n        // use the Mapbox GL JS map canvas for three.js\r\n        this.renderer = new THREE.WebGLRenderer({\r\n          canvas: map.getCanvas(),\r\n          context: gl,\r\n          antialias: true,\r\n        });\r\n\r\n        this.renderer.autoClear = false;\r\n      },\r\n      render: function (gl, matrix) {\r\n        const rotationX = new THREE.Matrix4().makeRotationAxis(\r\n          new THREE.Vector3(1, 0, 0),\r\n          modelTransform.rotateX\r\n        );\r\n        const rotationY = new THREE.Matrix4().makeRotationAxis(\r\n          new THREE.Vector3(0, 1, 0),\r\n          modelTransform.rotateY\r\n        );\r\n        const rotationZ = new THREE.Matrix4().makeRotationAxis(\r\n          new THREE.Vector3(0, 0, 1),\r\n          modelTransform.rotateZ\r\n        );\r\n\r\n        const m = new THREE.Matrix4().fromArray(matrix);\r\n        const l = new THREE.Matrix4()\r\n          .makeTranslation(\r\n            modelTransform.translateX,\r\n            modelTransform.translateY,\r\n            modelTransform.translateZ\r\n          )\r\n          .scale(\r\n            new THREE.Vector3(\r\n              modelTransform.scale,\r\n              -modelTransform.scale,\r\n              modelTransform.scale\r\n            )\r\n          )\r\n          .multiply(rotationX)\r\n          .multiply(rotationY)\r\n          .multiply(rotationZ);\r\n\r\n        this.camera.projectionMatrix = m.multiply(l);\r\n        this.renderer.resetState();\r\n        this.renderer.render(this.scene, this.camera);\r\n        this.map.triggerRepaint();\r\n      },\r\n    };\r\n\r\n    map.on(\"style.load\", () => {\r\n      map.addLayer(customLayer, \"waterway-label\");\r\n    });\r\n\r\n    // setTimeout(() => {\r\n\r\n    //     this.scene = new THREE.Scene();\r\n    //     const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n    //     const renderer = new THREE.WebGLRenderer({ canvas: this.mapboxWrapper.map.getCanvas(), context: this.mapboxWrapper.map.painter.context, alpha: true });\r\n\r\n    //     // const renderer = new THREE.WebGLRenderer({\r\n    //     //     canvas: this.mapboxWrapper.map.getCanvas(),\r\n    //     //     antialias: true,\r\n    //     //     alpha: true\r\n    //     // });\r\n\r\n    //     renderer.setSize(window.innerWidth, window.innerHeight);\r\n    //     renderer.setPixelRatio(window.devicePixelRatio);\r\n\r\n    //     renderer.autoClear = false;\r\n\r\n    //     this.mapboxWrapper.map.on('render', () => {\r\n    //         const rotationX = this.mapboxWrapper.map.getPitch() * Math.PI / 180;\r\n    //         const rotationZ = this.mapboxWrapper.map.getBearing() * Math.PI / 180;\r\n\r\n    //         camera.position.x = 0;\r\n    //         camera.position.y = -Math.sin(rotationX);\r\n    //         camera.position.z = Math.cos(rotationX);\r\n\r\n    //         camera.rotation.x = rotationX;\r\n    //         camera.rotation.z = rotationZ;\r\n\r\n    //         renderer.render(this.scene, camera);\r\n    //     });\r\n\r\n    //      const animate = () => {\r\n    //         requestAnimationFrame(animate);\r\n    //         renderer.state.reset();\r\n    //         renderer.render(this.scene, camera);\r\n    //         console.log('running')\r\n    //     }\r\n    //     animate();\r\n\r\n    // }, 1000);\r\n  }\r\n  public mouseDown = (e) => {\r\n    // this.addPoint(40.7128, -74.0060);  // 뉴욕\r\n    // this.addPoint(37.7749, -122.4194); // 샌프란시스코\r\n    // this.addPoint(51.5074, -0.1278);   // 런던\r\n    // TODO\r\n  };\r\n  public mouseUp = (e) => {\r\n    // TODO\r\n  };\r\n  public mouseDrag = (e) => {\r\n    // TODO\r\n  };\r\n  public mouseClick = (e) => {\r\n    // TODO\r\n    // console.log('dddd');\r\n    // console.log(e);\r\n    // console.log(e['lngLat']);\r\n    // this.renderer.pts.push([e['lngLat']['lng'], e['lngLat']['lat']])\r\n  };\r\n  public mouseMove = (e) => {\r\n    // TODO\r\n  };\r\n  public keyDown(k: KeyboardEvent) {\r\n    // TODO\r\n  }\r\n  public destroy() {\r\n    // this.renderer.destroy();\r\n    while (this.divHost.lastElementChild) {\r\n      this.divHost.removeChild(this.divHost.lastElementChild);\r\n    }\r\n  }\r\n  addPoint(lat, lng) {\r\n    const geometry = new THREE.SphereGeometry(0.02, 32, 32); // 구형 포인트\r\n    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });\r\n    const point = new THREE.Mesh(geometry, material);\r\n\r\n    // 위도/경도를 화면 좌표로 변환\r\n    const coords = this.mapboxWrapper.map.project([lng, lat]);\r\n\r\n    // console.log(coords);\r\n\r\n    // Three.js 포인트를 지도 좌표에 맞게 위치시키기\r\n    point.position.set(\r\n      (coords.x / window.innerWidth) * 2 - 1, // Three.js의 x 좌표\r\n      -(coords.y / window.innerHeight) * 2 + 1, // Three.js의 y 좌표\r\n      0\r\n    );\r\n\r\n    // this.scene.add(point);\r\n  }\r\n}\r\n"],"names":["MapboxGLWrapper","constructor","id","map","center","lng","lat","setCenter","toMap","x","y","p","this","unproject","toScreen","lon","project","mouseDown","e","mouseUp","mouseMove","mouseClick","mouseDClick","initMap","mapboxgl","process","container","style","pitch","bearing","antialias","zoom","on","div","document","getElementsByClassName","position","display","Solution","divHost","mapboxWrapper","scene","mouseDrag","getElementById","startCoordinate","endCoordinate","material","THREE","color","geometry","positions","Float32Array","z","setAttribute","line","modelRotate","Math","PI","modelAsMercatorCoordinate","modelTransform","translateX","translateY","translateZ","rotateX","rotateY","rotateZ","scale","meterInMercatorCoordinateUnits","customLayer","type","renderingMode","onAdd","gl","camera","directionalLight","set","normalize","add","directionalLight2","GLTFLoader","load","gltf","renderer","canvas","getCanvas","context","autoClear","render","matrix","rotationX","makeRotationAxis","rotationY","rotationZ","m","fromArray","l","makeTranslation","multiply","projectionMatrix","resetState","triggerRepaint","addLayer","keyDown","k","destroy","lastElementChild","removeChild","addPoint","point","coords","window","innerWidth","innerHeight"],"sourceRoot":""}
{"version":3,"file":"static/js/59835.10500377.chunk.js","mappings":"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","sources":["njslab/GIS/Concave/MapboxGLWrapper/index.ts","njslab/GIS/Concave/index.ts","lib/NJSCore/GIS/index.ts"],"sourcesContent":["import mapboxgl from 'mapbox-gl';\r\n\r\nexport class MapboxGLWrapper {\r\n    public map: mapboxgl.Map\r\n    constructor(id: string) {\r\n        this.initMap(id);\r\n    }\r\n    private initMap(id: string) {\r\n        // https://account.mapbox.com\r\n        // mapboxgl.accessToken = process.env.NEXT_PUBLIC_API_KEY_MAPBOX;\r\n        mapboxgl.accessToken = process.env.REACT_APP_MAPBOX\r\n        this.map = new mapboxgl.Map({\r\n            container: id,\r\n            zoom: 15,\r\n            // minZoom: 10,\r\n            center: [-71.093161, 42.358871],\r\n            style: 'mapbox://styles/mapbox/dark-v10' // 'mapbox://styles/mapbox/streets-v11'\r\n        });\r\n        this.map.dragRotate.disable();\r\n\r\n        // https://docs.mapbox.com/mapbox-gl-js/api/events/#mapmouseevent#type\r\n        this.map.on('mousemove', (e) => { this.mouseMove(e); });\r\n        this.map.on('click', (e) => { this.mouseClick(e); });\r\n        this.map.on('mousedown', (e) => { this.mouseDown(e); });\r\n        this.map.on('dblclick', (e) => { this.mouseDClick(e); });\r\n        this.map.on('mouseup', (e) => { this.mouseUp(e); });\r\n\r\n        let div = document.getElementsByClassName('mapboxgl-canvas')[0] as HTMLDivElement;\r\n        div.style.position = 'absolute';\r\n        \r\n        div = document.getElementsByClassName('mapboxgl-control-container')[0] as HTMLDivElement;\r\n        div.style.display = 'none';\r\n\r\n    }\r\n    public center = (lng: number = -99.292649, lat: number = 39.043903) => {\r\n        // const v = new mapboxgl.LngLat(lon, lat);\r\n        // console.log(v);\r\n        this.map.setCenter({ lat, lng })\r\n    }\r\n    public toMap = (x: number, y: number) => {\r\n        const p = this.map.unproject({x, y} as any)\r\n        return [p.lng, p.lat];\r\n    }\r\n    public toScreen = (lon: number, lat: number) => {\r\n        const p = this.map.project([lon, lat])\r\n        return [p.x, p.y];\r\n    }\r\n    public mouseDown = (e) => {\r\n        // console.log(this.toScreen(-71.093161, 42.358871))\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseUp = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseMove = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseClick = (e) => {\r\n        // console.log(e)\r\n        \r\n        // console.log(this.toMap(100, 100));\r\n        // console.log(e.point)\r\n        // this.center()\r\n        // this.map.zoomTo(0)\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseDClick = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n}\r\n\r\n\r\n","import * as turf from \"@turf/turf\";\r\n\r\nimport concaveman from 'concaveman';\r\n\r\nimport { MapboxGLWrapper } from './MapboxGLWrapper';\r\nimport { RendererCanvas } from '../../../lib'\r\n\r\nimport {  processZipFile, transformCoordinates, mapBoxVisualizeGeoJSON, appendDropDownFileLoader } from '../gisUtils'\r\n\r\nimport { renderConcave, generateConcavePolygon } from './Concave'\r\n\r\nexport class Solution {\r\n    public divHost: HTMLDivElement;\r\n    public mapboxWrapper: MapboxGLWrapper;\r\n    public renderer: Renderer;\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id) as HTMLDivElement;\r\n        this.divHost.style.position = 'relative';\r\n\r\n        this.mapboxWrapper = new MapboxGLWrapper(this.divHost.id);\r\n        this.mapboxWrapper.mouseDown = this.mouseDown\r\n        this.mapboxWrapper.mouseUp = this.mouseUp\r\n        this.mapboxWrapper.mouseClick = this.mouseClick\r\n        this.mapboxWrapper.mouseMove = this.mouseMove\r\n\r\n        setTimeout(() => {\r\n            this.renderer = new Renderer(this.divHost, this);\r\n        }, 100);\r\n\r\n\r\n        const callBackFn = async (e) => {\r\n            const files = e.dataTransfer.files;\r\n            if (files.length > 0 && files[0].name.endsWith('.zip')) {\r\n                const zipFile = files[0];\r\n                try {\r\n                    const { geojson, projectionString } = await processZipFile(zipFile);\r\n                    console.log('GeoJSON:', geojson);\r\n                    console.log('Projection:', projectionString);\r\n                    const transformedGeoJSON = await transformCoordinates(geojson, projectionString);\r\n\r\n\r\n                    mapBoxVisualizeGeoJSON(this.mapboxWrapper.map, transformedGeoJSON)\r\n       \r\n                } catch (error) {\r\n                    console.error('error:', error);\r\n                }\r\n            } else {\r\n                console.error('Not a valid ZIP file');\r\n            }\r\n        }\r\n\r\n        appendDropDownFileLoader(this.divHost, callBackFn)\r\n\r\n    }\r\n    public mouseDown = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseUp = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseDrag = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseClick = (e) => {\r\n        // TODO\r\n        // console.log(e);\r\n        // console.log(e['lngLat']);\r\n        this.renderer.pts.push([e['lngLat']['lng'], e['lngLat']['lat']])\r\n    }\r\n    public mouseMove = (e)  =>{\r\n        // TODO\r\n    }\r\n    public keyDown(k: KeyboardEvent) {\r\n        // TODO\r\n    }\r\n    public destroy() {\r\n        this.renderer?.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\nexport class Renderer extends RendererCanvas {\r\n    public app: Solution\r\n    public time: number = 0.0;\r\n    public pts: number[][] = [];\r\n    constructor(div: any, app: Solution) {\r\n        super(div);\r\n        this.app = app;\r\n        this.canvas.id = 'mapboxCustom'\r\n        this.canvas.style.position = 'absolute';\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n        this.canvas.style.pointerEvents = 'none';\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n        this.pts.push([-71.093161, 42.358871]);\r\n\r\n        this.start();\r\n    }\r\n    public mouseDown = (x: number, y: number): void => {\r\n\r\n    }\r\n    public mouseUp = (x: number, y: number): void => {\r\n\r\n    }\r\n    public mouseDrag = (x: number, y: number): void => {\r\n\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D): void {\r\n        this.time += 0.1;\r\n\r\n\r\n        exeCaveman(ctx, this.pts, this.app.mapboxWrapper.toScreen)\r\n\r\n        exeTurf(ctx, this.pts, this.app.mapboxWrapper.toScreen)\r\n\r\n        // const resultA  = generateConcavePolygon(this.pts)\r\n        // renderConcave(ctx, resultA.points, resultA.concaveIndices, this.app.mapboxWrapper.toScreen);\r\n\r\n\r\n        for(let i = 0 ; i < this.pts.length; ++i) {\r\n            const pt = this.pts[i];\r\n            const p = this.app.mapboxWrapper.toScreen(pt[0], pt[1]);\r\n            // const p = this.app.mapboxWrapper.map.unproject({x: 10, y: 10})\r\n    \r\n            ctx.beginPath();\r\n            ctx.arc(p[0], p[1], Math.sin(this.time) * 3 + 15, 0, Math.PI * 2);\r\n            ctx.closePath();\r\n            ctx.fillStyle = 'rgba(0, 255, 255, 0.25)';\r\n            ctx.fill();\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\nconst exeTurf = (ctx, pts, toScreen) => {\r\n    const points = turf.featureCollection(\r\n        pts.map((p) => {\r\n           return turf.point([p[0], p[1]])\r\n        })\r\n    );\r\n    \r\n    const options = { units: \"miles\", maxEdge: 1 };  \r\n    const hull = turf.concave(points, options);\r\n    if (hull) {\r\n        // console.log(hull)\r\n\r\n        const vs = hull['geometry']['coordinates'][0]\r\n        ctx.beginPath();\r\n\r\n        let projected = toScreen(vs[0][0], vs[0][1])\r\n        ctx.moveTo(projected[0], projected[1])\r\n\r\n        for(let i = 1 ; i < vs.length; ++i) {\r\n            // console.log(vs[i][0], vs[i][1])\r\n            projected = toScreen(vs[i][0], vs[i][1])\r\n            ctx.lineTo(projected[0], projected[1])\r\n        }\r\n        ctx.strokeStyle = '#00f'\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\n\r\nconst exeCaveman = (ctx, pts, toScreen) => {\r\n    const concaveHull = concaveman(pts);\r\n    // console.log(concaveHull)\r\n    ctx.lineWidth = 4;\r\n    if (concaveHull.length > 3) {\r\n        let projected = toScreen(concaveHull[0][0], concaveHull[0][1])\r\n        ctx.moveTo(projected[0], projected[1])\r\n\r\n        for(let i = 1 ; i < concaveHull.length; ++i) {\r\n            // console.log(concaveHull[i][0], concaveHull[i][1])\r\n            projected = toScreen(concaveHull[i][0], concaveHull[i][1])\r\n            ctx.lineTo(projected[0], projected[1])\r\n        }\r\n        ctx.strokeStyle = '#f00'\r\n        ctx.stroke();\r\n    }\r\n    ctx.lineWidth = 1;\r\n\r\n}","import mapboxgl from 'mapbox-gl';\nimport * as shapefile from 'shapefile'; // https://www.npmjs.com/package/shapefile\nimport JSZip from 'jszip';\nimport proj4 from 'proj4';\n\nexport const transformCoordinates = async (geojson, projectionString) => {\n    if (!projectionString) {\n        console.warn('no projection needed.');\n        return geojson;\n      }\n  \n      try {\n        proj4.defs('SOURCE_CRS', projectionString);\n      } catch (error) {\n        console.error('fail to parse the projection:', error);\n        return geojson;\n      }\n  \n      // const transformedFeatures = geojson.features.map(feature => {\n      //   if (feature.geometry.type === 'Polygon') {\n      //     const transformedCoordinates = feature.geometry.coordinates.map(ring => \n      //       ring.map(coord => {\n      //         const [lon, lat] = proj4('SOURCE_CRS', 'EPSG:4326', coord);\n      //         return [lon, lat];\n      //       })\n      //     );\n      //     return {...feature, geometry: {...feature.geometry, coordinates: transformedCoordinates}};\n      //   }\n      //   return feature;\n      // });\n\n      const transformedFeatures = geojson.features.map(feature => {\n        const transformCoordinates = coords => {\n          return coords.map(coord => {\n            const [lon, lat] = proj4('SOURCE_CRS', 'EPSG:4326', coord);\n            return [lon, lat];\n          });\n        };\n      \n        switch (feature.geometry.type) {\n          case 'Polygon':\n            const transformedPolygonCoordinates = feature.geometry.coordinates.map(ring => transformCoordinates(ring));\n            return {...feature, geometry: {...feature.geometry, coordinates: transformedPolygonCoordinates}};\n          \n          case 'MultiPolygon':\n            const transformedMultiPolygonCoordinates = feature.geometry.coordinates.map(polygon => \n              polygon.map(ring => transformCoordinates(ring))\n            );\n            return {...feature, geometry: {...feature.geometry, coordinates: transformedMultiPolygonCoordinates}};\n          \n          case 'LineString':\n            const transformedLineCoordinates = transformCoordinates(feature.geometry.coordinates);\n            return {...feature, geometry: {...feature.geometry, coordinates: transformedLineCoordinates}};\n          \n          case 'MultiLineString':\n            const transformedMultiLineCoordinates = feature.geometry.coordinates.map(line => transformCoordinates(line));\n            return {...feature, geometry: {...feature.geometry, coordinates: transformedMultiLineCoordinates}};\n          \n          case 'Point':\n            const transformedPoint = transformCoordinates([feature.geometry.coordinates])[0];\n            return {...feature, geometry: {...feature.geometry, coordinates: transformedPoint}};\n          \n          case 'MultiPoint':\n            const transformedMultiPointCoordinates = transformCoordinates(feature.geometry.coordinates);\n            return {...feature, geometry: {...feature.geometry, coordinates: transformedMultiPointCoordinates}};\n          \n          default:\n            return feature; // 기타 피처 타입은 변환하지 않음\n        }\n      });\n      \n  \n      return {...geojson, features: transformedFeatures};\n}\n\n\nexport const processZipFile = async (zipFile) => {\n    const zip = new JSZip();\n    const zipContents = await zip.loadAsync(zipFile);\n\n    let shpFile, dbfFile, prjFile;\n    for (const filename in zipContents.files) {\n      if (filename.endsWith('.shp')) {\n        shpFile = zipContents.files[filename];\n      } else if (filename.endsWith('.dbf')) {\n        dbfFile = zipContents.files[filename];\n      } else if (filename.endsWith('.prj')) {\n        prjFile = zipContents.files[filename];\n      }\n    }\n\n    if (!shpFile || !dbfFile) {\n      throw new Error('no .shp or .dbf in the zip file');\n    }\n\n    const shpBuffer = await shpFile.async('arraybuffer');\n    const dbfBuffer = await dbfFile.async('arraybuffer');\n    const prjContent = prjFile ? await prjFile.async('string') : null;\n\n    const geojson = await new Promise((resolve, reject) => {\n      shapefile.read(shpBuffer, dbfBuffer)\n        .then(geojson => resolve(geojson))\n        .catch(error => reject(error));\n    });\n\n    return { geojson, projectionString: prjContent };\n}\n\nexport const appendDropDownFileLoader = (div: HTMLDivElement, fn: (e: DragEvent) => any) => {\n    div.addEventListener('dragover', (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        e.dataTransfer.dropEffect = 'copy';\n    });\n    div.addEventListener('drop', async (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        fn(e);\n    });\n}\n\nexport const mapBoxVisualizeGeoJSON = (map, geojson) => {\n  if (map.getSource('geojson-data')) {\n\n    const existingLayers = map.getStyle().layers || [];\n    existingLayers.forEach(layer => {\n        if (layer.id.startsWith('geojson-layer')) {\n            map.removeLayer(layer.id);\n        }\n    });\n    map.removeSource('geojson-data');\n}\n\nmap.addSource('geojson-data', {\n    type: 'geojson',\n    data: geojson\n});\n\n  // 피처 타입에 따라 레이어 추가\n  geojson.features.forEach(feature => {\n      let layerType;\n      let paint;\n\n      switch (feature.geometry.type) {\n          case 'Polygon':\n          case 'MultiPolygon':\n              layerType = 'fill';\n              paint = {\n                  'fill-color': '#088',\n                  'fill-opacity': 0.8\n              };\n              break;\n          case 'LineString':\n          case 'MultiLineString':\n              layerType = 'line';\n              paint = {\n                  'line-color': '#088',\n                  'line-width': 2\n              };\n              break;\n          case 'Point':\n          case 'MultiPoint':\n              layerType = 'circle';\n              paint = {\n                  'circle-radius': 6,\n                  'circle-color': '#088'\n              };\n              break;\n          default:\n              return; // 기타 피처 타입은 무시\n      }\n\n      map.addLayer({\n          id: `geojson-layer-${feature.id || feature.geometry.type}`, // 고유한 ID를 사용\n          type: layerType,\n          source: 'geojson-data',\n          filter: ['==', '$type', feature.geometry.type], // 특정 피처 타입에 대한 필터\n          paint\n      });\n  });\n\n  // 지도 뷰를 GeoJSON 데이터의 범위로 조정\n  const bounds = new mapboxgl.LngLatBounds();\n  geojson.features.forEach(feature => {\n      if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n          feature.geometry.coordinates.forEach(ring => {\n              ring.forEach(coord => {\n                  bounds.extend(coord);\n              });\n          });\n      } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n          feature.geometry.coordinates.forEach(coord => {\n              bounds.extend(coord);\n          });\n      } else if (feature.geometry.type === 'Point' || feature.geometry.type === 'MultiPoint') {\n          bounds.extend(feature.geometry.coordinates);\n      }\n  });\n\n  try {\n    map.fitBounds(bounds, { padding: 50 });\n  } catch (error) {\n    console.error(error)\n  }\n};\n\n\n\nexport const mapBoxVisualizeGeoJSONMulti = (map, geojson) => {\n  if (map.getSource('geojson-data')) {\n      // 기존 레이어와 소스를 제거\n      const existingLayers = map.getStyle().layers || [];\n      existingLayers.forEach(layer => {\n          if (layer.id.startsWith('geojson-layer')) {\n              map.removeLayer(layer.id);\n          }\n      });\n      map.removeSource('geojson-data');\n  }\n\n  map.addSource('geojson-data', {\n      type: 'geojson',\n      data: geojson\n  });\n\n  geojson.features.forEach((feature, index) => {\n      let layerType;\n      let paint;\n      let filter;\n\n      switch (feature.geometry.type) {\n          case 'Polygon':\n              layerType = 'fill';\n              paint = {\n                  'fill-color': '#088',\n                  'fill-opacity': 0.8\n              };\n              filter = ['==', '$type', 'Polygon'];\n              break;\n          case 'MultiPolygon':\n              layerType = 'fill';\n              paint = {\n                  'fill-color': '#088',\n                  'fill-opacity': 0.8\n              };\n              filter = ['==', '$type', 'Polygon']; // MultiPolygon을 Polygon으로 처리\n              break;\n          case 'LineString':\n              layerType = 'line';\n              paint = {\n                  'line-color': '#088',\n                  'line-width': 2\n              };\n              filter = ['==', '$type', 'LineString'];\n              break;\n          case 'MultiLineString':\n              layerType = 'line';\n              paint = {\n                  'line-color': '#088',\n                  'line-width': 2\n              };\n              filter = ['==', '$type', 'LineString']; // MultiLineString도 LineString으로 처리\n              break;\n          case 'Point':\n              layerType = 'circle';\n              paint = {\n                  'circle-radius': 6,\n                  'circle-color': '#088'\n              };\n              filter = ['==', '$type', 'Point'];\n              break;\n          case 'MultiPoint':\n              layerType = 'circle';\n              paint = {\n                  'circle-radius': 6,\n                  'circle-color': '#088'\n              };\n              filter = ['==', '$type', 'Point']; // MultiPoint도 Point으로 처리\n              break;\n          default:\n              return; // 기타 피처 타입은 무시\n      }\n\n      const layerId = `geojson-layer-${feature.geometry.type}-${index}`;\n\n      // 레이어 추가\n      map.addLayer({\n          id: layerId,\n          type: layerType,\n          source: 'geojson-data',\n          paint,\n          filter\n      });\n  });\n\n  // 지도 뷰를 GeoJSON 데이터의 범위로 조정\n  const bounds = new mapboxgl.LngLatBounds();\n  geojson.features.forEach(feature => {\n      if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n          feature.geometry.coordinates.forEach(ring => {\n              ring.forEach(coord => {\n                  bounds.extend(coord);\n              });\n          });\n      } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n          feature.geometry.coordinates.forEach(coord => {\n              bounds.extend(coord);\n          });\n      } else if (feature.geometry.type === 'Point' || feature.geometry.type === 'MultiPoint') {\n          bounds.extend(feature.geometry.coordinates);\n      }\n  });\n\n  map.fitBounds(bounds, { padding: 50 });\n};\n"],"names":["MapboxGLWrapper","constructor","id","map","center","lng","lat","setCenter","toMap","x","y","p","this","unproject","toScreen","lon","project","mouseDown","e","mouseUp","mouseMove","mouseClick","mouseDClick","initMap","mapboxgl","process","container","zoom","style","dragRotate","disable","on","div","document","getElementsByClassName","position","display","Solution","divHost","mapboxWrapper","renderer","mouseDrag","pts","push","getElementById","setTimeout","Renderer","appendDropDownFileLoader","async","files","dataTransfer","length","name","endsWith","zipFile","geojson","projectionString","processZipFile","console","log","transformedGeoJSON","transformCoordinates","mapBoxVisualizeGeoJSON","error","keyDown","k","destroy","lastElementChild","removeChild","RendererCanvas","app","super","time","canvas","width","height","pointerEvents","start","render","ctx","exeCaveman","exeTurf","i","pt","beginPath","arc","Math","sin","PI","closePath","fillStyle","fill","points","turf","hull","units","maxEdge","vs","projected","moveTo","lineTo","strokeStyle","stroke","concaveHull","concaveman","lineWidth","warn","proj4","transformedFeatures","features","feature","coords","coord","geometry","type","transformedPolygonCoordinates","coordinates","ring","transformedMultiPolygonCoordinates","polygon","transformedLineCoordinates","transformedMultiLineCoordinates","line","transformedPoint","transformedMultiPointCoordinates","zip","JSZip","zipContents","loadAsync","shpFile","dbfFile","prjFile","filename","Error","shpBuffer","dbfBuffer","prjContent","Promise","resolve","reject","shapefile","then","catch","fn","addEventListener","preventDefault","stopPropagation","dropEffect","getSource","getStyle","layers","forEach","layer","startsWith","removeLayer","removeSource","addSource","data","layerType","paint","addLayer","source","filter","bounds","extend","fitBounds","padding"],"sourceRoot":""}
{"version":3,"file":"static/js/76379.c089a74e.chunk.js","mappings":"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","sources":["../node_modules/@deck.gl/core/dist/lib/attribute/gl-utils.js","../node_modules/@deck.gl/core/dist/lib/attribute/data-column.js","../node_modules/@deck.gl/core/dist/utils/iterable-utils.js","../node_modules/@deck.gl/core/dist/utils/range.js","../node_modules/@deck.gl/core/dist/lib/attribute/transition-settings.js","../node_modules/@deck.gl/core/dist/lib/attribute/attribute.js","../node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js","../node_modules/@luma.gl/engine/dist/transform/buffer-transform.js","../node_modules/@luma.gl/shadertools/dist/modules-webgl1/math/fp64/fp64-utils.js","../node_modules/@luma.gl/shadertools/dist/modules-webgl1/math/fp64/fp64-arithmetic-glsl.js","../node_modules/@luma.gl/shadertools/dist/modules-webgl1/math/fp64/fp64.js","../node_modules/@deck.gl/core/dist/utils/array-utils.js","../node_modules/@deck.gl/core/dist/transitions/gpu-transition-utils.js","../node_modules/@deck.gl/core/dist/transitions/gpu-transition.js","../node_modules/@deck.gl/core/dist/transitions/gpu-interpolation-transition.js","../node_modules/@deck.gl/core/dist/transitions/gpu-spring-transition.js","../node_modules/@deck.gl/core/dist/lib/attribute/attribute-transition-manager.js","../node_modules/@deck.gl/core/dist/lib/attribute/attribute-manager.js","../node_modules/@deck.gl/core/dist/transitions/cpu-interpolation-transition.js","../node_modules/@deck.gl/core/dist/transitions/cpu-spring-transition.js","../node_modules/@deck.gl/core/dist/lib/uniform-transition-manager.js","../node_modules/@deck.gl/core/dist/lifecycle/props.js","../node_modules/@deck.gl/core/dist/utils/count.js","../node_modules/@deck.gl/core/dist/utils/shader.js","../node_modules/@deck.gl/core/dist/shaderlib/project/project-functions.js","../node_modules/@deck.gl/core/dist/utils/texture.js","../node_modules/@deck.gl/core/dist/lifecycle/prop-types.js","../node_modules/@deck.gl/core/dist/lifecycle/create-props.js","../node_modules/@deck.gl/core/dist/lifecycle/component.js","../node_modules/@deck.gl/core/dist/lifecycle/component-state.js","../node_modules/@deck.gl/core/dist/lib/layer-state.js","../node_modules/@deck.gl/core/dist/lib/layer.js","../node_modules/@luma.gl/shadertools/dist/modules/engine/picking/picking.js","../node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js","../node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js","../node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-vertex.glsl.js","../node_modules/@deck.gl/layers/dist/arc-layer/arc-layer.js","../node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-fragment.glsl.js","../node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-vertex.glsl.js","../node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.js","../node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-fragment.glsl.js","../node_modules/@luma.gl/core/dist/adapter/type-utils/vertex-format-from-attribute.js","../node_modules/@luma.gl/engine/dist/geometry/geometry.js","../node_modules/@luma.gl/core/dist/lib/uniforms/uniform-block.js","../node_modules/@luma.gl/core/dist/utils/array-equal.js","../node_modules/@luma.gl/core/dist/adapter/type-utils/decode-shader-types.js","../node_modules/@luma.gl/core/dist/lib/uniforms/uniform-buffer-layout.js","../node_modules/@luma.gl/core/dist/lib/uniforms/uniform-store.js","../node_modules/@luma.gl/core/dist/utils/deep-equal.js","../node_modules/wgsl_reflect/wgsl_reflect.module.js","../node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js","../node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js","../node_modules/@luma.gl/engine/dist/shader-inputs.js","../node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js","../node_modules/@luma.gl/engine/dist/lib/pipeline-factory.js","../node_modules/@luma.gl/engine/dist/lib/shader-factory.js","../node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js","../node_modules/@luma.gl/engine/dist/model/model.js","../node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js"],"sourcesContent":["import { getTypedArrayFromDataType, getDataTypeFromTypedArray } from '@luma.gl/core';\nexport function typedArrayFromDataType(type) {\n    // Sorted in some order of likelihood to reduce amount of comparisons\n    switch (type) {\n        case 'float64':\n            return Float64Array;\n        case 'uint8':\n        case 'unorm8':\n            return Uint8ClampedArray;\n        default:\n            return getTypedArrayFromDataType(type);\n    }\n}\nexport const dataTypeFromTypedArray = getDataTypeFromTypedArray;\nexport function getBufferAttributeLayout(name, accessor) {\n    return {\n        attribute: name,\n        // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure\n        format: accessor.size > 1\n            ? `${accessor.type}x${accessor.size}`\n            : accessor.type,\n        byteOffset: accessor.offset || 0\n        // Note stride is set on the top level\n    };\n}\nexport function getStride(accessor) {\n    return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\nexport function bufferLayoutEqual(accessor1, accessor2) {\n    return (accessor1.type === accessor2.type &&\n        accessor1.size === accessor2.size &&\n        getStride(accessor1) === getStride(accessor2) &&\n        (accessor1.offset || 0) === (accessor2.offset || 0));\n}\n","import { Buffer } from '@luma.gl/core';\nimport { typedArrayFromDataType, getBufferAttributeLayout, getStride, dataTypeFromTypedArray } from \"./gl-utils.js\";\nimport typedArrayManager from \"../../utils/typed-array-manager.js\";\nimport { toDoublePrecisionArray } from \"../../utils/math-utils.js\";\nimport log from \"../../utils/log.js\";\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n    if (shaderAttributeOptions.offset) {\n        log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n    }\n    // All shader attributes share the parent's stride\n    const stride = getStride(baseAccessor);\n    // `vertexOffset` is used to access the neighboring vertex's value\n    // e.g. `nextPositions` in polygon\n    const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined\n        ? shaderAttributeOptions.vertexOffset\n        : baseAccessor.vertexOffset || 0;\n    // `elementOffset` is defined when shader attribute's size is smaller than the parent's\n    // e.g. `translations` in transform matrix\n    const elementOffset = shaderAttributeOptions.elementOffset || 0;\n    const offset = \n    // offsets defined by the attribute\n    vertexOffset * stride +\n        elementOffset * baseAccessor.bytesPerElement +\n        // offsets defined by external buffers if any\n        (baseAccessor.offset || 0);\n    return {\n        ...shaderAttributeOptions,\n        offset,\n        stride\n    };\n}\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n    const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n    return {\n        high: resolvedOptions,\n        low: {\n            ...resolvedOptions,\n            offset: resolvedOptions.offset + baseAccessor.size * 4\n        }\n    };\n}\nexport default class DataColumn {\n    /* eslint-disable max-statements */\n    constructor(device, opts, state) {\n        this._buffer = null;\n        this.device = device;\n        this.id = opts.id || '';\n        this.size = opts.size || 1;\n        const logicalType = opts.logicalType || opts.type;\n        const doublePrecision = logicalType === 'float64';\n        let { defaultValue } = opts;\n        defaultValue = Number.isFinite(defaultValue)\n            ? [defaultValue]\n            : defaultValue || new Array(this.size).fill(0);\n        let bufferType;\n        if (doublePrecision) {\n            bufferType = 'float32';\n        }\n        else if (!logicalType && opts.isIndexed) {\n            bufferType = 'uint32';\n        }\n        else {\n            bufferType = logicalType || 'float32';\n        }\n        // This is the attribute type defined by the layer\n        // If an external buffer is provided, this.type may be overwritten\n        // But we always want to use defaultType for allocation\n        let defaultType = typedArrayFromDataType(logicalType || bufferType);\n        this.doublePrecision = doublePrecision;\n        // `fp64: false` tells a double-precision attribute to allocate Float32Arrays\n        // by default when using auto-packing. This is more efficient in use cases where\n        // high precision is unnecessary, but the `64Low` attribute is still required\n        // by the shader.\n        if (doublePrecision && opts.fp64 === false) {\n            defaultType = Float32Array;\n        }\n        this.value = null;\n        this.settings = {\n            ...opts,\n            defaultType,\n            defaultValue: defaultValue,\n            logicalType,\n            type: bufferType,\n            normalized: bufferType.includes('norm'),\n            size: this.size,\n            bytesPerElement: defaultType.BYTES_PER_ELEMENT\n        };\n        this.state = {\n            ...state,\n            externalBuffer: null,\n            bufferAccessor: this.settings,\n            allocatedValue: null,\n            numInstances: 0,\n            bounds: null,\n            constant: false\n        };\n    }\n    /* eslint-enable max-statements */\n    get isConstant() {\n        return this.state.constant;\n    }\n    get buffer() {\n        return this._buffer;\n    }\n    get byteOffset() {\n        const accessor = this.getAccessor();\n        if (accessor.vertexOffset) {\n            return accessor.vertexOffset * getStride(accessor);\n        }\n        return 0;\n    }\n    get numInstances() {\n        return this.state.numInstances;\n    }\n    set numInstances(n) {\n        this.state.numInstances = n;\n    }\n    delete() {\n        if (this._buffer) {\n            this._buffer.delete();\n            this._buffer = null;\n        }\n        typedArrayManager.release(this.state.allocatedValue);\n    }\n    getBuffer() {\n        if (this.state.constant) {\n            return null;\n        }\n        return this.state.externalBuffer || this._buffer;\n    }\n    getValue(attributeName = this.id, options = null) {\n        const result = {};\n        if (this.state.constant) {\n            const value = this.value;\n            if (options) {\n                const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n                const offset = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;\n                const size = shaderAttributeDef.size || this.size;\n                result[attributeName] = value.subarray(offset, offset + size);\n            }\n            else {\n                result[attributeName] = value;\n            }\n        }\n        else {\n            result[attributeName] = this.getBuffer();\n        }\n        if (this.doublePrecision) {\n            if (this.value instanceof Float64Array) {\n                result[`${attributeName}64Low`] = result[attributeName];\n            }\n            else {\n                // Disable fp64 low part\n                result[`${attributeName}64Low`] = new Float32Array(this.size);\n            }\n        }\n        return result;\n    }\n    _getBufferLayout(attributeName = this.id, options = null) {\n        const accessor = this.getAccessor();\n        const attributes = [];\n        const result = {\n            name: this.id,\n            byteStride: getStride(accessor),\n            attributes\n        };\n        if (this.doublePrecision) {\n            const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(accessor, options || {});\n            attributes.push(getBufferAttributeLayout(attributeName, { ...accessor, ...doubleShaderAttributeDefs.high }), getBufferAttributeLayout(`${attributeName}64Low`, {\n                ...accessor,\n                ...doubleShaderAttributeDefs.low\n            }));\n        }\n        else if (options) {\n            const shaderAttributeDef = resolveShaderAttribute(accessor, options);\n            attributes.push(getBufferAttributeLayout(attributeName, { ...accessor, ...shaderAttributeDef }));\n        }\n        else {\n            attributes.push(getBufferAttributeLayout(attributeName, accessor));\n        }\n        return result;\n    }\n    setAccessor(accessor) {\n        this.state.bufferAccessor = accessor;\n    }\n    getAccessor() {\n        return this.state.bufferAccessor;\n    }\n    // Returns [min: Array(size), max: Array(size)]\n    /* eslint-disable max-depth */\n    getBounds() {\n        if (this.state.bounds) {\n            return this.state.bounds;\n        }\n        let result = null;\n        if (this.state.constant && this.value) {\n            const min = Array.from(this.value);\n            result = [min, min];\n        }\n        else {\n            const { value, numInstances, size } = this;\n            const len = numInstances * size;\n            if (value && len && value.length >= len) {\n                const min = new Array(size).fill(Infinity);\n                const max = new Array(size).fill(-Infinity);\n                for (let i = 0; i < len;) {\n                    for (let j = 0; j < size; j++) {\n                        const v = value[i++];\n                        if (v < min[j])\n                            min[j] = v;\n                        if (v > max[j])\n                            max[j] = v;\n                    }\n                }\n                result = [min, max];\n            }\n        }\n        this.state.bounds = result;\n        return result;\n    }\n    // returns true if success\n    // eslint-disable-next-line max-statements\n    setData(data) {\n        const { state } = this;\n        let opts;\n        if (ArrayBuffer.isView(data)) {\n            opts = { value: data };\n        }\n        else if (data instanceof Buffer) {\n            opts = { buffer: data };\n        }\n        else {\n            opts = data;\n        }\n        const accessor = { ...this.settings, ...opts };\n        if (ArrayBuffer.isView(opts.value)) {\n            if (!opts.type) {\n                // Deduce data type\n                const is64Bit = this.doublePrecision && opts.value instanceof Float64Array;\n                if (is64Bit) {\n                    accessor.type = 'float32';\n                }\n                else {\n                    const type = dataTypeFromTypedArray(opts.value);\n                    accessor.type = accessor.normalized ? type.replace('int', 'norm') : type;\n                }\n            }\n            accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;\n            accessor.stride = getStride(accessor);\n        }\n        state.bounds = null; // clear cached bounds\n        if (opts.constant) {\n            // set constant\n            let value = opts.value;\n            value = this._normalizeValue(value, [], 0);\n            if (this.settings.normalized) {\n                value = this.normalizeConstant(value);\n            }\n            const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n            if (!hasChanged) {\n                return false;\n            }\n            state.externalBuffer = null;\n            state.constant = true;\n            this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);\n        }\n        else if (opts.buffer) {\n            const buffer = opts.buffer;\n            state.externalBuffer = buffer;\n            state.constant = false;\n            this.value = opts.value || null;\n        }\n        else if (opts.value) {\n            this._checkExternalBuffer(opts);\n            let value = opts.value;\n            state.externalBuffer = null;\n            state.constant = false;\n            this.value = value;\n            let { buffer } = this;\n            const stride = getStride(accessor);\n            const byteOffset = (accessor.vertexOffset || 0) * stride;\n            if (this.doublePrecision && value instanceof Float64Array) {\n                value = toDoublePrecisionArray(value, accessor);\n            }\n            if (this.settings.isIndexed) {\n                const ArrayType = this.settings.defaultType;\n                if (value.constructor !== ArrayType) {\n                    // Cast the index buffer to expected type\n                    value = new ArrayType(value);\n                }\n            }\n            // A small over allocation is used as safety margin\n            // Shader attributes may try to access this buffer with bigger offsets\n            const requiredBufferSize = value.byteLength + byteOffset + stride * 2;\n            if (!buffer || buffer.byteLength < requiredBufferSize) {\n                buffer = this._createBuffer(requiredBufferSize);\n            }\n            buffer.write(value, byteOffset);\n        }\n        this.setAccessor(accessor);\n        return true;\n    }\n    updateSubBuffer(opts = {}) {\n        this.state.bounds = null; // clear cached bounds\n        const value = this.value;\n        const { startOffset = 0, endOffset } = opts;\n        this.buffer.write(this.doublePrecision && value instanceof Float64Array\n            ? toDoublePrecisionArray(value, {\n                size: this.size,\n                startIndex: startOffset,\n                endIndex: endOffset\n            })\n            : value.subarray(startOffset, endOffset), startOffset * value.BYTES_PER_ELEMENT + this.byteOffset);\n    }\n    allocate(numInstances, copy = false) {\n        const { state } = this;\n        const oldValue = state.allocatedValue;\n        // Allocate at least one element to ensure a valid buffer\n        const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n            size: this.size,\n            type: this.settings.defaultType,\n            copy\n        });\n        this.value = value;\n        const { byteOffset } = this;\n        let { buffer } = this;\n        if (!buffer || buffer.byteLength < value.byteLength + byteOffset) {\n            buffer = this._createBuffer(value.byteLength + byteOffset);\n            if (copy && oldValue) {\n                // Upload the full existing attribute value to the GPU, so that updateBuffer\n                // can choose to only update a partial range.\n                // TODO - copy old buffer to new buffer on the GPU\n                buffer.write(oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue, byteOffset);\n            }\n        }\n        state.allocatedValue = value;\n        state.constant = false;\n        state.externalBuffer = null;\n        this.setAccessor(this.settings);\n        return true;\n    }\n    // PRIVATE HELPER METHODS\n    _checkExternalBuffer(opts) {\n        const { value } = opts;\n        if (!ArrayBuffer.isView(value)) {\n            throw new Error(`Attribute ${this.id} value is not TypedArray`);\n        }\n        const ArrayType = this.settings.defaultType;\n        let illegalArrayType = false;\n        if (this.doublePrecision) {\n            // not 32bit or 64bit\n            illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n        }\n        if (illegalArrayType) {\n            throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);\n        }\n        if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n            log.warn(`Attribute ${this.id} is normalized`)();\n        }\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n    normalizeConstant(value) {\n        /* eslint-disable complexity */\n        switch (this.settings.type) {\n            case 'snorm8':\n                // normalize [-128, 127] to [-1, 1]\n                return new Float32Array(value).map(x => ((x + 128) / 255) * 2 - 1);\n            case 'snorm16':\n                // normalize [-32768, 32767] to [-1, 1]\n                return new Float32Array(value).map(x => ((x + 32768) / 65535) * 2 - 1);\n            case 'unorm8':\n                // normalize [0, 255] to [0, 1]\n                return new Float32Array(value).map(x => x / 255);\n            case 'unorm16':\n                // normalize [0, 65535] to [0, 1]\n                return new Float32Array(value).map(x => x / 65535);\n            default:\n                // No normalization for gl.FLOAT and gl.HALF_FLOAT\n                return value;\n        }\n    }\n    /* check user supplied values and apply fallback */\n    _normalizeValue(value, out, start) {\n        const { defaultValue, size } = this.settings;\n        if (Number.isFinite(value)) {\n            out[start] = value;\n            return out;\n        }\n        if (!value) {\n            let i = size;\n            while (--i >= 0) {\n                out[start + i] = defaultValue[i];\n            }\n            return out;\n        }\n        // Important - switch cases are 5x more performant than a for loop!\n        /* eslint-disable no-fallthrough, default-case */\n        switch (size) {\n            case 4:\n                out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n            case 3:\n                out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n            case 2:\n                out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n            case 1:\n                out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n                break;\n            default:\n                // In the rare case where the attribute size > 4, do it the slow way\n                // This is used for e.g. transform matrices\n                let i = size;\n                while (--i >= 0) {\n                    out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n                }\n        }\n        return out;\n    }\n    _areValuesEqual(value1, value2) {\n        if (!value1 || !value2) {\n            return false;\n        }\n        const { size } = this;\n        for (let i = 0; i < size; i++) {\n            if (value1[i] !== value2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _createBuffer(byteLength) {\n        if (this._buffer) {\n            this._buffer.destroy();\n        }\n        const { isIndexed, type } = this.settings;\n        this._buffer = this.device.createBuffer({\n            ...this._buffer?.props,\n            id: this.id,\n            usage: isIndexed ? Buffer.INDEX : Buffer.VERTEX,\n            indexType: isIndexed ? type : undefined,\n            byteLength\n        });\n        return this._buffer;\n    }\n}\n","const EMPTY_ARRAY = [];\nconst placeholderArray = [];\n/*\n * Create an Iterable\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\n * and a \"context\" tracker from the given data\n */\nexport function createIterable(data, startRow = 0, endRow = Infinity) {\n    let iterable = EMPTY_ARRAY;\n    const objectInfo = {\n        index: -1,\n        data,\n        // visitor can optionally utilize this to avoid constructing a new array for every object\n        target: []\n    };\n    if (!data) {\n        iterable = EMPTY_ARRAY;\n    }\n    else if (typeof data[Symbol.iterator] === 'function') {\n        // data is already an iterable\n        iterable = data;\n    }\n    else if (data.length > 0) {\n        placeholderArray.length = data.length;\n        iterable = placeholderArray;\n    }\n    if (startRow > 0 || Number.isFinite(endRow)) {\n        iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);\n        objectInfo.index = startRow - 1;\n    }\n    return { iterable, objectInfo };\n}\n/*\n * Returns true if data is an async iterable object\n */\nexport function isAsyncIterable(data) {\n    return data && data[Symbol.asyncIterator];\n}\n/*\n * Create an accessor function from a flat buffer that yields the value at each object index\n */\nexport function getAccessorFromBuffer(typedArray, options) {\n    const { size, stride, offset, startIndices, nested } = options;\n    const bytesPerElement = typedArray.BYTES_PER_ELEMENT;\n    const elementStride = stride ? stride / bytesPerElement : size;\n    const elementOffset = offset ? offset / bytesPerElement : 0;\n    const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);\n    return (_, { index, target }) => {\n        if (!startIndices) {\n            const sourceIndex = index * elementStride + elementOffset;\n            for (let j = 0; j < size; j++) {\n                target[j] = typedArray[sourceIndex + j];\n            }\n            return target;\n        }\n        const startIndex = startIndices[index];\n        const endIndex = startIndices[index + 1] || vertexCount;\n        let result;\n        if (nested) {\n            result = new Array(endIndex - startIndex);\n            for (let i = startIndex; i < endIndex; i++) {\n                const sourceIndex = i * elementStride + elementOffset;\n                target = new Array(size);\n                for (let j = 0; j < size; j++) {\n                    target[j] = typedArray[sourceIndex + j];\n                }\n                result[i - startIndex] = target;\n            }\n        }\n        else if (elementStride === size) {\n            result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);\n        }\n        else {\n            result = new typedArray.constructor((endIndex - startIndex) * size);\n            let targetIndex = 0;\n            for (let i = startIndex; i < endIndex; i++) {\n                const sourceIndex = i * elementStride + elementOffset;\n                for (let j = 0; j < size; j++) {\n                    result[targetIndex++] = typedArray[sourceIndex + j];\n                }\n            }\n        }\n        return result;\n    };\n}\n","/*\n * range (Array)\n *   + start (Number) - the start index (incl.)\n *   + end (Number) - the end index (excl.)\n * rangeList (Array) - array of sorted, combined ranges\n */\nexport const EMPTY = [];\nexport const FULL = [[0, Infinity]];\n// Insert a range into a range collection\nexport function add(rangeList, range) {\n    // Noop if range collection already covers all\n    if (rangeList === FULL) {\n        return rangeList;\n    }\n    // Validate the input range\n    if (range[0] < 0) {\n        range[0] = 0;\n    }\n    if (range[0] >= range[1]) {\n        return rangeList;\n    }\n    // TODO - split off to tree-shakable Range class\n    const newRangeList = [];\n    const len = rangeList.length;\n    let insertPosition = 0;\n    for (let i = 0; i < len; i++) {\n        const range0 = rangeList[i];\n        if (range0[1] < range[0]) {\n            // the current range is to the left of the new range\n            newRangeList.push(range0);\n            insertPosition = i + 1;\n        }\n        else if (range0[0] > range[1]) {\n            // the current range is to the right of the new range\n            newRangeList.push(range0);\n        }\n        else {\n            range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];\n        }\n    }\n    newRangeList.splice(insertPosition, 0, range);\n    return newRangeList;\n}\n","const DEFAULT_TRANSITION_SETTINGS = {\n    interpolation: {\n        duration: 0,\n        easing: t => t\n    },\n    spring: {\n        stiffness: 0.05,\n        damping: 0.5\n    }\n};\nexport function normalizeTransitionSettings(userSettings, layerSettings) {\n    if (!userSettings) {\n        return null;\n    }\n    if (Number.isFinite(userSettings)) {\n        userSettings = { type: 'interpolation', duration: userSettings };\n    }\n    const type = userSettings.type || 'interpolation';\n    return {\n        ...DEFAULT_TRANSITION_SETTINGS[type],\n        ...layerSettings,\n        ...userSettings,\n        type\n    };\n}\n","/* eslint-disable complexity */\nimport DataColumn from \"./data-column.js\";\nimport assert from \"../../utils/assert.js\";\nimport { createIterable, getAccessorFromBuffer } from \"../../utils/iterable-utils.js\";\nimport { fillArray } from \"../../utils/flatten.js\";\nimport * as range from \"../../utils/range.js\";\nimport { bufferLayoutEqual } from \"./gl-utils.js\";\nimport { normalizeTransitionSettings } from \"./transition-settings.js\";\nexport default class Attribute extends DataColumn {\n    constructor(device, opts) {\n        super(device, opts, {\n            startIndices: null,\n            lastExternalBuffer: null,\n            binaryValue: null,\n            binaryAccessor: null,\n            needsUpdate: true,\n            needsRedraw: false,\n            layoutChanged: false,\n            updateRanges: range.FULL\n        });\n        /** Legacy approach to set attribute value - read `isConstant` instead for attribute state */\n        this.constant = false;\n        // eslint-disable-next-line\n        this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n        Object.seal(this.settings);\n        Object.seal(this.state);\n        // Check all fields and generate helpful error messages\n        this._validateAttributeUpdaters();\n    }\n    get startIndices() {\n        return this.state.startIndices;\n    }\n    set startIndices(layout) {\n        this.state.startIndices = layout;\n    }\n    needsUpdate() {\n        return this.state.needsUpdate;\n    }\n    needsRedraw({ clearChangedFlags = false } = {}) {\n        const needsRedraw = this.state.needsRedraw;\n        this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n        return needsRedraw;\n    }\n    layoutChanged() {\n        return this.state.layoutChanged;\n    }\n    setAccessor(accessor) {\n        var _a;\n        (_a = this.state).layoutChanged || (_a.layoutChanged = !bufferLayoutEqual(accessor, this.getAccessor()));\n        super.setAccessor(accessor);\n    }\n    getUpdateTriggers() {\n        const { accessor } = this.settings;\n        // Backards compatibility: allow attribute name to be used as update trigger key\n        return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n    }\n    supportsTransition() {\n        return Boolean(this.settings.transition);\n    }\n    // Resolve transition settings object if transition is enabled, otherwise `null`\n    getTransitionSetting(opts) {\n        if (!opts || !this.supportsTransition()) {\n            return null;\n        }\n        const { accessor } = this.settings;\n        // TODO: have the layer resolve these transition settings itself?\n        const layerSettings = this.settings.transition;\n        // these are the transition settings passed in by the user\n        const userSettings = Array.isArray(accessor)\n            ? // @ts-ignore\n                opts[accessor.find(a => opts[a])]\n            : // @ts-ignore\n                opts[accessor];\n        // Shorthand: use duration instead of parameter object\n        return normalizeTransitionSettings(userSettings, layerSettings);\n    }\n    setNeedsUpdate(reason = this.id, dataRange) {\n        this.state.needsUpdate = this.state.needsUpdate || reason;\n        this.setNeedsRedraw(reason);\n        if (dataRange) {\n            const { startRow = 0, endRow = Infinity } = dataRange;\n            this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n        }\n        else {\n            this.state.updateRanges = range.FULL;\n        }\n    }\n    clearNeedsUpdate() {\n        this.state.needsUpdate = false;\n        this.state.updateRanges = range.EMPTY;\n    }\n    setNeedsRedraw(reason = this.id) {\n        this.state.needsRedraw = this.state.needsRedraw || reason;\n    }\n    allocate(numInstances) {\n        const { state, settings } = this;\n        if (settings.noAlloc) {\n            // Data is provided through a Buffer object.\n            return false;\n        }\n        if (settings.update) {\n            super.allocate(numInstances, state.updateRanges !== range.FULL);\n            return true;\n        }\n        return false;\n    }\n    updateBuffer({ numInstances, data, props, context }) {\n        if (!this.needsUpdate()) {\n            return false;\n        }\n        const { state: { updateRanges }, settings: { update, noAlloc } } = this;\n        let updated = true;\n        if (update) {\n            // Custom updater - typically for non-instanced layers\n            for (const [startRow, endRow] of updateRanges) {\n                update.call(context, this, { data, startRow, endRow, props, numInstances });\n            }\n            if (!this.value) {\n                // no value was assigned during update\n            }\n            else if (this.constant ||\n                !this.buffer ||\n                this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n                this.setData({\n                    value: this.value,\n                    constant: this.constant\n                });\n                // Setting attribute.constant in updater is a legacy approach that interferes with allocation in the next cycle\n                // Respect it here but reset after use\n                this.constant = false;\n            }\n            else {\n                for (const [startRow, endRow] of updateRanges) {\n                    const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n                    const endOffset = Number.isFinite(endRow)\n                        ? this.getVertexOffset(endRow)\n                        : noAlloc || !Number.isFinite(numInstances)\n                            ? this.value.length\n                            : numInstances * this.size;\n                    super.updateSubBuffer({ startOffset, endOffset });\n                }\n            }\n            this._checkAttributeArray();\n        }\n        else {\n            updated = false;\n        }\n        this.clearNeedsUpdate();\n        this.setNeedsRedraw();\n        return updated;\n    }\n    // Use generic value\n    // Returns true if successful\n    setConstantValue(value) {\n        if (value === undefined || typeof value === 'function') {\n            return false;\n        }\n        const hasChanged = this.setData({ constant: true, value });\n        if (hasChanged) {\n            this.setNeedsRedraw();\n        }\n        this.clearNeedsUpdate();\n        return true;\n    }\n    // Use external buffer\n    // Returns true if successful\n    // eslint-disable-next-line max-statements\n    setExternalBuffer(buffer) {\n        const { state } = this;\n        if (!buffer) {\n            state.lastExternalBuffer = null;\n            return false;\n        }\n        this.clearNeedsUpdate();\n        if (state.lastExternalBuffer === buffer) {\n            return true;\n        }\n        state.lastExternalBuffer = buffer;\n        this.setNeedsRedraw();\n        this.setData(buffer);\n        return true;\n    }\n    // Binary value is a typed array packed from mapping the source data with the accessor\n    // If the returned value from the accessor is the same as the attribute value, set it directly\n    // Otherwise use the auto updater for transform/normalization\n    setBinaryValue(buffer, startIndices = null) {\n        const { state, settings } = this;\n        if (!buffer) {\n            state.binaryValue = null;\n            state.binaryAccessor = null;\n            return false;\n        }\n        if (settings.noAlloc) {\n            // Let the layer handle this\n            return false;\n        }\n        if (state.binaryValue === buffer) {\n            this.clearNeedsUpdate();\n            return true;\n        }\n        state.binaryValue = buffer;\n        this.setNeedsRedraw();\n        const needsUpdate = settings.transform || startIndices !== this.startIndices;\n        if (needsUpdate) {\n            if (ArrayBuffer.isView(buffer)) {\n                buffer = { value: buffer };\n            }\n            const binaryValue = buffer;\n            assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);\n            const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n            state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n                size: binaryValue.size || this.size,\n                stride: binaryValue.stride,\n                offset: binaryValue.offset,\n                startIndices: startIndices,\n                nested: needsNormalize\n            });\n            // Fall through to auto updater\n            return false;\n        }\n        this.clearNeedsUpdate();\n        this.setData(buffer);\n        return true;\n    }\n    getVertexOffset(row) {\n        const { startIndices } = this;\n        const vertexIndex = startIndices\n            ? row < startIndices.length\n                ? startIndices[row]\n                : this.numInstances\n            : row;\n        return vertexIndex * this.size;\n    }\n    getValue() {\n        const shaderAttributeDefs = this.settings.shaderAttributes;\n        const result = super.getValue();\n        if (!shaderAttributeDefs) {\n            return result;\n        }\n        for (const shaderAttributeName in shaderAttributeDefs) {\n            Object.assign(result, super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n        }\n        return result;\n    }\n    /** Generate WebGPU-style buffer layout descriptor from this attribute */\n    getBufferLayout(\n    /** A luma.gl Model-shaped object that supplies additional hint to attribute resolution */\n    modelInfo) {\n        // Clear change flag\n        this.state.layoutChanged = false;\n        const shaderAttributeDefs = this.settings.shaderAttributes;\n        const result = super._getBufferLayout();\n        const { stepMode } = this.settings;\n        if (stepMode === 'dynamic') {\n            // If model info is provided, use isInstanced flag to determine step mode\n            // If no model info is provided, assume it's an instanced model (most common use case)\n            result.stepMode = modelInfo ? (modelInfo.isInstanced ? 'instance' : 'vertex') : 'instance';\n        }\n        else {\n            result.stepMode = stepMode ?? 'vertex';\n        }\n        if (!shaderAttributeDefs) {\n            return result;\n        }\n        for (const shaderAttributeName in shaderAttributeDefs) {\n            const map = super._getBufferLayout(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]);\n            // @ts-ignore\n            result.attributes.push(...map.attributes);\n        }\n        return result;\n    }\n    /* eslint-disable max-depth, max-statements */\n    _autoUpdater(attribute, { data, startRow, endRow, props, numInstances }) {\n        if (attribute.constant) {\n            return;\n        }\n        const { settings, state, value, size, startIndices } = attribute;\n        const { accessor, transform } = settings;\n        const accessorFunc = state.binaryAccessor ||\n            // @ts-ignore\n            (typeof accessor === 'function' ? accessor : props[accessor]);\n        assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n        let i = attribute.getVertexOffset(startRow);\n        const { iterable, objectInfo } = createIterable(data, startRow, endRow);\n        for (const object of iterable) {\n            objectInfo.index++;\n            let objectValue = accessorFunc(object, objectInfo);\n            if (transform) {\n                // transform callbacks could be bound to a particular layer instance.\n                // always point `this` to the current layer.\n                objectValue = transform.call(this, objectValue);\n            }\n            if (startIndices) {\n                const numVertices = (objectInfo.index < startIndices.length - 1\n                    ? startIndices[objectInfo.index + 1]\n                    : numInstances) - startIndices[objectInfo.index];\n                if (objectValue && Array.isArray(objectValue[0])) {\n                    let startIndex = i;\n                    for (const item of objectValue) {\n                        attribute._normalizeValue(item, value, startIndex);\n                        startIndex += size;\n                    }\n                }\n                else if (objectValue && objectValue.length > size) {\n                    value.set(objectValue, i);\n                }\n                else {\n                    attribute._normalizeValue(objectValue, objectInfo.target, 0);\n                    fillArray({\n                        target: value,\n                        source: objectInfo.target,\n                        start: i,\n                        count: numVertices\n                    });\n                }\n                i += numVertices * size;\n            }\n            else {\n                attribute._normalizeValue(objectValue, value, i);\n                i += size;\n            }\n        }\n    }\n    /* eslint-enable max-depth, max-statements */\n    // Validate deck.gl level fields\n    _validateAttributeUpdaters() {\n        const { settings } = this;\n        // Check that 'update' is a valid function\n        const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n        if (!hasUpdater) {\n            throw new Error(`Attribute ${this.id} missing update or accessor`);\n        }\n    }\n    // check that the first few elements of the attribute are reasonable\n    /* eslint-disable no-fallthrough */\n    _checkAttributeArray() {\n        const { value } = this;\n        const limit = Math.min(4, this.size);\n        if (value && value.length >= limit) {\n            let valid = true;\n            switch (limit) {\n                case 4:\n                    valid = valid && Number.isFinite(value[3]);\n                case 3:\n                    valid = valid && Number.isFinite(value[2]);\n                case 2:\n                    valid = valid && Number.isFinite(value[1]);\n                case 1:\n                    valid = valid && Number.isFinite(value[0]);\n                    break;\n                default:\n                    valid = false;\n            }\n            if (!valid) {\n                throw new Error(`Illegal attribute generated for ${this.id}`);\n            }\n        }\n    }\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { glsl } from \"./highlight.js\";\nconst FS_GLES = `\\\nout vec4 transform_output;\nvoid main() {\ntransform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n    qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n    const words = line.replace(/^\\s+/, '').split(/\\s+/);\n    // TODO add support for precession qualifiers (highp, mediump and lowp)\n    const [qualifier, type, definition] = words;\n    if (!qualifiers.includes(qualifier) || !type || !definition) {\n        return null;\n    }\n    const name = definition.split(';')[0];\n    return { qualifier, type, name };\n}\n/**\n * Given the shader input and output variable names,\n * builds and return a pass through fragment shader.\n */\nexport function getPassthroughFS(options) {\n    const { input, inputChannels, output } = options || {};\n    if (!input) {\n        // Default shader\n        return FS300;\n    }\n    if (!inputChannels) {\n        throw new Error('inputChannels');\n    }\n    const inputType = channelCountToType(inputChannels);\n    const outputValue = convertToVec4(input, inputChannels);\n    return `\\\n#version 300 es\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n}\n/** convert glsl type to suffix */\nexport function typeToChannelSuffix(type) {\n    // prettier-ignore\n    switch (type) {\n        case 'float': return 'x';\n        case 'vec2': return 'xy';\n        case 'vec3': return 'xyz';\n        case 'vec4': return 'xyzw';\n        default:\n            throw new Error(type);\n    }\n}\n/** convert glsl type to channel count */\nexport function typeToChannelCount(type) {\n    // prettier-ignore\n    switch (type) {\n        case 'float': return 1;\n        case 'vec2': return 2;\n        case 'vec3': return 3;\n        case 'vec4': return 4;\n        default:\n            throw new Error(type);\n    }\n}\nfunction channelCountToType(channels) {\n    // prettier-ignore\n    switch (channels) {\n        case 1: return 'float';\n        case 2: return 'vec2';\n        case 3: return 'vec3';\n        case 4: return 'vec4';\n        default:\n            throw new Error(`invalid channels: ${channels}`);\n    }\n}\n/** Returns glsl instruction for converting to vec4 */\nexport function convertToVec4(variable, channels) {\n    // prettier-ignore\n    switch (channels) {\n        case 1: return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n        case 2: return `vec4(${variable}, 0.0, 1.0)`;\n        case 3: return `vec4(${variable}, 1.0)`;\n        case 4: return variable;\n        default:\n            throw new Error(`invalid channels: ${channels}`);\n    }\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, assert } from '@luma.gl/core';\nimport { getPassthroughFS } from '@luma.gl/shadertools';\nimport { Model } from \"../model/model.js\";\n/**\n * Creates a pipeline for buffer→buffer transforms.\n * @deprecated\n */\nexport class BufferTransform {\n    device;\n    model;\n    transformFeedback;\n    /** @deprecated Use device feature test. */\n    static isSupported(device) {\n        return device?.info?.type === 'webgl';\n    }\n    constructor(device, props = Model.defaultProps) {\n        assert(BufferTransform.isSupported(device), 'BufferTransform not yet implemented on WebGPU');\n        this.device = device;\n        this.model = new Model(this.device, {\n            id: props.id || 'buffer-transform-model',\n            fs: props.fs || getPassthroughFS(),\n            topology: props.topology || 'point-list',\n            ...props\n        });\n        this.transformFeedback = this.device.createTransformFeedback({\n            layout: this.model.pipeline.shaderLayout,\n            buffers: props.feedbackBuffers\n        });\n        this.model.setTransformFeedback(this.transformFeedback);\n        Object.seal(this);\n    }\n    /** Destroy owned resources. */\n    destroy() {\n        if (this.model) {\n            this.model.destroy();\n        }\n    }\n    /** @deprecated Use {@link destroy}. */\n    delete() {\n        this.destroy();\n    }\n    /** Run one transform loop. */\n    run(options) {\n        const renderPass = this.device.beginRenderPass(options);\n        this.model.draw(renderPass);\n        renderPass.end();\n    }\n    /** @deprecated */\n    update(...args) {\n        // TODO(v9): Method should likely be removed for v9. Keeping a method stub\n        // to assist with migrating DeckGL usage.\n        // eslint-disable-next-line no-console\n        console.warn('TextureTransform#update() not implemented');\n    }\n    /** Returns the {@link Buffer} or {@link BufferRange} for given varying name. */\n    getBuffer(varyingName) {\n        return this.transformFeedback.getBuffer(varyingName);\n    }\n    readAsync(varyingName) {\n        const result = this.getBuffer(varyingName);\n        if (result instanceof Buffer) {\n            return result.readAsync();\n        }\n        const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;\n        return buffer.readAsync(byteOffset, byteLength);\n    }\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Calculate WebGL 64 bit float\n * @param a  - the input float number\n * @param out - the output array. If not supplied, a new array is created.\n * @param startIndex - the index in the output array to fill from. Default 0.\n * @returns - the fp64 representation of the input number\n */\nexport function fp64ify(a, out = [], startIndex = 0) {\n    const hiPart = Math.fround(a);\n    const loPart = a - hiPart;\n    out[startIndex] = hiPart;\n    out[startIndex + 1] = loPart;\n    return out;\n}\n/**\n * Calculate the low part of a WebGL 64 bit float\n * @param a the input float number\n * @returns the lower 32 bit of the number\n */\nexport function fp64LowPart(a) {\n    return a - Math.fround(a);\n}\n/**\n * Calculate WebGL 64 bit matrix (transposed \"Float64Array\")\n * @param matrix  the input matrix\n * @returns the fp64 representation of the input matrix\n */\nexport function fp64ifyMatrix4(matrix) {\n    // Transpose the projection matrix to column major for GLSL.\n    const matrixFP64 = new Float32Array(32);\n    for (let i = 0; i < 4; ++i) {\n        for (let j = 0; j < 4; ++j) {\n            const index = i * 4 + j;\n            fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);\n        }\n    }\n    return matrixFP64;\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { glsl } from \"../../../lib/glsl-utils/highlight.js\";\nexport const fp64arithmeticShader = `\\\nuniform float ONE;\nvec2 split(float a) {\nconst float SPLIT = 4097.0;\nfloat t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nfloat a_hi = t * ONE - (t - a);\nfloat a_lo = a * ONE - a_hi;\n#else\nfloat a_hi = t - (t - a);\nfloat a_lo = a - a_hi;\n#endif\nreturn vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\nvec2 b = split(a.x);\nb.y += a.y;\nreturn b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nfloat sum = (a + b) * ONE;\nfloat err = b - (sum - a) * ONE;\n#else\nfloat sum = a + b;\nfloat err = b - (sum - a);\n#endif\nreturn vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\nfloat s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nfloat v = (s * ONE - a) * ONE;\nfloat err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\nfloat v = s - a;\nfloat err = (a - (s - v)) + (b - v);\n#endif\nreturn vec2(s, err);\n}\nvec2 twoSub(float a, float b) {\nfloat s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nfloat v = (s * ONE - a) * ONE;\nfloat err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\nfloat v = s - a;\nfloat err = (a - (s - v)) - (b + v);\n#endif\nreturn vec2(s, err);\n}\nvec2 twoSqr(float a) {\nfloat prod = a * a;\nvec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nfloat err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\na_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\nfloat err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\nreturn vec2(prod, err);\n}\nvec2 twoProd(float a, float b) {\nfloat prod = a * b;\nvec2 a_fp64 = split(a);\nvec2 b_fp64 = split(b);\nfloat err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\na_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\nreturn vec2(prod, err);\n}\nvec2 sum_fp64(vec2 a, vec2 b) {\nvec2 s, t;\ns = twoSum(a.x, b.x);\nt = twoSum(a.y, b.y);\ns.y += t.x;\ns = quickTwoSum(s.x, s.y);\ns.y += t.y;\ns = quickTwoSum(s.x, s.y);\nreturn s;\n}\nvec2 sub_fp64(vec2 a, vec2 b) {\nvec2 s, t;\ns = twoSub(a.x, b.x);\nt = twoSub(a.y, b.y);\ns.y += t.x;\ns = quickTwoSum(s.x, s.y);\ns.y += t.y;\ns = quickTwoSum(s.x, s.y);\nreturn s;\n}\nvec2 mul_fp64(vec2 a, vec2 b) {\nvec2 prod = twoProd(a.x, b.x);\nprod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\nprod = split2(prod);\n#endif\nprod = quickTwoSum(prod.x, prod.y);\nprod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\nprod = split2(prod);\n#endif\nprod = quickTwoSum(prod.x, prod.y);\nreturn prod;\n}\nvec2 div_fp64(vec2 a, vec2 b) {\nfloat xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\nvec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\nvec2 yn = a * xn;\n#endif\nfloat diff = (sub_fp64(a, mul_fp64(b, yn))).x;\nvec2 prod = twoProd(xn, diff);\nreturn sum_fp64(yn, prod);\n}\nvec2 sqrt_fp64(vec2 a) {\nif (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\nif (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\nfloat x = 1.0 / sqrt(a.x);\nfloat yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\nvec2 yn_sqr = twoSqr(yn) * ONE;\n#else\nvec2 yn_sqr = twoSqr(yn);\n#endif\nfloat diff = sub_fp64(a, yn_sqr).x;\nvec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\nreturn sum_fp64(split(yn), prod);\n#else\nreturn sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n`;\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { fp64ify, fp64LowPart, fp64ifyMatrix4 } from \"./fp64-utils.js\";\nimport { fp64arithmeticShader } from \"./fp64-arithmetic-glsl.js\";\nimport { fp64functionShader } from \"./fp64-functions-glsl.js\";\nconst CONST_UNIFORMS = {\n    // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND\n    ONE: 1.0\n};\nexport { fp64ify, fp64LowPart, fp64ifyMatrix4 };\nfunction getUniforms() {\n    return CONST_UNIFORMS;\n}\n/**\n * 64bit arithmetic: add, sub, mul, div (small subset of fp64 module)\n */\nexport const fp64arithmetic = {\n    name: 'fp64-arithmetic',\n    vs: fp64arithmeticShader,\n    getUniforms,\n    fp64ify,\n    fp64LowPart,\n    fp64ifyMatrix4\n};\n/**\n * Full 64 bit math library\n */\nexport const fp64 = {\n    name: 'fp64',\n    vs: fp64functionShader,\n    dependencies: [fp64arithmetic],\n    // Additional Functions\n    fp64ify,\n    fp64LowPart,\n    fp64ifyMatrix4\n};\n","/*\n * Helper function for padArray\n */\nfunction padArrayChunk(options) {\n    const { source, target, start = 0, size, getData } = options;\n    const end = options.end || target.length;\n    const sourceLength = source.length;\n    const targetLength = end - start;\n    if (sourceLength > targetLength) {\n        target.set(source.subarray(0, targetLength), start);\n        return;\n    }\n    target.set(source, start);\n    if (!getData) {\n        return;\n    }\n    // source is not large enough to fill target space, call `getData` to get filler data\n    let i = sourceLength;\n    while (i < targetLength) {\n        const datum = getData(i, source);\n        for (let j = 0; j < size; j++) {\n            target[start + i] = datum[j] || 0;\n            i++;\n        }\n    }\n}\n/*\n * The padArray function stretches a source array to the size of a target array.\n   The arrays can have internal structures (like the attributes of PathLayer and\n   SolidPolygonLayer), defined by the optional sourceStartIndices and targetStartIndices parameters.\n   If the target array is larger, the getData callback is used to fill in the blanks.\n */\nexport function padArray({ source, target, size, getData, sourceStartIndices, targetStartIndices }) {\n    if (!sourceStartIndices || !targetStartIndices) {\n        // Flat arrays\n        padArrayChunk({\n            source,\n            target,\n            size,\n            getData\n        });\n        return target;\n    }\n    // Arrays have internal structure\n    let sourceIndex = 0;\n    let targetIndex = 0;\n    const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));\n    const n = Math.min(sourceStartIndices.length, targetStartIndices.length);\n    for (let i = 1; i < n; i++) {\n        const nextSourceIndex = sourceStartIndices[i] * size;\n        const nextTargetIndex = targetStartIndices[i] * size;\n        padArrayChunk({\n            source: source.subarray(sourceIndex, nextSourceIndex),\n            target,\n            start: targetIndex,\n            end: nextTargetIndex,\n            size,\n            getData: getChunkData\n        });\n        sourceIndex = nextSourceIndex;\n        targetIndex = nextTargetIndex;\n    }\n    if (targetIndex < target.length) {\n        padArrayChunk({\n            // @ts-ignore\n            source: [],\n            target,\n            start: targetIndex,\n            size,\n            getData: getChunkData\n        });\n    }\n    return target;\n}\n","import { padArray } from \"../utils/array-utils.js\";\nimport Attribute from \"../lib/attribute/attribute.js\";\nimport { GL } from '@luma.gl/constants';\n/** Create a new empty attribute with the same settings: type, shader layout etc. */\nexport function cloneAttribute(attribute) {\n    // `attribute.settings` is the original options passed when constructing the attribute.\n    // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n    const { device, settings, value } = attribute;\n    const newAttribute = new Attribute(device, settings);\n    // Placeholder value - necessary for generating the correct buffer layout\n    newAttribute.setData({\n        value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),\n        normalized: settings.normalized\n    });\n    return newAttribute;\n}\n/** Returns the GLSL attribute type for the given number of float32 components. */\nexport function getAttributeTypeFromSize(size) {\n    switch (size) {\n        case 1:\n            return 'float';\n        case 2:\n            return 'vec2';\n        case 3:\n            return 'vec3';\n        case 4:\n            return 'vec4';\n        default:\n            throw new Error(`No defined attribute type for size \"${size}\"`);\n    }\n}\n/** Returns the {@link VertexFormat} for the given number of float32 components. */\nexport function getFloat32VertexFormat(size) {\n    switch (size) {\n        case 1:\n            return 'float32';\n        case 2:\n            return 'float32x2';\n        case 3:\n            return 'float32x3';\n        case 4:\n            return 'float32x4';\n        default:\n            throw new Error('invalid type size');\n    }\n}\nexport function cycleBuffers(buffers) {\n    buffers.push(buffers.shift());\n}\nexport function getAttributeBufferLength(attribute, numInstances) {\n    const { doublePrecision, settings, value, size } = attribute;\n    const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n    let maxVertexOffset = 0;\n    const { shaderAttributes } = attribute.settings;\n    if (shaderAttributes) {\n        for (const shaderAttribute of Object.values(shaderAttributes)) {\n            maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);\n        }\n    }\n    return ((settings.noAlloc ? value.length : (numInstances + maxVertexOffset) * size) *\n        multiplier);\n}\nexport function matchBuffer({ device, source, target }) {\n    if (!target || target.byteLength < source.byteLength) {\n        target?.destroy();\n        target = device.createBuffer({\n            byteLength: source.byteLength,\n            usage: source.usage\n        });\n    }\n    return target;\n}\n/* eslint-disable complexity */\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\n//\n// padBuffer may return either the original buffer, or a new buffer if the size of the original\n// was insufficient. Callers are responsible for disposing of the original buffer if needed.\nexport function padBuffer({ device, buffer, attribute, fromLength, toLength, fromStartIndices, getData = x => x }) {\n    // TODO: move the precisionMultiplier logic to the attribute when retrieving\n    // its `size` and `elementOffset`?\n    const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n    const size = attribute.size * precisionMultiplier;\n    const byteOffset = attribute.byteOffset;\n    // Transform feedback can only write to float varyings\n    // Attributes of format unorm8/uint8 (1 byte per element) etc will be padded to float32 (4 bytes per element)\n    const targetByteOffset = attribute.settings.bytesPerElement < 4\n        ? (byteOffset / attribute.settings.bytesPerElement) * 4\n        : byteOffset;\n    const toStartIndices = attribute.startIndices;\n    const hasStartIndices = fromStartIndices && toStartIndices;\n    const isConstant = attribute.isConstant;\n    // check if buffer needs to be padded\n    if (!hasStartIndices && buffer && fromLength >= toLength) {\n        return buffer;\n    }\n    const ArrayType = attribute.value instanceof Float64Array\n        ? Float32Array\n        : attribute.value.constructor;\n    const toData = isConstant\n        ? attribute.value\n        : // TODO(v9.1): Avoid non-portable synchronous reads.\n            new ArrayType(attribute\n                .getBuffer()\n                .readSyncWebGL(byteOffset, toLength * ArrayType.BYTES_PER_ELEMENT).buffer);\n    if (attribute.settings.normalized && !isConstant) {\n        const getter = getData;\n        getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n    }\n    const getMissingData = isConstant\n        ? (i, chunk) => getData(toData, chunk)\n        : (i, chunk) => getData(toData.subarray(i + byteOffset, i + byteOffset + size), chunk);\n    // TODO(v9.1): Avoid non-portable synchronous reads.\n    const source = buffer\n        ? new Float32Array(buffer.readSyncWebGL(targetByteOffset, fromLength * 4).buffer)\n        : new Float32Array(0);\n    const target = new Float32Array(toLength);\n    padArray({\n        source,\n        target,\n        sourceStartIndices: fromStartIndices,\n        targetStartIndices: toStartIndices,\n        size,\n        getData: getMissingData\n    });\n    if (!buffer || buffer.byteLength < target.byteLength + targetByteOffset) {\n        buffer?.destroy();\n        buffer = device.createBuffer({\n            byteLength: target.byteLength + targetByteOffset,\n            usage: 35050\n        });\n    }\n    buffer.write(target, targetByteOffset);\n    return buffer;\n}\n","import Transition from \"./transition.js\";\nimport { cloneAttribute, getAttributeBufferLength } from \"./gpu-transition-utils.js\";\nexport class GPUTransitionBase {\n    constructor({ device, attribute, timeline }) {\n        this.buffers = [];\n        /** The vertex count of the last buffer.\n         * Buffer may be larger than the actual length we want to use\n         * because we only reallocate buffers when they grow, not when they shrink,\n         * due to performance costs */\n        this.currentLength = 0;\n        this.device = device;\n        this.transition = new Transition(timeline);\n        this.attribute = attribute;\n        this.attributeInTransition = cloneAttribute(attribute);\n        this.currentStartIndices = attribute.startIndices;\n    }\n    get inProgress() {\n        return this.transition.inProgress;\n    }\n    start(transitionSettings, numInstances, duration = Infinity) {\n        this.settings = transitionSettings;\n        this.currentStartIndices = this.attribute.startIndices;\n        this.currentLength = getAttributeBufferLength(this.attribute, numInstances);\n        this.transition.start({ ...transitionSettings, duration });\n    }\n    update() {\n        const updated = this.transition.update();\n        if (updated) {\n            this.onUpdate();\n        }\n        return updated;\n    }\n    setBuffer(buffer) {\n        this.attributeInTransition.setData({\n            buffer,\n            normalized: this.attribute.settings.normalized,\n            // Retain placeholder value to generate correct shader layout\n            value: this.attributeInTransition.value\n        });\n    }\n    cancel() {\n        this.transition.cancel();\n    }\n    delete() {\n        this.cancel();\n        for (const buffer of this.buffers) {\n            buffer.destroy();\n        }\n        this.buffers.length = 0;\n    }\n}\n","import { BufferTransform } from '@luma.gl/engine';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { GL } from '@luma.gl/constants';\nimport { getAttributeTypeFromSize, cycleBuffers, padBuffer, matchBuffer, getFloat32VertexFormat } from \"./gpu-transition-utils.js\";\nimport { GPUTransitionBase } from \"./gpu-transition.js\";\nexport default class GPUInterpolationTransition extends GPUTransitionBase {\n    constructor({ device, attribute, timeline }) {\n        super({ device, attribute, timeline });\n        this.type = 'interpolation';\n        this.transform = getTransform(device, attribute);\n    }\n    start(transitionSettings, numInstances) {\n        const prevLength = this.currentLength;\n        const prevStartIndices = this.currentStartIndices;\n        super.start(transitionSettings, numInstances, transitionSettings.duration);\n        if (transitionSettings.duration <= 0) {\n            this.transition.cancel();\n            return;\n        }\n        const { buffers, attribute } = this;\n        // Alternate between two buffers when new transitions start.\n        // Last destination buffer is used as an attribute (from state),\n        // And the other buffer is now the current buffer.\n        cycleBuffers(buffers);\n        buffers[0] = padBuffer({\n            device: this.device,\n            buffer: buffers[0],\n            attribute,\n            fromLength: prevLength,\n            toLength: this.currentLength,\n            fromStartIndices: prevStartIndices,\n            getData: transitionSettings.enter\n        });\n        buffers[1] = matchBuffer({\n            device: this.device,\n            source: buffers[0],\n            target: buffers[1]\n        });\n        this.setBuffer(buffers[1]);\n        const { transform } = this;\n        const model = transform.model;\n        let vertexCount = Math.floor(this.currentLength / attribute.size);\n        if (useFp64(attribute)) {\n            vertexCount /= 2;\n        }\n        model.setVertexCount(vertexCount);\n        if (attribute.isConstant) {\n            model.setAttributes({ aFrom: buffers[0] });\n            model.setConstantAttributes({ aTo: attribute.value });\n        }\n        else {\n            model.setAttributes({\n                aFrom: buffers[0],\n                aTo: attribute.getBuffer()\n            });\n        }\n        transform.transformFeedback.setBuffers({ vCurrent: buffers[1] });\n    }\n    onUpdate() {\n        const { duration, easing } = this.settings;\n        const { time } = this.transition;\n        let t = time / duration;\n        if (easing) {\n            t = easing(t);\n        }\n        const { model } = this.transform;\n        model.setUniforms({ time: t });\n        this.transform.run({ discard: true });\n    }\n    delete() {\n        super.delete();\n        this.transform.destroy();\n    }\n}\nconst vs = `\\\n#version 300 es\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nin ATTRIBUTE_TYPE aFrom;\nin ATTRIBUTE_TYPE aTo;\nout ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n`;\nconst vs64 = `\\\n#version 300 es\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nin ATTRIBUTE_TYPE aFrom;\nin ATTRIBUTE_TYPE aFrom64Low;\nin ATTRIBUTE_TYPE aTo;\nin ATTRIBUTE_TYPE aTo64Low;\nout ATTRIBUTE_TYPE vCurrent;\nout ATTRIBUTE_TYPE vCurrent64Low;\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid main(void) {\n  for (int i=0; i<ATTRIBUTE_SIZE; i++) {\n    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), time);\n    vCurrent[i] = value.x;\n    vCurrent64Low[i] = value.y;\n  }\n  gl_Position = vec4(0.0);\n}\n`;\nfunction useFp64(attribute) {\n    return attribute.doublePrecision && attribute.value instanceof Float64Array;\n}\nfunction getTransform(device, attribute) {\n    const attributeSize = attribute.size;\n    const attributeType = getAttributeTypeFromSize(attributeSize);\n    const inputFormat = getFloat32VertexFormat(attributeSize);\n    const bufferLayout = attribute.getBufferLayout();\n    if (useFp64(attribute)) {\n        return new BufferTransform(device, {\n            vs: vs64,\n            bufferLayout: [\n                {\n                    name: 'aFrom',\n                    byteStride: 8 * attributeSize,\n                    attributes: [\n                        { attribute: 'aFrom', format: inputFormat, byteOffset: 0 },\n                        { attribute: 'aFrom64Low', format: inputFormat, byteOffset: 4 * attributeSize }\n                    ]\n                },\n                {\n                    name: 'aTo',\n                    byteStride: 8 * attributeSize,\n                    attributes: [\n                        { attribute: 'aTo', format: inputFormat, byteOffset: 0 },\n                        { attribute: 'aTo64Low', format: inputFormat, byteOffset: 4 * attributeSize }\n                    ]\n                }\n            ],\n            modules: [fp64arithmetic],\n            defines: {\n                ATTRIBUTE_TYPE: attributeType,\n                ATTRIBUTE_SIZE: attributeSize\n            },\n            // Default uniforms are not set without this\n            moduleSettings: {},\n            varyings: ['vCurrent', 'vCurrent64Low'],\n            // @ts-expect-error WebGLRenderPipeline only prop TODO - support in RenderPipeline?\n            bufferMode: 35980,\n            disableWarnings: true\n        });\n    }\n    return new BufferTransform(device, {\n        vs,\n        bufferLayout: [\n            { name: 'aFrom', format: inputFormat },\n            { name: 'aTo', format: bufferLayout.attributes[0].format }\n        ],\n        defines: {\n            ATTRIBUTE_TYPE: attributeType\n        },\n        varyings: ['vCurrent'],\n        disableWarnings: true\n    });\n}\n","import { BufferTransform } from '@luma.gl/engine';\nimport { padBuffer, matchBuffer, getAttributeTypeFromSize, getFloat32VertexFormat, cycleBuffers } from \"./gpu-transition-utils.js\";\nimport { GPUTransitionBase } from \"./gpu-transition.js\";\nexport default class GPUSpringTransition extends GPUTransitionBase {\n    constructor({ device, attribute, timeline }) {\n        super({ device, attribute, timeline });\n        this.type = 'spring';\n        this.texture = getTexture(device);\n        this.framebuffer = getFramebuffer(device, this.texture);\n        this.transform = getTransform(device, attribute);\n    }\n    start(transitionSettings, numInstances) {\n        const prevLength = this.currentLength;\n        const prevStartIndices = this.currentStartIndices;\n        super.start(transitionSettings, numInstances);\n        const { buffers, attribute } = this;\n        for (let i = 0; i < 2; i++) {\n            buffers[i] = padBuffer({\n                device: this.device,\n                buffer: buffers[i],\n                attribute,\n                fromLength: prevLength,\n                toLength: this.currentLength,\n                fromStartIndices: prevStartIndices,\n                getData: transitionSettings.enter\n            });\n        }\n        buffers[2] = matchBuffer({\n            device: this.device,\n            source: buffers[0],\n            target: buffers[2]\n        });\n        this.setBuffer(buffers[1]);\n        const { model } = this.transform;\n        model.setVertexCount(Math.floor(this.currentLength / attribute.size));\n        if (attribute.isConstant) {\n            model.setConstantAttributes({ aTo: attribute.value });\n        }\n        else {\n            model.setAttributes({ aTo: attribute.getBuffer() });\n        }\n    }\n    onUpdate() {\n        const { buffers, transform, framebuffer, transition } = this;\n        const settings = this.settings;\n        transform.model.setAttributes({\n            aPrev: buffers[0],\n            aCur: buffers[1]\n        });\n        transform.transformFeedback.setBuffers({ vNext: buffers[2] });\n        transform.model.setUniforms({\n            stiffness: settings.stiffness,\n            damping: settings.damping\n        });\n        transform.run({\n            framebuffer,\n            discard: false,\n            parameters: { viewport: [0, 0, 1, 1] },\n            clearColor: [0, 0, 0, 0]\n        });\n        cycleBuffers(buffers);\n        this.setBuffer(buffers[1]);\n        const isTransitioning = this.device.readPixelsToArrayWebGL(framebuffer)[0] > 0;\n        if (!isTransitioning) {\n            transition.end();\n        }\n    }\n    delete() {\n        super.delete();\n        this.transform.destroy();\n        this.texture.destroy();\n        this.framebuffer.destroy();\n    }\n}\nconst vs = `\\\n#version 300 es\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nin ATTRIBUTE_TYPE aPrev;\nin ATTRIBUTE_TYPE aCur;\nin ATTRIBUTE_TYPE aTo;\nout ATTRIBUTE_TYPE vNext;\nout float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n`;\nconst fs = `\\\n#version 300 es\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nin float vIsTransitioningFlag;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  fragColor = vec4(1.0);\n}`;\nfunction getTransform(device, attribute) {\n    const attributeType = getAttributeTypeFromSize(attribute.size);\n    const format = getFloat32VertexFormat(attribute.size);\n    return new BufferTransform(device, {\n        vs,\n        fs,\n        bufferLayout: [\n            { name: 'aPrev', format },\n            { name: 'aCur', format },\n            { name: 'aTo', format: attribute.getBufferLayout().attributes[0].format }\n        ],\n        varyings: ['vNext'],\n        defines: { ATTRIBUTE_TYPE: attributeType },\n        parameters: {\n            depthCompare: 'always',\n            blendColorOperation: 'max',\n            blendColorSrcFactor: 'one',\n            blendColorDstFactor: 'one',\n            blendAlphaOperation: 'max',\n            blendAlphaSrcFactor: 'one',\n            blendAlphaDstFactor: 'one'\n        }\n    });\n}\nfunction getTexture(device) {\n    return device.createTexture({\n        data: new Uint8Array(4),\n        format: 'rgba8unorm',\n        mipmaps: false,\n        // dataFormat: GL.RGBA,\n        width: 1,\n        height: 1\n    });\n}\nfunction getFramebuffer(device, texture) {\n    return device.createFramebuffer({\n        id: 'spring-transition-is-transitioning-framebuffer',\n        width: 1,\n        height: 1,\n        colorAttachments: [texture]\n    });\n}\n","// deck.gl, MIT license\nimport GPUInterpolationTransition from \"../../transitions/gpu-interpolation-transition.js\";\nimport GPUSpringTransition from \"../../transitions/gpu-spring-transition.js\";\nimport log from \"../../utils/log.js\";\nconst TRANSITION_TYPES = {\n    interpolation: GPUInterpolationTransition,\n    spring: GPUSpringTransition\n};\nexport default class AttributeTransitionManager {\n    constructor(device, { id, timeline }) {\n        if (!device)\n            throw new Error('AttributeTransitionManager is constructed without device');\n        this.id = id;\n        this.device = device;\n        this.timeline = timeline;\n        this.transitions = {};\n        this.needsRedraw = false;\n        this.numInstances = 1;\n    }\n    finalize() {\n        for (const attributeName in this.transitions) {\n            this._removeTransition(attributeName);\n        }\n    }\n    /* Public methods */\n    // Called when attribute manager updates\n    // Check the latest attributes for updates.\n    update({ attributes, transitions, numInstances }) {\n        // Transform class will crash if elementCount is 0\n        this.numInstances = numInstances || 1;\n        for (const attributeName in attributes) {\n            const attribute = attributes[attributeName];\n            const settings = attribute.getTransitionSetting(transitions);\n            // this attribute might not support transitions?\n            if (!settings)\n                continue; // eslint-disable-line no-continue\n            this._updateAttribute(attributeName, attribute, settings);\n        }\n        for (const attributeName in this.transitions) {\n            const attribute = attributes[attributeName];\n            if (!attribute || !attribute.getTransitionSetting(transitions)) {\n                // Animated attribute has been removed\n                this._removeTransition(attributeName);\n            }\n        }\n    }\n    // Returns `true` if attribute is transition-enabled\n    hasAttribute(attributeName) {\n        const transition = this.transitions[attributeName];\n        return transition && transition.inProgress;\n    }\n    // Get all the animated attributes\n    getAttributes() {\n        const animatedAttributes = {};\n        for (const attributeName in this.transitions) {\n            const transition = this.transitions[attributeName];\n            if (transition.inProgress) {\n                animatedAttributes[attributeName] = transition.attributeInTransition;\n            }\n        }\n        return animatedAttributes;\n    }\n    /* eslint-disable max-statements */\n    // Called every render cycle, run transform feedback\n    // Returns `true` if anything changes\n    run() {\n        if (this.numInstances === 0) {\n            return false;\n        }\n        for (const attributeName in this.transitions) {\n            const updated = this.transitions[attributeName].update();\n            if (updated) {\n                this.needsRedraw = true;\n            }\n        }\n        const needsRedraw = this.needsRedraw;\n        this.needsRedraw = false;\n        return needsRedraw;\n    }\n    /* eslint-enable max-statements */\n    /* Private methods */\n    _removeTransition(attributeName) {\n        this.transitions[attributeName].delete();\n        delete this.transitions[attributeName];\n    }\n    // Check an attributes for updates\n    // Returns a transition object if a new transition is triggered.\n    _updateAttribute(attributeName, attribute, settings) {\n        const transition = this.transitions[attributeName];\n        // an attribute can change transition type when it updates\n        // let's remove the transition when that happens so we can create the new transition type\n        // TODO: when switching transition types, make sure to carry over the attribute's\n        // previous buffers, currentLength, startIndices, etc, to be used as the starting point\n        // for the next transition\n        let isNew = !transition || transition.type !== settings.type;\n        if (isNew) {\n            if (transition) {\n                this._removeTransition(attributeName);\n            }\n            const TransitionType = TRANSITION_TYPES[settings.type];\n            if (TransitionType) {\n                this.transitions[attributeName] = new TransitionType({\n                    attribute,\n                    timeline: this.timeline,\n                    device: this.device\n                });\n            }\n            else {\n                log.error(`unsupported transition type '${settings.type}'`)();\n                isNew = false;\n            }\n        }\n        if (isNew || attribute.needsRedraw()) {\n            this.needsRedraw = true;\n            this.transitions[attributeName].start(settings, this.numInstances);\n        }\n    }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable guard-for-in */\nimport Attribute from \"./attribute.js\";\nimport log from \"../../utils/log.js\";\nimport memoize from \"../../utils/memoize.js\";\nimport { mergeBounds } from \"../../utils/math-utils.js\";\nimport debug from \"../../debug/index.js\";\nimport AttributeTransitionManager from \"./attribute-transition-manager.js\";\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\nexport default class AttributeManager {\n    constructor(device, { id = 'attribute-manager', stats, timeline } = {}) {\n        this.mergeBoundsMemoized = memoize(mergeBounds);\n        this.id = id;\n        this.device = device;\n        this.attributes = {};\n        this.updateTriggers = {};\n        this.needsRedraw = true;\n        this.userData = {};\n        this.stats = stats;\n        this.attributeTransitionManager = new AttributeTransitionManager(device, {\n            id: `${id}-transitions`,\n            timeline\n        });\n        // For debugging sanity, prevent uninitialized members\n        Object.seal(this);\n    }\n    finalize() {\n        for (const attributeName in this.attributes) {\n            this.attributes[attributeName].delete();\n        }\n        this.attributeTransitionManager.finalize();\n    }\n    // Returns the redraw flag, optionally clearing it.\n    // Redraw flag will be set if any attributes attributes changed since\n    // flag was last cleared.\n    //\n    // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n    // @return {false|String} - reason a redraw is needed.\n    getNeedsRedraw(opts = { clearRedrawFlags: false }) {\n        const redraw = this.needsRedraw;\n        this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n        return redraw && this.id;\n    }\n    // Sets the redraw flag.\n    // @param {Boolean} redraw=true\n    setNeedsRedraw() {\n        this.needsRedraw = true;\n    }\n    // Adds attributes\n    add(attributes) {\n        this._add(attributes);\n    }\n    // Adds attributes\n    addInstanced(attributes) {\n        this._add(attributes, { stepMode: 'instance' });\n    }\n    /**\n     * Removes attributes\n     * Takes an array of attribute names and delete them from\n     * the attribute map if they exists\n     *\n     * @example\n     * attributeManager.remove(['position']);\n     *\n     * @param {Object} attributeNameArray - attribute name array (see above)\n     */\n    remove(attributeNameArray) {\n        for (const name of attributeNameArray) {\n            if (this.attributes[name] !== undefined) {\n                this.attributes[name].delete();\n                delete this.attributes[name];\n            }\n        }\n    }\n    // Marks an attribute for update\n    invalidate(triggerName, dataRange) {\n        const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n        // For performance tuning\n        debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n    }\n    invalidateAll(dataRange) {\n        for (const attributeName in this.attributes) {\n            this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n        }\n        // For performance tuning\n        debug(TRACE_INVALIDATE, this, 'all');\n    }\n    // Ensure all attribute buffers are updated from props or data.\n    // eslint-disable-next-line complexity\n    update({ data, numInstances, startIndices = null, transitions, props = {}, buffers = {}, context = {} }) {\n        // keep track of whether some attributes are updated\n        let updated = false;\n        debug(TRACE_UPDATE_START, this);\n        if (this.stats) {\n            this.stats.get('Update Attributes').timeStart();\n        }\n        for (const attributeName in this.attributes) {\n            const attribute = this.attributes[attributeName];\n            const accessorName = attribute.settings.accessor;\n            attribute.startIndices = startIndices;\n            attribute.numInstances = numInstances;\n            if (props[attributeName]) {\n                log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n            }\n            if (attribute.setExternalBuffer(buffers[attributeName])) {\n                // Step 1: try update attribute directly from external buffers\n            }\n            else if (attribute.setBinaryValue(typeof accessorName === 'string' ? buffers[accessorName] : undefined, data.startIndices)) {\n                // Step 2: try set packed value from external typed array\n            }\n            else if (typeof accessorName === 'string' &&\n                !buffers[accessorName] &&\n                attribute.setConstantValue(props[accessorName])) {\n                // Step 3: try set constant value from props\n                // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n                // This may happen when setBinaryValue falls through to use the auto updater\n            }\n            else if (attribute.needsUpdate()) {\n                // Step 4: update via updater callback\n                updated = true;\n                this._updateAttribute({\n                    attribute,\n                    numInstances,\n                    data,\n                    props,\n                    context\n                });\n            }\n            this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n        }\n        if (updated) {\n            // Only initiate alloc/update (and logging) if actually needed\n            debug(TRACE_UPDATE_END, this, numInstances);\n        }\n        if (this.stats) {\n            this.stats.get('Update Attributes').timeEnd();\n        }\n        this.attributeTransitionManager.update({\n            attributes: this.attributes,\n            numInstances,\n            transitions\n        });\n    }\n    // Update attribute transition to the current timestamp\n    // Returns `true` if any transition is in progress\n    updateTransition() {\n        const { attributeTransitionManager } = this;\n        const transitionUpdated = attributeTransitionManager.run();\n        this.needsRedraw = this.needsRedraw || transitionUpdated;\n        return transitionUpdated;\n    }\n    /**\n     * Returns all attribute descriptors\n     * Note: Format matches luma.gl Model/Program.setAttributes()\n     * @return {Object} attributes - descriptors\n     */\n    getAttributes() {\n        return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };\n    }\n    /**\n     * Computes the spatial bounds of a given set of attributes\n     */\n    getBounds(attributeNames) {\n        const bounds = attributeNames.map(attributeName => this.attributes[attributeName]?.getBounds());\n        return this.mergeBoundsMemoized(bounds);\n    }\n    /**\n     * Returns changed attribute descriptors\n     * This indicates which WebGLBuffers need to be updated\n     * @return {Object} attributes - descriptors\n     */\n    getChangedAttributes(opts = { clearChangedFlags: false }) {\n        const { attributes, attributeTransitionManager } = this;\n        const changedAttributes = { ...attributeTransitionManager.getAttributes() };\n        for (const attributeName in attributes) {\n            const attribute = attributes[attributeName];\n            if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n                changedAttributes[attributeName] = attribute;\n            }\n        }\n        return changedAttributes;\n    }\n    /** Generate WebGPU-style buffer layout descriptors from all attributes */\n    getBufferLayouts(\n    /** A luma.gl Model-shaped object that supplies additional hint to attribute resolution */\n    modelInfo) {\n        return Object.values(this.getAttributes()).map(attribute => attribute.getBufferLayout(modelInfo));\n    }\n    // PRIVATE METHODS\n    /** Register new attributes */\n    _add(\n    /** A map from attribute name to attribute descriptors */\n    attributes, \n    /** Additional attribute settings to pass to all attributes */\n    overrideOptions) {\n        for (const attributeName in attributes) {\n            const attribute = attributes[attributeName];\n            const props = {\n                ...attribute,\n                id: attributeName,\n                size: (attribute.isIndexed && 1) || attribute.size || 1,\n                ...overrideOptions\n            };\n            // Initialize the attribute descriptor, with WebGL and metadata fields\n            this.attributes[attributeName] = new Attribute(this.device, props);\n        }\n        this._mapUpdateTriggersToAttributes();\n    }\n    // build updateTrigger name to attribute name mapping\n    _mapUpdateTriggersToAttributes() {\n        const triggers = {};\n        for (const attributeName in this.attributes) {\n            const attribute = this.attributes[attributeName];\n            attribute.getUpdateTriggers().forEach(triggerName => {\n                if (!triggers[triggerName]) {\n                    triggers[triggerName] = [];\n                }\n                triggers[triggerName].push(attributeName);\n            });\n        }\n        this.updateTriggers = triggers;\n    }\n    _invalidateTrigger(triggerName, dataRange) {\n        const { attributes, updateTriggers } = this;\n        const invalidatedAttributes = updateTriggers[triggerName];\n        if (invalidatedAttributes) {\n            invalidatedAttributes.forEach(name => {\n                const attribute = attributes[name];\n                if (attribute) {\n                    attribute.setNeedsUpdate(attribute.id, dataRange);\n                }\n            });\n        }\n        return invalidatedAttributes;\n    }\n    _updateAttribute(opts) {\n        const { attribute, numInstances } = opts;\n        debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n        if (attribute.constant) {\n            // The attribute is flagged as constant outside of an update cycle\n            // Skip allocation and updater call\n            // @ts-ignore value can be set to an array by user but always cast to typed array during attribute update\n            attribute.setConstantValue(attribute.value);\n            return;\n        }\n        if (attribute.allocate(numInstances)) {\n            debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n        }\n        // Calls update on any buffers that need update\n        const updated = attribute.updateBuffer(opts);\n        if (updated) {\n            this.needsRedraw = true;\n            debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n        }\n    }\n}\n","import { lerp } from '@math.gl/core';\nimport Transition from \"./transition.js\";\nexport default class CPUInterpolationTransition extends Transition {\n    get value() {\n        return this._value;\n    }\n    _onUpdate() {\n        const { time, settings: { fromValue, toValue, duration, easing } } = this;\n        const t = easing(time / duration);\n        this._value = lerp(fromValue, toValue, t);\n    }\n}\n","import Transition from \"./transition.js\";\nconst EPSILON = 1e-5;\n/*\n * Calculate the next value in the spring transition\n * @param prev {Number} - previous value\n * @param cur {Number} - current value\n * @param dest {Number} - destination value\n * @param damping {Number}\n * @param stiffness {Number}\n */\nfunction updateSpringElement(prev, cur, dest, damping, stiffness) {\n    const velocity = cur - prev;\n    const delta = dest - cur;\n    const spring = delta * stiffness;\n    const damper = -velocity * damping;\n    return spring + damper + velocity + cur;\n}\nfunction updateSpring(prev, cur, dest, damping, stiffness) {\n    if (Array.isArray(dest)) {\n        const next = [];\n        for (let i = 0; i < dest.length; i++) {\n            next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);\n        }\n        return next;\n    }\n    return updateSpringElement(prev, cur, dest, damping, stiffness);\n}\n/*\n * Calculate the distance between two numbers or two vectors\n */\nfunction distance(value1, value2) {\n    if (Array.isArray(value1)) {\n        let distanceSquare = 0;\n        for (let i = 0; i < value1.length; i++) {\n            const d = value1[i] - value2[i];\n            distanceSquare += d * d;\n        }\n        return Math.sqrt(distanceSquare);\n    }\n    return Math.abs(value1 - value2);\n}\nexport default class CPUSpringTransition extends Transition {\n    get value() {\n        return this._currValue;\n    }\n    _onUpdate() {\n        // TODO - use timeline\n        // const {time} = this;\n        const { fromValue, toValue, damping, stiffness } = this.settings;\n        const { _prevValue = fromValue, _currValue = fromValue } = this;\n        let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);\n        const delta = distance(nextValue, toValue);\n        const velocity = distance(nextValue, _currValue);\n        if (delta < EPSILON && velocity < EPSILON) {\n            nextValue = toValue;\n            this.end();\n        }\n        this._prevValue = _currValue;\n        this._currValue = nextValue;\n    }\n}\n","import { normalizeTransitionSettings } from \"./attribute/transition-settings.js\";\nimport CPUInterpolationTransition from \"../transitions/cpu-interpolation-transition.js\";\nimport CPUSpringTransition from \"../transitions/cpu-spring-transition.js\";\nimport log from \"../utils/log.js\";\nconst TRANSITION_TYPES = {\n    interpolation: CPUInterpolationTransition,\n    spring: CPUSpringTransition\n};\nexport default class UniformTransitionManager {\n    constructor(timeline) {\n        this.transitions = new Map();\n        this.timeline = timeline;\n    }\n    get active() {\n        return this.transitions.size > 0;\n    }\n    add(key, fromValue, toValue, settings) {\n        const { transitions } = this;\n        if (transitions.has(key)) {\n            const transition = transitions.get(key);\n            // value may not be available if `update()` has not been called. Fallback to `fromValue`\n            const { value = transition.settings.fromValue } = transition;\n            // start from interrupted position\n            fromValue = value;\n            this.remove(key);\n        }\n        settings = normalizeTransitionSettings(settings);\n        if (!settings) {\n            return;\n        }\n        const TransitionType = TRANSITION_TYPES[settings.type];\n        if (!TransitionType) {\n            log.error(`unsupported transition type '${settings.type}'`)();\n            return;\n        }\n        const transition = new TransitionType(this.timeline);\n        transition.start({\n            ...settings,\n            fromValue,\n            toValue\n        });\n        transitions.set(key, transition);\n    }\n    remove(key) {\n        const { transitions } = this;\n        if (transitions.has(key)) {\n            transitions.get(key).cancel();\n            transitions.delete(key);\n        }\n    }\n    update() {\n        const propsInTransition = {};\n        for (const [key, transition] of this.transitions) {\n            transition.update();\n            propsInTransition[key] = transition.value;\n            if (!transition.inProgress) {\n                // transition ended\n                this.remove(key);\n            }\n        }\n        return propsInTransition;\n    }\n    clear() {\n        for (const key of this.transitions.keys()) {\n            this.remove(key);\n        }\n    }\n}\n","import { PROP_TYPES_SYMBOL } from \"./constants.js\";\nexport function validateProps(props) {\n    const propTypes = props[PROP_TYPES_SYMBOL];\n    for (const propName in propTypes) {\n        const propType = propTypes[propName];\n        const { validate } = propType;\n        if (validate && !validate(props[propName], propType)) {\n            throw new Error(`Invalid prop ${propName}: ${props[propName]}`);\n        }\n    }\n}\n// Returns an object with \"change flags\", either false or strings indicating reason for change\nexport function diffProps(props, oldProps) {\n    // First check if any props have changed (ignore props that will be examined separately)\n    const propsChangedReason = compareProps({\n        newProps: props,\n        oldProps,\n        propTypes: props[PROP_TYPES_SYMBOL],\n        ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }\n    });\n    // Now check if any data related props have changed\n    const dataChangedReason = diffDataProps(props, oldProps);\n    // Check update triggers to determine if any attributes need regeneration\n    // Note - if data has changed, all attributes will need regeneration, so skip this step\n    let updateTriggersChangedReason = false;\n    if (!dataChangedReason) {\n        updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);\n    }\n    return {\n        dataChanged: dataChangedReason,\n        propsChanged: propsChangedReason,\n        updateTriggersChanged: updateTriggersChangedReason,\n        extensionsChanged: diffExtensions(props, oldProps),\n        transitionsChanged: diffTransitions(props, oldProps)\n    };\n}\nfunction diffTransitions(props, oldProps) {\n    if (!props.transitions) {\n        return false;\n    }\n    const result = {};\n    const propTypes = props[PROP_TYPES_SYMBOL];\n    let changed = false;\n    for (const key in props.transitions) {\n        const propType = propTypes[key];\n        const type = propType && propType.type;\n        const isTransitionable = type === 'number' || type === 'color' || type === 'array';\n        if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {\n            result[key] = true;\n            changed = true;\n        }\n    }\n    return changed ? result : false;\n}\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * @param {Object} opt.oldProps - object with old key/value pairs\n * @param {Object} opt.newProps - object with new key/value pairs\n * @param {Object} opt.ignoreProps={} - object, keys that should not be compared\n * @returns {null|String} - null when values of all keys are strictly equal.\n *   if unequal, returns a string explaining what changed.\n */\n/* eslint-disable max-statements, max-depth, complexity */\n/*\n * Note: for better performance, this function assumes that both oldProps and newProps\n   inherit the same prototype (defaultProps). That is, if neither object contains own\n   property <key>, assume `oldProps.<key>` and `newProps.<key>` are equal.\n */\nexport function compareProps({ newProps, oldProps, ignoreProps = {}, propTypes = {}, triggerName = 'props' }) {\n    // shallow equality => deep equality\n    if (oldProps === newProps) {\n        return false;\n    }\n    // TODO - do we need these checks? Should never happen...\n    if (typeof newProps !== 'object' || newProps === null) {\n        return `${triggerName} changed shallowly`;\n    }\n    if (typeof oldProps !== 'object' || oldProps === null) {\n        return `${triggerName} changed shallowly`;\n    }\n    // Compare explicitly defined new props against old/default values\n    for (const key of Object.keys(newProps)) {\n        if (!(key in ignoreProps)) {\n            if (!(key in oldProps)) {\n                return `${triggerName}.${key} added`;\n            }\n            const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);\n            if (changed) {\n                return `${triggerName}.${key} ${changed}`;\n            }\n        }\n    }\n    // Test if any old props have been dropped\n    for (const key of Object.keys(oldProps)) {\n        if (!(key in ignoreProps)) {\n            if (!(key in newProps)) {\n                return `${triggerName}.${key} dropped`;\n            }\n            if (!Object.hasOwnProperty.call(newProps, key)) {\n                // Compare dropped old prop against default value\n                const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);\n                if (changed) {\n                    return `${triggerName}.${key} ${changed}`;\n                }\n            }\n        }\n    }\n    return false;\n}\n/* eslint-enable max-statements, max-depth, complexity */\n// HELPERS\nfunction comparePropValues(newProp, oldProp, propType) {\n    // If prop type has an equal function, invoke it\n    let equal = propType && propType.equal;\n    if (equal && !equal(newProp, oldProp, propType)) {\n        return 'changed deeply';\n    }\n    if (!equal) {\n        // If object has an equals function, invoke it\n        equal = newProp && oldProp && newProp.equals;\n        if (equal && !equal.call(newProp, oldProp)) {\n            return 'changed deeply';\n        }\n    }\n    if (!equal && oldProp !== newProp) {\n        return 'changed shallowly';\n    }\n    return null;\n}\n// The comparison of the data prop requires special handling\n// the dataComparator should be used if supplied\nfunction diffDataProps(props, oldProps) {\n    if (oldProps === null) {\n        return 'oldProps is null, initial diff';\n    }\n    let dataChanged = false;\n    // Support optional app defined comparison of data\n    const { dataComparator, _dataDiff } = props;\n    if (dataComparator) {\n        if (!dataComparator(props.data, oldProps.data)) {\n            dataChanged = 'Data comparator detected a change';\n        }\n        // Otherwise, do a shallow equal on props\n    }\n    else if (props.data !== oldProps.data) {\n        dataChanged = 'A new data container was supplied';\n    }\n    if (dataChanged && _dataDiff) {\n        dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;\n    }\n    return dataChanged;\n}\n// Checks if any update triggers have changed\n// also calls callback to invalidate attributes accordingly.\nfunction diffUpdateTriggers(props, oldProps) {\n    if (oldProps === null) {\n        return { all: true };\n    }\n    // If the 'all' updateTrigger fires, ignore testing others\n    if ('all' in props.updateTriggers) {\n        const diffReason = diffUpdateTrigger(props, oldProps, 'all');\n        if (diffReason) {\n            return { all: true };\n        }\n    }\n    const reason = {};\n    let changed = false;\n    // If the 'all' updateTrigger didn't fire, need to check all others\n    for (const triggerName in props.updateTriggers) {\n        if (triggerName !== 'all') {\n            const diffReason = diffUpdateTrigger(props, oldProps, triggerName);\n            if (diffReason) {\n                reason[triggerName] = true;\n                changed = true;\n            }\n        }\n    }\n    return changed ? reason : false;\n}\n// Returns true if any extensions have changed\nfunction diffExtensions(props, oldProps) {\n    if (oldProps === null) {\n        return true;\n    }\n    const oldExtensions = oldProps.extensions;\n    const { extensions } = props;\n    if (extensions === oldExtensions) {\n        return false;\n    }\n    if (!oldExtensions || !extensions) {\n        return true;\n    }\n    if (extensions.length !== oldExtensions.length) {\n        return true;\n    }\n    for (let i = 0; i < extensions.length; i++) {\n        if (!extensions[i].equals(oldExtensions[i])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction diffUpdateTrigger(props, oldProps, triggerName) {\n    let newTriggers = props.updateTriggers[triggerName];\n    newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;\n    let oldTriggers = oldProps.updateTriggers[triggerName];\n    oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;\n    const diffReason = compareProps({\n        oldProps: oldTriggers,\n        newProps: newTriggers,\n        triggerName\n    });\n    return diffReason;\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nconst ERR_NOT_OBJECT = 'count(): argument not an object';\nconst ERR_NOT_CONTAINER = 'count(): argument not a container';\n/**\n * Deduces numer of elements in a JavaScript container.\n * - Auto-deduction for ES6 containers that define a count() method\n * - Auto-deduction for ES6 containers that define a size member\n * - Auto-deduction for Classic Arrays via the built-in length attribute\n * - Also handles objects, although note that this an O(N) operation\n */\nexport function count(container) {\n    if (!isObject(container)) {\n        throw new Error(ERR_NOT_OBJECT);\n    }\n    // Check if ES6 collection \"count\" function is available\n    if (typeof container.count === 'function') {\n        return container.count();\n    }\n    // Check if ES6 collection \"size\" attribute is set\n    if (Number.isFinite(container.size)) {\n        return container.size;\n    }\n    // Check if array length attribute is set\n    // Note: checking this last since some ES6 collections (Immutable.js)\n    // emit profuse warnings when trying to access `length` attribute\n    if (Number.isFinite(container.length)) {\n        return container.length;\n    }\n    // Note that getting the count of an object is O(N)\n    if (isPlainObject(container)) {\n        return Object.keys(container).length;\n    }\n    throw new Error(ERR_NOT_CONTAINER);\n}\n/**\n * Checks if argument is a plain object (not a class or array etc)\n * @param {*} value - JavaScript value to be tested\n * @return {Boolean} - true if argument is a plain JavaScript object\n */\nfunction isPlainObject(value) {\n    return value !== null && typeof value === 'object' && value.constructor === Object;\n}\n/**\n * Checks if argument is an indexable object (not a primitive value, nor null)\n * @param {*} value - JavaScript value to be tested\n * @return {Boolean} - true if argument is a JavaScript object\n */\nfunction isObject(value) {\n    return value !== null && typeof value === 'object';\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// Merge two luma.gl shader descriptors\nexport function mergeShaders(target, source) {\n    if (!source) {\n        return target;\n    }\n    const result = { ...target, ...source };\n    if ('defines' in source) {\n        result.defines = { ...target.defines, ...source.defines };\n    }\n    if ('modules' in source) {\n        result.modules = (target.modules || []).concat(source.modules);\n        // Hack: prject32 and project64 cannot co-exist\n        if (source.modules.some(module => module.name === 'project64')) {\n            const index = result.modules.findIndex(module => module.name === 'project32');\n            if (index >= 0) {\n                result.modules.splice(index, 1);\n            }\n        }\n    }\n    if ('inject' in source) {\n        if (!target.inject) {\n            result.inject = source.inject;\n        }\n        else {\n            const mergedInjection = { ...target.inject };\n            for (const key in source.inject) {\n                mergedInjection[key] = (mergedInjection[key] || '') + source.inject[key];\n            }\n            result.inject = mergedInjection;\n        }\n    }\n    return result;\n}\n","/**\n * Projection utils\n * TODO: move to Viewport class?\n */\nimport { COORDINATE_SYSTEM } from \"../../lib/constants.js\";\nimport { getOffsetOrigin } from \"./viewport-uniforms.js\";\nimport WebMercatorViewport from \"../../viewports/web-mercator-viewport.js\";\nimport { vec3, vec4 } from '@math.gl/core';\nimport { addMetersToLngLat } from '@math.gl/web-mercator';\nconst DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];\n// In project.glsl, offset modes calculate z differently from LNG_LAT mode.\n// offset modes apply the y adjustment (unitsPerMeter2) when projecting z\n// LNG_LAT mode only use the linear scale.\nfunction lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {\n    const p = viewport.projectPosition(lngLatZ);\n    // TODO - avoid using instanceof\n    if (offsetMode && viewport instanceof WebMercatorViewport) {\n        const [longitude, latitude, z = 0] = lngLatZ;\n        const distanceScales = viewport.getDistanceScales([longitude, latitude]);\n        p[2] = z * distanceScales.unitsPerMeter[2];\n    }\n    return p;\n}\nfunction normalizeParameters(opts) {\n    const { viewport, modelMatrix, coordinateOrigin } = opts;\n    let { coordinateSystem, fromCoordinateSystem, fromCoordinateOrigin } = opts;\n    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n        coordinateSystem = viewport.isGeospatial\n            ? COORDINATE_SYSTEM.LNGLAT\n            : COORDINATE_SYSTEM.CARTESIAN;\n    }\n    if (fromCoordinateSystem === undefined) {\n        fromCoordinateSystem = coordinateSystem;\n    }\n    if (fromCoordinateOrigin === undefined) {\n        fromCoordinateOrigin = coordinateOrigin;\n    }\n    return {\n        viewport,\n        coordinateSystem,\n        coordinateOrigin,\n        modelMatrix,\n        fromCoordinateSystem,\n        fromCoordinateOrigin\n    };\n}\n/** Get the common space position from world coordinates in the given coordinate system */\nexport function getWorldPosition(position, { viewport, modelMatrix, coordinateSystem, coordinateOrigin, offsetMode }) {\n    let [x, y, z = 0] = position;\n    if (modelMatrix) {\n        [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n    }\n    switch (coordinateSystem) {\n        case COORDINATE_SYSTEM.LNGLAT:\n            return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n        case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n            return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);\n        case COORDINATE_SYSTEM.METER_OFFSETS:\n            return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport, offsetMode);\n        case COORDINATE_SYSTEM.CARTESIAN:\n        default:\n            return viewport.isGeospatial\n                ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]]\n                : viewport.projectPosition([x, y, z]);\n    }\n}\n/**\n * Equivalent to project_position in project.glsl\n * projects a user supplied position to world position directly with or without\n * a reference coordinate system\n */\nexport function projectPosition(position, params) {\n    const { viewport, coordinateSystem, coordinateOrigin, modelMatrix, fromCoordinateSystem, fromCoordinateOrigin } = normalizeParameters(params);\n    const { autoOffset = true } = params;\n    const { geospatialOrigin = DEFAULT_COORDINATE_ORIGIN, shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN, offsetMode = false } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};\n    const worldPosition = getWorldPosition(position, {\n        viewport,\n        modelMatrix,\n        coordinateSystem: fromCoordinateSystem,\n        coordinateOrigin: fromCoordinateOrigin,\n        offsetMode\n    });\n    if (offsetMode) {\n        const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n        vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n    }\n    return worldPosition;\n}\n","import { Texture } from '@luma.gl/core';\nconst DEFAULT_TEXTURE_PARAMETERS = {\n    minFilter: 'linear',\n    mipmapFilter: 'linear',\n    magFilter: 'linear',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge'\n};\n// Track the textures that are created by us. They need to be released when they are no longer used.\nconst internalTextures = {};\n/**\n *\n * @param owner\n * @param device\n * @param image could be one of:\n *   - Texture\n *   - Browser object: Image, ImageData, ImageData, HTMLCanvasElement, HTMLVideoElement, ImageBitmap\n *   - Plain object: {width: <number>, height: <number>, data: <Uint8Array>}\n * @param parameters\n * @returns\n */\nexport function createTexture(owner, device, image, sampler) {\n    if (image instanceof Texture) {\n        // @ts-expect-error This type error seems like it shouldn't happen...\n        return image;\n    }\n    else if (image.constructor && image.constructor.name !== 'Object') {\n        // Browser object\n        image = { data: image };\n    }\n    let samplerParameters = null;\n    if (image.compressed) {\n        samplerParameters = {\n            minFilter: 'linear',\n            mipmapFilter: image.data.length > 1 ? 'nearest' : 'linear'\n        };\n    }\n    const texture = device.createTexture({\n        ...image,\n        sampler: {\n            ...DEFAULT_TEXTURE_PARAMETERS,\n            ...samplerParameters,\n            ...sampler\n        }\n    });\n    // Track this texture\n    internalTextures[texture.id] = owner;\n    return texture;\n}\nexport function destroyTexture(owner, texture) {\n    if (!texture || !(texture instanceof Texture)) {\n        return;\n    }\n    // Only delete the texture if requested by the same layer that created it\n    if (internalTextures[texture.id] === owner) {\n        texture.delete();\n        delete internalTextures[texture.id];\n    }\n}\n","import { createTexture, destroyTexture } from \"../utils/texture.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nconst TYPE_DEFINITIONS = {\n    boolean: {\n        validate(value, propType) {\n            return true;\n        },\n        equal(value1, value2, propType) {\n            return Boolean(value1) === Boolean(value2);\n        }\n    },\n    number: {\n        validate(value, propType) {\n            return (Number.isFinite(value) &&\n                (!('max' in propType) || value <= propType.max) &&\n                (!('min' in propType) || value >= propType.min));\n        }\n    },\n    color: {\n        validate(value, propType) {\n            return ((propType.optional && !value) ||\n                (isArray(value) && (value.length === 3 || value.length === 4)));\n        },\n        equal(value1, value2, propType) {\n            return deepEqual(value1, value2, 1);\n        }\n    },\n    accessor: {\n        validate(value, propType) {\n            const valueType = getTypeOf(value);\n            return valueType === 'function' || valueType === getTypeOf(propType.value);\n        },\n        equal(value1, value2, propType) {\n            if (typeof value2 === 'function') {\n                return true;\n            }\n            return deepEqual(value1, value2, 1);\n        }\n    },\n    array: {\n        validate(value, propType) {\n            return (propType.optional && !value) || isArray(value);\n        },\n        equal(value1, value2, propType) {\n            const { compare } = propType;\n            const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;\n            return compare ? deepEqual(value1, value2, depth) : value1 === value2;\n        }\n    },\n    object: {\n        equal(value1, value2, propType) {\n            if (propType.ignore) {\n                return true;\n            }\n            const { compare } = propType;\n            const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;\n            return compare ? deepEqual(value1, value2, depth) : value1 === value2;\n        }\n    },\n    function: {\n        validate(value, propType) {\n            return (propType.optional && !value) || typeof value === 'function';\n        },\n        equal(value1, value2, propType) {\n            // Backward compatibility - {compare: true} and {ignore: false} are equivalent\n            const shouldIgnore = !propType.compare && propType.ignore !== false;\n            return shouldIgnore || value1 === value2;\n        }\n    },\n    data: {\n        transform: (value, propType, component) => {\n            if (!value) {\n                return value;\n            }\n            const { dataTransform } = component.props;\n            if (dataTransform) {\n                return dataTransform(value);\n            }\n            // Detect loaders.gl v4 table format\n            if (typeof value.shape === 'string' &&\n                value.shape.endsWith('-table') &&\n                Array.isArray(value.data)) {\n                return value.data;\n            }\n            return value;\n        }\n    },\n    image: {\n        transform: (value, propType, component) => {\n            const context = component.context;\n            if (!context || !context.device) {\n                return null;\n            }\n            return createTexture(component.id, context.device, value, {\n                ...propType.parameters,\n                ...component.props.textureParameters\n            });\n        },\n        release: (value, propType, component) => {\n            destroyTexture(component.id, value);\n        }\n    }\n};\nexport function parsePropTypes(propDefs) {\n    const propTypes = {};\n    const defaultProps = {};\n    const deprecatedProps = {};\n    for (const [propName, propDef] of Object.entries(propDefs)) {\n        const deprecated = propDef?.deprecatedFor;\n        if (deprecated) {\n            deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];\n        }\n        else {\n            const propType = parsePropType(propName, propDef);\n            propTypes[propName] = propType;\n            defaultProps[propName] = propType.value;\n        }\n    }\n    return { propTypes, defaultProps, deprecatedProps };\n}\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(name, propDef) {\n    switch (getTypeOf(propDef)) {\n        case 'object':\n            return normalizePropDefinition(name, propDef);\n        case 'array':\n            return normalizePropDefinition(name, { type: 'array', value: propDef, compare: false });\n        case 'boolean':\n            return normalizePropDefinition(name, { type: 'boolean', value: propDef });\n        case 'number':\n            return normalizePropDefinition(name, { type: 'number', value: propDef });\n        case 'function':\n            // return guessFunctionType(name, propDef);\n            return normalizePropDefinition(name, { type: 'function', value: propDef, compare: true });\n        default:\n            return { name, type: 'unknown', value: propDef };\n    }\n}\nfunction normalizePropDefinition(name, propDef) {\n    if (!('type' in propDef)) {\n        if (!('value' in propDef)) {\n            // If no type and value this object is likely the value\n            return { name, type: 'object', value: propDef };\n        }\n        return { name, type: getTypeOf(propDef.value), ...propDef };\n    }\n    return { name, ...TYPE_DEFINITIONS[propDef.type], ...propDef };\n}\nfunction isArray(value) {\n    return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n    if (isArray(value)) {\n        return 'array';\n    }\n    if (value === null) {\n        return 'null';\n    }\n    return typeof value;\n}\n","import log from \"../utils/log.js\";\nimport { isAsyncIterable } from \"../utils/iterable-utils.js\";\nimport { parsePropTypes } from \"./prop-types.js\";\nimport { COMPONENT_SYMBOL, PROP_TYPES_SYMBOL, DEPRECATED_PROPS_SYMBOL, ASYNC_ORIGINAL_SYMBOL, ASYNC_RESOLVED_SYMBOL, ASYNC_DEFAULTS_SYMBOL } from \"./constants.js\";\nimport Component from \"./component.js\";\n// Create a property object\nexport function createProps(component, propObjects) {\n    // Resolve extension value\n    let extensions;\n    for (let i = propObjects.length - 1; i >= 0; i--) {\n        const props = propObjects[i];\n        if ('extensions' in props) {\n            // @ts-expect-error TS(2339) extensions not defined\n            extensions = props.extensions;\n        }\n    }\n    // Create a new prop object with empty default props object\n    const propsPrototype = getPropsPrototype(component.constructor, extensions);\n    // The true default props object will be found later\n    const propsInstance = Object.create(propsPrototype);\n    // Props need a back pointer to the owning component\n    propsInstance[COMPONENT_SYMBOL] = component;\n    // The supplied (original) values for those async props that are set to url strings or Promises.\n    // In this case, the actual (i.e. resolved) values are looked up from component.internalState\n    propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};\n    // Note: the actual (resolved) values for props that are NOT set to urls or Promises.\n    // in this case the values are served directly from this map\n    propsInstance[ASYNC_RESOLVED_SYMBOL] = {};\n    // \"Copy\" all sync props\n    for (let i = 0; i < propObjects.length; ++i) {\n        const props = propObjects[i];\n        // Do not use Object.assign here to avoid Symbols in props overwriting our private fields\n        // This might happen if one of the arguments is another props instance\n        for (const key in props) {\n            propsInstance[key] = props[key];\n        }\n    }\n    // Props must be immutable\n    Object.freeze(propsInstance);\n    return propsInstance;\n}\nconst MergedDefaultPropsCacheKey = '_mergedDefaultProps';\n// Return precalculated defaultProps and propType objects if available\n// build them if needed\nfunction getPropsPrototype(componentClass, extensions) {\n    // Bail out if we're not looking at a component - for two reasons:\n    // 1. There's no reason for an ancestor of component to have props\n    // 2. If we don't bail out, we'll follow the prototype chain all the way back to the global\n    // function prototype and add _mergedDefaultProps to it, which may break other frameworks\n    // (e.g. the react-three-fiber reconciler)\n    if (!(componentClass instanceof Component.constructor))\n        return {};\n    // A string that uniquely identifies the extensions involved\n    let cacheKey = MergedDefaultPropsCacheKey;\n    if (extensions) {\n        for (const extension of extensions) {\n            const ExtensionClass = extension.constructor;\n            if (ExtensionClass) {\n                cacheKey += `:${ExtensionClass.extensionName || ExtensionClass.name}`;\n            }\n        }\n    }\n    const defaultProps = getOwnProperty(componentClass, cacheKey);\n    if (!defaultProps) {\n        return (componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []));\n    }\n    return defaultProps;\n}\n// Build defaultProps and propType objects by walking component prototype chain\nfunction createPropsPrototypeAndTypes(componentClass, extensions) {\n    const parent = componentClass.prototype;\n    if (!parent) {\n        return null;\n    }\n    const parentClass = Object.getPrototypeOf(componentClass);\n    const parentDefaultProps = getPropsPrototype(parentClass);\n    // Parse propTypes from Component.defaultProps\n    const componentDefaultProps = getOwnProperty(componentClass, 'defaultProps') || {};\n    const componentPropDefs = parsePropTypes(componentDefaultProps);\n    // Merged default props object. Order: parent, self, extensions\n    const defaultProps = Object.assign(Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);\n    // Merged prop type definitions. Order: parent, self, extensions\n    const propTypes = Object.assign(Object.create(null), parentDefaultProps?.[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);\n    // Merged deprecation list. Order: parent, self, extensions\n    const deprecatedProps = Object.assign(Object.create(null), parentDefaultProps?.[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);\n    for (const extension of extensions) {\n        const extensionDefaultProps = getPropsPrototype(extension.constructor);\n        if (extensionDefaultProps) {\n            Object.assign(defaultProps, extensionDefaultProps);\n            Object.assign(propTypes, extensionDefaultProps[PROP_TYPES_SYMBOL]);\n            Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);\n        }\n    }\n    // Create any necessary property descriptors and create the default prop object\n    // Assign merged default props\n    createPropsPrototype(defaultProps, componentClass);\n    // Add getters/setters for async props\n    addAsyncPropsToPropPrototype(defaultProps, propTypes);\n    // Add setters for deprecated props\n    addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps);\n    // Store the precalculated props\n    defaultProps[PROP_TYPES_SYMBOL] = propTypes;\n    defaultProps[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;\n    // Backwards compatibility\n    // TODO: remove access of hidden property from the rest of the code base\n    if (extensions.length === 0 && !hasOwnProperty(componentClass, '_propTypes')) {\n        componentClass._propTypes = propTypes;\n    }\n    return defaultProps;\n}\n// Builds a pre-merged default props object that component props can inherit from\nfunction createPropsPrototype(defaultProps, componentClass) {\n    // Avoid freezing `id` prop\n    const id = getComponentName(componentClass);\n    Object.defineProperties(defaultProps, {\n        // `id` is treated specially because layer might need to override it\n        id: {\n            writable: true,\n            value: id\n        }\n    });\n}\nfunction addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps) {\n    for (const propName in deprecatedProps) {\n        /* eslint-disable accessor-pairs */\n        Object.defineProperty(defaultProps, propName, {\n            enumerable: false,\n            set(newValue) {\n                const nameStr = `${this.id}: ${propName}`;\n                for (const newPropName of deprecatedProps[propName]) {\n                    if (!hasOwnProperty(this, newPropName)) {\n                        this[newPropName] = newValue;\n                    }\n                }\n                log.deprecated(nameStr, deprecatedProps[propName].join('/'))();\n            }\n        });\n        /* eslint-enable accessor-pairs */\n    }\n}\n// Create descriptors for overridable props\nfunction addAsyncPropsToPropPrototype(defaultProps, propTypes) {\n    const defaultValues = {};\n    const descriptors = {};\n    // Move async props into shadow values\n    for (const propName in propTypes) {\n        const propType = propTypes[propName];\n        const { name, value } = propType;\n        // Note: async is ES7 keyword, can't destructure\n        if (propType.async) {\n            defaultValues[name] = value;\n            descriptors[name] = getDescriptorForAsyncProp(name);\n        }\n    }\n    // Default \"resolved\" values for async props, returned if value not yet resolved/set.\n    defaultProps[ASYNC_DEFAULTS_SYMBOL] = defaultValues;\n    // Shadowed object, just to make sure \"early indexing\" into the instance does not fail\n    defaultProps[ASYNC_ORIGINAL_SYMBOL] = {};\n    Object.defineProperties(defaultProps, descriptors);\n}\n// Helper: Configures getter and setter for one async prop\nfunction getDescriptorForAsyncProp(name) {\n    return {\n        enumerable: true,\n        // Save the provided value for async props in a special map\n        set(newValue) {\n            if (typeof newValue === 'string' ||\n                newValue instanceof Promise ||\n                isAsyncIterable(newValue)) {\n                this[ASYNC_ORIGINAL_SYMBOL][name] = newValue;\n            }\n            else {\n                this[ASYNC_RESOLVED_SYMBOL][name] = newValue;\n            }\n        },\n        // Only the component's state knows the true value of async prop\n        get() {\n            if (this[ASYNC_RESOLVED_SYMBOL]) {\n                // Prop value isn't async, so just return it\n                if (name in this[ASYNC_RESOLVED_SYMBOL]) {\n                    const value = this[ASYNC_RESOLVED_SYMBOL][name];\n                    return value || this[ASYNC_DEFAULTS_SYMBOL][name];\n                }\n                if (name in this[ASYNC_ORIGINAL_SYMBOL]) {\n                    // It's an async prop value: look into component state\n                    const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;\n                    if (state && state.hasAsyncProp(name)) {\n                        return state.getAsyncProp(name) || this[ASYNC_DEFAULTS_SYMBOL][name];\n                    }\n                }\n            }\n            // the prop is not supplied, or\n            // component not yet initialized/matched, return the component's default value for the prop\n            return this[ASYNC_DEFAULTS_SYMBOL][name];\n        }\n    };\n}\n// HELPER METHODS\nfunction hasOwnProperty(object, prop) {\n    return Object.prototype.hasOwnProperty.call(object, prop);\n}\n// Constructors have their super class constructors as prototypes\nfunction getOwnProperty(object, prop) {\n    return hasOwnProperty(object, prop) && object[prop];\n}\nfunction getComponentName(componentClass) {\n    const componentName = componentClass.componentName;\n    if (!componentName) {\n        log.warn(`${componentClass.name}.componentName not specified`)();\n    }\n    return componentName || componentClass.name;\n}\n","import { COMPONENT_SYMBOL, PROP_TYPES_SYMBOL, ASYNC_ORIGINAL_SYMBOL, ASYNC_RESOLVED_SYMBOL, ASYNC_DEFAULTS_SYMBOL } from \"./constants.js\";\nimport { createProps } from \"./create-props.js\";\nlet counter = 0;\nclass Component {\n    constructor(...propObjects) {\n        // Merge supplied props with default props and freeze them.\n        /* eslint-disable prefer-spread */\n        this.props = createProps(this, propObjects);\n        /* eslint-enable prefer-spread */\n        this.id = this.props.id; // The layer's id, used for matching with layers from last render cycle\n        this.count = counter++; // Keep track of how many layer instances you are generating\n    }\n    // clone this layer with modified props\n    clone(newProps) {\n        const { props } = this;\n        // Async props cannot be copied with Object.assign, copy them separately\n        const asyncProps = {};\n        // See async props definition in create-props.js\n        for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {\n            if (key in props[ASYNC_RESOLVED_SYMBOL]) {\n                asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];\n            }\n            else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {\n                asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];\n            }\n        }\n        // Some custom layer implementation may not support multiple arguments in the constructor\n        // @ts-ignore\n        return new this.constructor({ ...props, ...asyncProps, ...newProps });\n    }\n}\nComponent.componentName = 'Component';\nComponent.defaultProps = {};\nexport default Component;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { isAsyncIterable } from \"../utils/iterable-utils.js\";\nimport { COMPONENT_SYMBOL, PROP_TYPES_SYMBOL, ASYNC_ORIGINAL_SYMBOL, ASYNC_RESOLVED_SYMBOL, ASYNC_DEFAULTS_SYMBOL } from \"./constants.js\";\nconst EMPTY_PROPS = Object.freeze({});\nexport default class ComponentState {\n    constructor(component) {\n        this.component = component;\n        this.asyncProps = {}; // Prop values that the layer sees\n        this.onAsyncPropUpdated = () => { };\n        this.oldProps = null; // Last props before update\n        this.oldAsyncProps = null; // Last props before update, with async values copied.\n    }\n    finalize() {\n        for (const propName in this.asyncProps) {\n            const asyncProp = this.asyncProps[propName];\n            if (asyncProp && asyncProp.type && asyncProp.type.release) {\n                // Release any resources created by transforms\n                asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);\n            }\n        }\n        this.asyncProps = {};\n        this.component = null;\n        this.resetOldProps();\n    }\n    /* Layer-facing props API */\n    getOldProps() {\n        return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;\n    }\n    resetOldProps() {\n        this.oldAsyncProps = null;\n        this.oldProps = this.component ? this.component.props : null;\n    }\n    // Checks if a prop is overridden\n    hasAsyncProp(propName) {\n        return propName in this.asyncProps;\n    }\n    // Returns value of an overriden prop\n    getAsyncProp(propName) {\n        const asyncProp = this.asyncProps[propName];\n        return asyncProp && asyncProp.resolvedValue;\n    }\n    isAsyncPropLoading(propName) {\n        if (propName) {\n            const asyncProp = this.asyncProps[propName];\n            return Boolean(asyncProp &&\n                asyncProp.pendingLoadCount > 0 &&\n                asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);\n        }\n        for (const key in this.asyncProps) {\n            if (this.isAsyncPropLoading(key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // Without changing the original prop value, swap out the data resolution under the hood\n    reloadAsyncProp(propName, value) {\n        this._watchPromise(propName, Promise.resolve(value));\n    }\n    // Updates all async/overridden props (when new props come in)\n    // Checks if urls have changed, starts loading, or removes override\n    setAsyncProps(props) {\n        this.component = props[COMPONENT_SYMBOL] || this.component;\n        // NOTE: prop param and default values are only support for testing\n        const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};\n        const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;\n        const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};\n        // TODO - use async props from the layer's prop types\n        for (const propName in resolvedValues) {\n            const value = resolvedValues[propName];\n            this._createAsyncPropData(propName, defaultValues[propName]);\n            this._updateAsyncProp(propName, value);\n            // Use transformed value\n            resolvedValues[propName] = this.getAsyncProp(propName);\n        }\n        for (const propName in originalValues) {\n            const value = originalValues[propName];\n            // Makes sure a record exists for this prop\n            this._createAsyncPropData(propName, defaultValues[propName]);\n            this._updateAsyncProp(propName, value);\n        }\n    }\n    /* Placeholder methods for subclassing */\n    _fetch(propName, url) {\n        return null;\n    }\n    _onResolve(propName, value) { } // eslint-disable-line @typescript-eslint/no-empty-function\n    _onError(propName, error) { } // eslint-disable-line @typescript-eslint/no-empty-function\n    // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n    _updateAsyncProp(propName, value) {\n        if (!this._didAsyncInputValueChange(propName, value)) {\n            return;\n        }\n        // interpret value string as url and start a new load tracked by a promise\n        if (typeof value === 'string') {\n            value = this._fetch(propName, value);\n        }\n        // interprets promise and track the \"loading\"\n        if (value instanceof Promise) {\n            this._watchPromise(propName, value);\n            return;\n        }\n        if (isAsyncIterable(value)) {\n            this._resolveAsyncIterable(propName, value); // eslint-disable-line @typescript-eslint/no-floating-promises\n            return;\n        }\n        // else, normal, non-async value. Just store value for now\n        this._setPropValue(propName, value);\n    }\n    // Whenever async props are changing, we need to make a copy of oldProps\n    // otherwise the prop rewriting will affect the value both in props and oldProps.\n    // While the copy is relatively expensive, this only happens on load completion.\n    _freezeAsyncOldProps() {\n        if (!this.oldAsyncProps && this.oldProps) {\n            // 1. inherit all synchronous props from oldProps\n            // 2. reconfigure the async prop descriptors to fixed values\n            this.oldAsyncProps = Object.create(this.oldProps);\n            for (const propName in this.asyncProps) {\n                Object.defineProperty(this.oldAsyncProps, propName, {\n                    enumerable: true,\n                    value: this.oldProps[propName]\n                });\n            }\n        }\n    }\n    // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n    _didAsyncInputValueChange(propName, value) {\n        // @ts-ignore\n        const asyncProp = this.asyncProps[propName];\n        if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n            return false;\n        }\n        asyncProp.lastValue = value;\n        return true;\n    }\n    // Set normal, non-async value\n    _setPropValue(propName, value) {\n        // Save the current value before overwriting so that diffProps can access both\n        this._freezeAsyncOldProps();\n        const asyncProp = this.asyncProps[propName];\n        if (asyncProp) {\n            value = this._postProcessValue(asyncProp, value);\n            asyncProp.resolvedValue = value;\n            asyncProp.pendingLoadCount++;\n            asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n        }\n    }\n    // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n    _setAsyncPropValue(propName, value, loadCount) {\n        // Only update if loadCount is larger or equal to resolvedLoadCount\n        // otherwise a more recent load has already completed\n        const asyncProp = this.asyncProps[propName];\n        if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n            // Save the current value before overwriting so that diffProps can access both\n            this._freezeAsyncOldProps();\n            asyncProp.resolvedValue = value;\n            asyncProp.resolvedLoadCount = loadCount;\n            // Call callback to inform listener\n            this.onAsyncPropUpdated(propName, value);\n        }\n    }\n    // Tracks a promise, sets the prop when loaded, handles load count\n    _watchPromise(propName, promise) {\n        const asyncProp = this.asyncProps[propName];\n        if (asyncProp) {\n            asyncProp.pendingLoadCount++;\n            const loadCount = asyncProp.pendingLoadCount;\n            promise\n                .then(data => {\n                if (!this.component) {\n                    // This component state has been finalized\n                    return;\n                }\n                data = this._postProcessValue(asyncProp, data);\n                this._setAsyncPropValue(propName, data, loadCount);\n                this._onResolve(propName, data);\n            })\n                .catch(error => {\n                this._onError(propName, error);\n            });\n        }\n    }\n    async _resolveAsyncIterable(propName, iterable) {\n        if (propName !== 'data') {\n            // we only support data as async iterable\n            this._setPropValue(propName, iterable);\n            return;\n        }\n        const asyncProp = this.asyncProps[propName];\n        if (!asyncProp) {\n            return;\n        }\n        asyncProp.pendingLoadCount++;\n        const loadCount = asyncProp.pendingLoadCount;\n        let data = [];\n        let count = 0;\n        for await (const chunk of iterable) {\n            if (!this.component) {\n                // This component state has been finalized\n                return;\n            }\n            // @ts-expect-error (2339) dataTransform is not decared in base component props\n            const { dataTransform } = this.component.props;\n            if (dataTransform) {\n                data = dataTransform(chunk, data);\n            }\n            else {\n                data = data.concat(chunk);\n            }\n            // Used by the default _dataDiff function\n            Object.defineProperty(data, '__diff', {\n                enumerable: false,\n                value: [{ startRow: count, endRow: data.length }]\n            });\n            count = data.length;\n            this._setAsyncPropValue(propName, data, loadCount);\n        }\n        this._onResolve(propName, data);\n    }\n    // Give the app a chance to post process the loaded data\n    _postProcessValue(asyncProp, value) {\n        const propType = asyncProp.type;\n        if (propType && this.component) {\n            if (propType.release) {\n                propType.release(asyncProp.resolvedValue, propType, this.component);\n            }\n            if (propType.transform) {\n                return propType.transform(value, propType, this.component);\n            }\n        }\n        return value;\n    }\n    // Creating an asyncProp record if needed\n    _createAsyncPropData(propName, defaultValue) {\n        const asyncProp = this.asyncProps[propName];\n        if (!asyncProp) {\n            const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];\n            // assert(defaultValue !== undefined);\n            this.asyncProps[propName] = {\n                type: propTypes && propTypes[propName],\n                lastValue: null,\n                resolvedValue: defaultValue,\n                pendingLoadCount: 0,\n                resolvedLoadCount: 0\n            };\n        }\n    }\n}\n","// deck.gl, MIT license\nimport ComponentState from \"../lifecycle/component-state.js\";\nexport default class LayerState extends ComponentState {\n    constructor({ attributeManager, layer }) {\n        super(layer);\n        this.attributeManager = attributeManager;\n        this.needsRedraw = true;\n        this.needsUpdate = true;\n        this.subLayers = null;\n        this.usesPickingColorCache = false;\n    }\n    get layer() {\n        return this.component;\n    }\n    /* Override base Component methods with Layer-specific handling */\n    _fetch(propName, url) {\n        const layer = this.layer;\n        const fetch = layer?.props.fetch;\n        if (fetch) {\n            return fetch(url, { propName, layer });\n        }\n        return super._fetch(propName, url);\n    }\n    _onResolve(propName, value) {\n        const layer = this.layer;\n        if (layer) {\n            const onDataLoad = layer.props.onDataLoad;\n            if (propName === 'data' && onDataLoad) {\n                onDataLoad(value, { propName, layer });\n            }\n        }\n    }\n    _onError(propName, error) {\n        const layer = this.layer;\n        if (layer) {\n            layer.raiseError(error, `loading ${propName} of ${this.layer}`);\n        }\n    }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable react/no-direct-mutation-state */\nimport { Buffer } from '@luma.gl/core';\nimport { COORDINATE_SYSTEM } from \"./constants.js\";\nimport AttributeManager from \"./attribute/attribute-manager.js\";\nimport UniformTransitionManager from \"./uniform-transition-manager.js\";\nimport { diffProps, validateProps } from \"../lifecycle/props.js\";\nimport { LIFECYCLE } from \"../lifecycle/constants.js\";\nimport { count } from \"../utils/count.js\";\nimport log from \"../utils/log.js\";\nimport debug from \"../debug/index.js\";\nimport assert from \"../utils/assert.js\";\nimport memoize from \"../utils/memoize.js\";\nimport { mergeShaders } from \"../utils/shader.js\";\nimport { projectPosition, getWorldPosition } from \"../shaderlib/project/project-functions.js\";\nimport typedArrayManager from \"../utils/typed-array-manager.js\";\nimport Component from \"../lifecycle/component.js\";\nimport LayerState from \"./layer-state.js\";\nimport { worldToPixels } from '@math.gl/web-mercator';\nimport { load } from '@loaders.gl/core';\nconst TRACE_CHANGE_FLAG = 'layer.changeFlag';\nconst TRACE_INITIALIZE = 'layer.initialize';\nconst TRACE_UPDATE = 'layer.update';\nconst TRACE_FINALIZE = 'layer.finalize';\nconst TRACE_MATCHED = 'layer.matched';\nconst MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;\nconst EMPTY_ARRAY = Object.freeze([]);\n// Only compare the same two viewports once\nconst areViewportsEqual = memoize(({ oldViewport, viewport }) => {\n    return oldViewport.equals(viewport);\n});\nlet pickingColorCache = new Uint8ClampedArray(0);\nconst defaultProps = {\n    // data: Special handling for null, see below\n    data: { type: 'data', value: EMPTY_ARRAY, async: true },\n    dataComparator: { type: 'function', value: null, optional: true },\n    _dataDiff: {\n        type: 'function',\n        // @ts-ignore __diff is not defined on data\n        value: data => data && data.__diff,\n        optional: true\n    },\n    dataTransform: { type: 'function', value: null, optional: true },\n    onDataLoad: { type: 'function', value: null, optional: true },\n    onError: { type: 'function', value: null, optional: true },\n    fetch: {\n        type: 'function',\n        value: (url, { propName, layer, loaders, loadOptions, signal }) => {\n            const { resourceManager } = layer.context;\n            loadOptions = loadOptions || layer.getLoadOptions();\n            loaders = loaders || layer.props.loaders;\n            if (signal) {\n                loadOptions = {\n                    ...loadOptions,\n                    fetch: {\n                        ...loadOptions?.fetch,\n                        signal\n                    }\n                };\n            }\n            let inResourceManager = resourceManager.contains(url);\n            if (!inResourceManager && !loadOptions) {\n                // If there is no layer-specific load options, then attempt to cache this resource in the data manager\n                resourceManager.add({ resourceId: url, data: load(url, loaders), persistent: false });\n                inResourceManager = true;\n            }\n            if (inResourceManager) {\n                return resourceManager.subscribe({\n                    resourceId: url,\n                    onChange: data => layer.internalState?.reloadAsyncProp(propName, data),\n                    consumerId: layer.id,\n                    requestId: propName\n                });\n            }\n            return load(url, loaders, loadOptions);\n        }\n    },\n    updateTriggers: {}, // Update triggers: a core change detection mechanism in deck.gl\n    visible: true,\n    pickable: false,\n    opacity: { type: 'number', min: 0, max: 1, value: 1 },\n    operation: 'draw',\n    onHover: { type: 'function', value: null, optional: true },\n    onClick: { type: 'function', value: null, optional: true },\n    onDragStart: { type: 'function', value: null, optional: true },\n    onDrag: { type: 'function', value: null, optional: true },\n    onDragEnd: { type: 'function', value: null, optional: true },\n    coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n    coordinateOrigin: { type: 'array', value: [0, 0, 0], compare: true },\n    modelMatrix: { type: 'array', value: null, compare: true, optional: true },\n    wrapLongitude: false,\n    positionFormat: 'XYZ',\n    colorFormat: 'RGBA',\n    parameters: { type: 'object', value: {}, optional: true, compare: 2 },\n    loadOptions: { type: 'object', value: null, optional: true, ignore: true },\n    transitions: null,\n    extensions: [],\n    loaders: { type: 'array', value: [], optional: true, ignore: true },\n    // Offset depth based on layer index to avoid z-fighting.\n    // Negative values pull layer towards the camera\n    // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm\n    getPolygonOffset: {\n        type: 'function',\n        value: ({ layerIndex }) => [0, -layerIndex * 100]\n    },\n    // Selection/Highlighting\n    highlightedObjectIndex: null,\n    autoHighlight: false,\n    highlightColor: { type: 'accessor', value: [0, 0, 128, 128] }\n};\nclass Layer extends Component {\n    constructor() {\n        super(...arguments);\n        this.internalState = null;\n        this.lifecycle = LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers\n        this.parent = null;\n    }\n    static get componentName() {\n        return Object.prototype.hasOwnProperty.call(this, 'layerName') ? this.layerName : '';\n    }\n    get root() {\n        // eslint-disable-next-line\n        let layer = this;\n        while (layer.parent) {\n            layer = layer.parent;\n        }\n        return layer;\n    }\n    toString() {\n        const className = this.constructor.layerName || this.constructor.name;\n        return `${className}({id: '${this.props.id}'})`;\n    }\n    // Public API for users\n    /** Projects a point with current view state from the current layer's coordinate system to screen */\n    project(xyz) {\n        assert(this.internalState);\n        const viewport = this.internalState.viewport || this.context.viewport;\n        const worldPosition = getWorldPosition(xyz, {\n            viewport,\n            modelMatrix: this.props.modelMatrix,\n            coordinateOrigin: this.props.coordinateOrigin,\n            coordinateSystem: this.props.coordinateSystem\n        });\n        const [x, y, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);\n        return xyz.length === 2 ? [x, y] : [x, y, z];\n    }\n    /** Unprojects a screen pixel to the current view's default coordinate system\n        Note: this does not reverse `project`. */\n    unproject(xy) {\n        assert(this.internalState);\n        const viewport = this.internalState.viewport || this.context.viewport;\n        return viewport.unproject(xy);\n    }\n    /** Projects a point with current view state from the current layer's coordinate system to the world space */\n    projectPosition(xyz, params) {\n        assert(this.internalState);\n        const viewport = this.internalState.viewport || this.context.viewport;\n        return projectPosition(xyz, {\n            viewport,\n            modelMatrix: this.props.modelMatrix,\n            coordinateOrigin: this.props.coordinateOrigin,\n            coordinateSystem: this.props.coordinateSystem,\n            ...params\n        });\n    }\n    // Public API for custom layer implementation\n    /** `true` if this layer renders other layers */\n    get isComposite() {\n        return false;\n    }\n    /** Updates selected state members and marks the layer for redraw */\n    setState(partialState) {\n        this.setChangeFlags({ stateChanged: true });\n        Object.assign(this.state, partialState);\n        this.setNeedsRedraw();\n    }\n    /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */\n    setNeedsRedraw() {\n        if (this.internalState) {\n            this.internalState.needsRedraw = true;\n        }\n    }\n    /** Mark this layer as needs a deep update */\n    setNeedsUpdate() {\n        if (this.internalState) {\n            this.context.layerManager.setNeedsUpdate(String(this));\n            this.internalState.needsUpdate = true;\n        }\n    }\n    /** Returns true if all async resources are loaded */\n    get isLoaded() {\n        return this.internalState ? !this.internalState.isAsyncPropLoading() : false;\n    }\n    /** Returns true if using shader-based WGS84 longitude wrapping */\n    get wrapLongitude() {\n        return this.props.wrapLongitude;\n    }\n    /** @deprecated Returns true if the layer is visible in the picking pass */\n    isPickable() {\n        return this.props.pickable && this.props.visible;\n    }\n    /** Returns an array of models used by this layer, can be overriden by layer subclass */\n    getModels() {\n        const state = this.state;\n        return (state && (state.models || (state.model && [state.model]))) || [];\n    }\n    // TODO deprecate in favour of setShaderModuleProps\n    /** Update shader module parameters */\n    setModuleParameters(moduleParameters) {\n        for (const model of this.getModels()) {\n            model.updateModuleSettings(moduleParameters);\n        }\n    }\n    /** Update shader input parameters */\n    setShaderModuleProps(...props) {\n        for (const model of this.getModels()) {\n            model.shaderInputs.setProps(...props);\n        }\n    }\n    /** Returns the attribute manager of this layer */\n    getAttributeManager() {\n        return this.internalState && this.internalState.attributeManager;\n    }\n    /** Returns the most recent layer that matched to this state\n      (When reacting to an async event, this layer may no longer be the latest) */\n    getCurrentLayer() {\n        return this.internalState && this.internalState.layer;\n    }\n    /** Returns the default parse options for async props */\n    getLoadOptions() {\n        return this.props.loadOptions;\n    }\n    use64bitPositions() {\n        const { coordinateSystem } = this.props;\n        return (coordinateSystem === COORDINATE_SYSTEM.DEFAULT ||\n            coordinateSystem === COORDINATE_SYSTEM.LNGLAT ||\n            coordinateSystem === COORDINATE_SYSTEM.CARTESIAN);\n    }\n    // Event handling\n    onHover(info, pickingEvent) {\n        if (this.props.onHover) {\n            return this.props.onHover(info, pickingEvent) || false;\n        }\n        return false;\n    }\n    onClick(info, pickingEvent) {\n        if (this.props.onClick) {\n            return this.props.onClick(info, pickingEvent) || false;\n        }\n        return false;\n    }\n    // Returns the picking color that doesn't match any subfeature\n    // Use if some graphics do not belong to any pickable subfeature\n    // @return {Array} - a black color\n    nullPickingColor() {\n        return [0, 0, 0];\n    }\n    // Returns the picking color that doesn't match any subfeature\n    // Use if some graphics do not belong to any pickable subfeature\n    encodePickingColor(i, target = []) {\n        target[0] = (i + 1) & 255;\n        target[1] = ((i + 1) >> 8) & 255;\n        target[2] = (((i + 1) >> 8) >> 8) & 255;\n        return target;\n    }\n    // Returns the index corresponding to a picking color that doesn't match any subfeature\n    // @param {Uint8Array} color - color array to be decoded\n    // @return {Array} - the decoded picking color\n    decodePickingColor(color) {\n        assert(color instanceof Uint8Array);\n        const [i1, i2, i3] = color;\n        // 1 was added to seperate from no selection\n        const index = i1 + i2 * 256 + i3 * 65536 - 1;\n        return index;\n    }\n    /** Deduces number of instances. Intention is to support:\n      - Explicit setting of numInstances\n      - Auto-deduction for ES6 containers that define a size member\n      - Auto-deduction for Classic Arrays via the built-in length attribute\n      - Auto-deduction via arrays */\n    getNumInstances() {\n        // First Check if app has provided an explicit value\n        if (Number.isFinite(this.props.numInstances)) {\n            return this.props.numInstances;\n        }\n        // Second check if the layer has set its own value\n        if (this.state && this.state.numInstances !== undefined) {\n            return this.state.numInstances;\n        }\n        // Use container library to get a count for any ES6 container or object\n        return count(this.props.data);\n    }\n    /** Buffer layout describes how many attribute values are packed for each data object\n        The default (null) is one value each object.\n        Some data formats (e.g. paths, polygons) have various length. Their buffer layout\n        is in the form of [L0, L1, L2, ...] */\n    getStartIndices() {\n        // First Check if startIndices is provided as an explicit value\n        if (this.props.startIndices) {\n            return this.props.startIndices;\n        }\n        // Second check if the layer has set its own value\n        if (this.state && this.state.startIndices) {\n            return this.state.startIndices;\n        }\n        return null;\n    }\n    // Default implementation\n    getBounds() {\n        return this.getAttributeManager()?.getBounds(['positions', 'instancePositions']);\n    }\n    getShaders(shaders) {\n        shaders = mergeShaders(shaders, {\n            disableWarnings: true,\n            modules: this.context.defaultShaderModules\n        });\n        for (const extension of this.props.extensions) {\n            shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));\n        }\n        return shaders;\n    }\n    /** Controls if updateState should be called. By default returns true if any prop has changed */\n    shouldUpdateState(params) {\n        return params.changeFlags.propsOrDataChanged;\n    }\n    /** Default implementation, all attributes will be invalidated and updated when data changes */\n    // eslint-disable-next-line complexity\n    updateState(params) {\n        const attributeManager = this.getAttributeManager();\n        const { dataChanged } = params.changeFlags;\n        if (dataChanged && attributeManager) {\n            if (Array.isArray(dataChanged)) {\n                // is partial update\n                for (const dataRange of dataChanged) {\n                    attributeManager.invalidateAll(dataRange);\n                }\n            }\n            else {\n                attributeManager.invalidateAll();\n            }\n        }\n        // Enable/disable picking buffer\n        if (attributeManager) {\n            const { props } = params;\n            const hasPickingBuffer = this.internalState.hasPickingBuffer;\n            const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) ||\n                props.pickable ||\n                props.extensions.some(extension => extension.getNeedsPickingBuffer.call(this, extension));\n            // Only generate picking buffer if needed\n            if (hasPickingBuffer !== needsPickingBuffer) {\n                this.internalState.hasPickingBuffer = needsPickingBuffer;\n                const { pickingColors, instancePickingColors } = attributeManager.attributes;\n                const pickingColorsAttribute = pickingColors || instancePickingColors;\n                if (pickingColorsAttribute) {\n                    if (needsPickingBuffer && pickingColorsAttribute.constant) {\n                        pickingColorsAttribute.constant = false;\n                        attributeManager.invalidate(pickingColorsAttribute.id);\n                    }\n                    if (!pickingColorsAttribute.value && !needsPickingBuffer) {\n                        pickingColorsAttribute.constant = true;\n                        pickingColorsAttribute.value = [0, 0, 0];\n                    }\n                }\n            }\n        }\n    }\n    /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */\n    finalizeState(context) {\n        for (const model of this.getModels()) {\n            model.destroy();\n        }\n        const attributeManager = this.getAttributeManager();\n        if (attributeManager) {\n            attributeManager.finalize();\n        }\n        if (this.context) {\n            this.context.resourceManager.unsubscribe({ consumerId: this.id });\n        }\n        if (this.internalState) {\n            this.internalState.uniformTransitions.clear();\n            this.internalState.finalize();\n        }\n    }\n    // If state has a model, draw it with supplied uniforms\n    draw(opts) {\n        for (const model of this.getModels()) {\n            model.draw(opts);\n        }\n    }\n    // called to populate the info object that is passed to the event handler\n    // @return null to cancel event\n    getPickingInfo({ info, mode, sourceLayer }) {\n        const { index } = info;\n        if (index >= 0) {\n            // If props.data is an indexable array, get the object\n            if (Array.isArray(this.props.data)) {\n                info.object = this.props.data[index];\n            }\n        }\n        return info;\n    }\n    // END LIFECYCLE METHODS\n    // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker\n    /** (Internal) Propagate an error event through the system */\n    raiseError(error, message) {\n        if (message) {\n            // Duplicating error message for backward compatibility, see #7986\n            // TODO - revisit in v9\n            error = new Error(`${message}: ${error.message}`, { cause: error });\n        }\n        if (!this.props.onError?.(error)) {\n            this.context?.onError?.(error, this);\n        }\n    }\n    /** (Internal) Checks if this layer needs redraw */\n    getNeedsRedraw(opts = { clearRedrawFlags: false }) {\n        return this._getNeedsRedraw(opts);\n    }\n    /** (Internal) Checks if this layer needs a deep update */\n    needsUpdate() {\n        if (!this.internalState) {\n            return false;\n        }\n        // Call subclass lifecycle method\n        return (this.internalState.needsUpdate ||\n            this.hasUniformTransition() ||\n            this.shouldUpdateState(this._getUpdateParams()));\n        // End lifecycle method\n    }\n    /** Checks if this layer has ongoing uniform transition */\n    hasUniformTransition() {\n        return this.internalState?.uniformTransitions.active || false;\n    }\n    /** Called when this layer is rendered into the given viewport */\n    activateViewport(viewport) {\n        if (!this.internalState) {\n            return;\n        }\n        const oldViewport = this.internalState.viewport;\n        this.internalState.viewport = viewport;\n        if (!oldViewport || !areViewportsEqual({ oldViewport, viewport })) {\n            this.setChangeFlags({ viewportChanged: true });\n            if (this.isComposite) {\n                if (this.needsUpdate()) {\n                    // Composite layers may add/remove sublayers on viewport change\n                    // Because we cannot change the layers list during a draw cycle, we don't want to update sublayers right away\n                    // This will not call update immediately, but mark the layerManager as needs update on the next frame\n                    this.setNeedsUpdate();\n                }\n            }\n            else {\n                this._update();\n            }\n        }\n    }\n    /** Default implementation of attribute invalidation, can be redefined */\n    invalidateAttribute(name = 'all') {\n        const attributeManager = this.getAttributeManager();\n        if (!attributeManager) {\n            return;\n        }\n        if (name === 'all') {\n            attributeManager.invalidateAll();\n        }\n        else {\n            attributeManager.invalidate(name);\n        }\n    }\n    /** Send updated attributes to the WebGL model */\n    updateAttributes(changedAttributes) {\n        // If some buffer layout changed\n        let bufferLayoutChanged = false;\n        for (const id in changedAttributes) {\n            if (changedAttributes[id].layoutChanged()) {\n                bufferLayoutChanged = true;\n            }\n        }\n        for (const model of this.getModels()) {\n            this._setModelAttributes(model, changedAttributes, bufferLayoutChanged);\n        }\n    }\n    /** Recalculate any attributes if needed */\n    _updateAttributes() {\n        const attributeManager = this.getAttributeManager();\n        if (!attributeManager) {\n            return;\n        }\n        const props = this.props;\n        // Figure out data length\n        const numInstances = this.getNumInstances();\n        const startIndices = this.getStartIndices();\n        attributeManager.update({\n            data: props.data,\n            numInstances,\n            startIndices,\n            props,\n            transitions: props.transitions,\n            // @ts-ignore (TS2339) property attribute is not present on some acceptable data types\n            buffers: props.data.attributes,\n            context: this\n        });\n        const changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });\n        this.updateAttributes(changedAttributes);\n    }\n    /** Update attribute transitions. This is called in drawLayer, no model updates required. */\n    _updateAttributeTransition() {\n        const attributeManager = this.getAttributeManager();\n        if (attributeManager) {\n            attributeManager.updateTransition();\n        }\n    }\n    /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */\n    _updateUniformTransition() {\n        // @ts-ignore (TS2339) internalState is alwasy defined when this method is called\n        const { uniformTransitions } = this.internalState;\n        if (uniformTransitions.active) {\n            // clone props\n            const propsInTransition = uniformTransitions.update();\n            const props = Object.create(this.props);\n            for (const key in propsInTransition) {\n                Object.defineProperty(props, key, { value: propsInTransition[key] });\n            }\n            return props;\n        }\n        return this.props;\n    }\n    /** Updater for the automatically populated instancePickingColors attribute */\n    calculateInstancePickingColors(attribute, { numInstances }) {\n        if (attribute.constant) {\n            return;\n        }\n        // calculateInstancePickingColors always generates the same sequence.\n        // pickingColorCache saves the largest generated sequence for reuse\n        const cacheSize = Math.floor(pickingColorCache.length / 4);\n        // Record when using the picking buffer cache, so that layers can always point at the most recently allocated cache\n        // @ts-ignore (TS2531) internalState is always defined when this method is called\n        this.internalState.usesPickingColorCache = true;\n        if (cacheSize < numInstances) {\n            if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {\n                log.warn('Layer has too many data objects. Picking might not be able to distinguish all objects.')();\n            }\n            pickingColorCache = typedArrayManager.allocate(pickingColorCache, numInstances, {\n                size: 4,\n                copy: true,\n                maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)\n            });\n            // If the attribute is larger than the cache, resize the cache and populate the missing chunk\n            const newCacheSize = Math.floor(pickingColorCache.length / 4);\n            const pickingColor = [];\n            for (let i = cacheSize; i < newCacheSize; i++) {\n                this.encodePickingColor(i, pickingColor);\n                pickingColorCache[i * 4 + 0] = pickingColor[0];\n                pickingColorCache[i * 4 + 1] = pickingColor[1];\n                pickingColorCache[i * 4 + 2] = pickingColor[2];\n            }\n        }\n        attribute.value = pickingColorCache.subarray(0, numInstances * 4);\n    }\n    /** Apply changed attributes to model */\n    _setModelAttributes(model, changedAttributes, bufferLayoutChanged = false) {\n        if (!Object.keys(changedAttributes).length) {\n            return;\n        }\n        if (bufferLayoutChanged) {\n            // AttributeManager is always defined when this method is called\n            const attributeManager = this.getAttributeManager();\n            model.setBufferLayout(attributeManager.getBufferLayouts(model));\n            // All attributes must be reset after buffer layout change\n            changedAttributes = attributeManager.getAttributes();\n        }\n        // @ts-ignore luma.gl type issue\n        const excludeAttributes = model.userData?.excludeAttributes || {};\n        const attributeBuffers = {};\n        const constantAttributes = {};\n        for (const name in changedAttributes) {\n            if (excludeAttributes[name]) {\n                continue;\n            }\n            const values = changedAttributes[name].getValue();\n            for (const attributeName in values) {\n                const value = values[attributeName];\n                if (value instanceof Buffer) {\n                    if (changedAttributes[name].settings.isIndexed) {\n                        model.setIndexBuffer(value);\n                    }\n                    else {\n                        attributeBuffers[attributeName] = value;\n                    }\n                }\n                else if (value) {\n                    constantAttributes[attributeName] = value;\n                }\n            }\n        }\n        // TODO - update buffer map?\n        model.setAttributes(attributeBuffers);\n        model.setConstantAttributes(constantAttributes);\n    }\n    /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.\n       This method may be overriden by layer implementations */\n    disablePickingIndex(objectIndex) {\n        const data = this.props.data;\n        if (!('attributes' in data)) {\n            this._disablePickingIndex(objectIndex);\n            return;\n        }\n        // @ts-ignore (TS2531) this method is only called internally with attributeManager defined\n        const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;\n        const colors = pickingColors || instancePickingColors;\n        const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];\n        if (externalColorAttribute && externalColorAttribute.value) {\n            const values = externalColorAttribute.value;\n            const objectColor = this.encodePickingColor(objectIndex);\n            for (let index = 0; index < data.length; index++) {\n                const i = colors.getVertexOffset(index);\n                if (values[i] === objectColor[0] &&\n                    values[i + 1] === objectColor[1] &&\n                    values[i + 2] === objectColor[2]) {\n                    this._disablePickingIndex(index);\n                }\n            }\n        }\n        else {\n            this._disablePickingIndex(objectIndex);\n        }\n    }\n    // TODO - simplify subclassing interface\n    _disablePickingIndex(objectIndex) {\n        // @ts-ignore (TS2531) this method is only called internally with attributeManager defined\n        const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;\n        const colors = pickingColors || instancePickingColors;\n        if (!colors) {\n            return;\n        }\n        const start = colors.getVertexOffset(objectIndex);\n        const end = colors.getVertexOffset(objectIndex + 1);\n        // Fill the sub buffer with 0s, 1 byte per element\n        colors.buffer.write(new Uint8Array(end - start), start);\n    }\n    /** (Internal) Re-enable all picking indices after multi-depth picking */\n    restorePickingColors() {\n        // @ts-ignore (TS2531) this method is only called internally with attributeManager defined\n        const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;\n        const colors = pickingColors || instancePickingColors;\n        if (!colors) {\n            return;\n        }\n        // The picking color cache may have been freed and then reallocated. This ensures we read from the currently allocated cache.\n        if (\n        // @ts-ignore (TS2531) this method is only called internally with internalState defined\n        this.internalState.usesPickingColorCache &&\n            colors.value.buffer !== pickingColorCache.buffer) {\n            colors.value = pickingColorCache.subarray(0, colors.value.length);\n        }\n        colors.updateSubBuffer({ startOffset: 0 });\n    }\n    /* eslint-disable max-statements */\n    /* (Internal) Called by layer manager when a new layer is found */\n    _initialize() {\n        assert(!this.internalState); // finalized layer cannot be reused\n        assert(Number.isFinite(this.props.coordinateSystem)); // invalid coordinateSystem\n        debug(TRACE_INITIALIZE, this);\n        const attributeManager = this._getAttributeManager();\n        if (attributeManager) {\n            // All instanced layers get instancePickingColors attribute by default\n            // Their shaders can use it to render a picking scene\n            // TODO - this slightly slows down non instanced layers\n            attributeManager.addInstanced({\n                instancePickingColors: {\n                    type: 'uint8',\n                    size: 4,\n                    noAlloc: true,\n                    // Updaters are always called with `this` pointing to the layer\n                    // eslint-disable-next-line @typescript-eslint/unbound-method\n                    update: this.calculateInstancePickingColors\n                }\n            });\n        }\n        this.internalState = new LayerState({\n            attributeManager,\n            layer: this\n        });\n        this._clearChangeFlags(); // populate this.internalState.changeFlags\n        this.state = {};\n        // for backwards compatibility with older layers\n        // TODO - remove in next release\n        /* eslint-disable accessor-pairs */\n        Object.defineProperty(this.state, 'attributeManager', {\n            get: () => {\n                log.deprecated('layer.state.attributeManager', 'layer.getAttributeManager()')();\n                return attributeManager;\n            }\n        });\n        /* eslint-enable accessor-pairs */\n        this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);\n        this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);\n        // Ensure any async props are updated\n        this.internalState.setAsyncProps(this.props);\n        // Call subclass lifecycle methods\n        this.initializeState(this.context);\n        // Initialize extensions\n        for (const extension of this.props.extensions) {\n            extension.initializeState.call(this, this.context, extension);\n        }\n        // End subclass lifecycle methods\n        // initializeState callback tends to clear state\n        this.setChangeFlags({\n            dataChanged: 'init',\n            propsChanged: 'init',\n            viewportChanged: true,\n            extensionsChanged: true\n        });\n        this._update();\n    }\n    /** (Internal) Called by layer manager to transfer state from an old layer */\n    _transferState(oldLayer) {\n        debug(TRACE_MATCHED, this, this === oldLayer);\n        const { state, internalState } = oldLayer;\n        if (this === oldLayer) {\n            return;\n        }\n        // Move internalState\n        this.internalState = internalState;\n        // Move state\n        this.state = state;\n        // We keep the state ref on old layers to support async actions\n        // oldLayer.state = null;\n        // Ensure any async props are updated\n        this.internalState.setAsyncProps(this.props);\n        this._diffProps(this.props, this.internalState.getOldProps());\n    }\n    /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */\n    _update() {\n        // Call subclass lifecycle method\n        const stateNeedsUpdate = this.needsUpdate();\n        // End lifecycle method\n        debug(TRACE_UPDATE, this, stateNeedsUpdate);\n        if (!stateNeedsUpdate) {\n            return;\n        }\n        const currentProps = this.props;\n        const context = this.context;\n        const internalState = this.internalState;\n        const currentViewport = context.viewport;\n        const propsInTransition = this._updateUniformTransition();\n        internalState.propsInTransition = propsInTransition;\n        // Overwrite this.context.viewport during update to use the last activated viewport on this layer\n        // In multi-view applications, a layer may only be drawn in one of the views\n        // Which would make the \"active\" viewport different from the shared context\n        context.viewport = internalState.viewport || currentViewport;\n        // Overwrite this.props during update to use in-transition prop values\n        this.props = propsInTransition;\n        try {\n            const updateParams = this._getUpdateParams();\n            const oldModels = this.getModels();\n            // Safely call subclass lifecycle methods\n            if (context.device) {\n                this.updateState(updateParams);\n            }\n            else {\n                try {\n                    this.updateState(updateParams);\n                }\n                catch (error) {\n                    // ignore error if gl context is missing\n                }\n            }\n            // Execute extension updates\n            for (const extension of this.props.extensions) {\n                extension.updateState.call(this, updateParams, extension);\n            }\n            const modelChanged = this.getModels()[0] !== oldModels[0];\n            this._postUpdate(updateParams, modelChanged);\n            // End subclass lifecycle methods\n        }\n        finally {\n            // Restore shared context\n            context.viewport = currentViewport;\n            this.props = currentProps;\n            this._clearChangeFlags();\n            internalState.needsUpdate = false;\n            internalState.resetOldProps();\n        }\n    }\n    /* eslint-enable max-statements */\n    /** (Internal) Called by manager when layer is about to be disposed\n        Note: not guaranteed to be called on application shutdown */\n    _finalize() {\n        debug(TRACE_FINALIZE, this);\n        // Call subclass lifecycle method\n        this.finalizeState(this.context);\n        // Finalize extensions\n        for (const extension of this.props.extensions) {\n            extension.finalizeState.call(this, this.context, extension);\n        }\n    }\n    // Calculates uniforms\n    _drawLayer({ renderPass, moduleParameters = null, uniforms = {}, parameters = {} }) {\n        this._updateAttributeTransition();\n        const currentProps = this.props;\n        const context = this.context;\n        // Overwrite this.props during redraw to use in-transition prop values\n        // `internalState.propsInTransition` could be missing if `updateState` failed\n        // @ts-ignore (TS2339) internalState is alwasy defined when this method is called\n        this.props = this.internalState.propsInTransition || currentProps;\n        const opacity = this.props.opacity;\n        // apply gamma to opacity to make it visually \"linear\"\n        uniforms.opacity = Math.pow(opacity, 1 / 2.2);\n        try {\n            // TODO/ib - hack move to luma Model.draw\n            if (moduleParameters) {\n                const { isActive, isAttribute } = moduleParameters.picking;\n                this.setModuleParameters(moduleParameters);\n                this.setShaderModuleProps({ picking: { isActive, isAttribute } });\n            }\n            // Apply polygon offset to avoid z-fighting\n            // TODO - move to draw-layers\n            const { getPolygonOffset } = this.props;\n            const offsets = (getPolygonOffset && getPolygonOffset(uniforms)) || [0, 0];\n            context.device.setParametersWebGL({ polygonOffset: offsets });\n            for (const model of this.getModels()) {\n                model.setParameters(parameters);\n            }\n            // Call subclass lifecycle method\n            context.device.withParametersWebGL(parameters, () => {\n                const opts = { renderPass, moduleParameters, uniforms, parameters, context };\n                // extensions\n                for (const extension of this.props.extensions) {\n                    extension.draw.call(this, opts, extension);\n                }\n                this.draw(opts);\n            });\n        }\n        finally {\n            this.props = currentProps;\n        }\n        // End lifecycle method\n    }\n    // Helper methods\n    /** Returns the current change flags */\n    getChangeFlags() {\n        return this.internalState?.changeFlags;\n    }\n    /* eslint-disable complexity */\n    /** Dirty some change flags, will be handled by updateLayer */\n    setChangeFlags(flags) {\n        if (!this.internalState) {\n            return;\n        }\n        const { changeFlags } = this.internalState;\n        /* eslint-disable no-fallthrough, max-depth */\n        for (const key in flags) {\n            if (flags[key]) {\n                let flagChanged = false;\n                switch (key) {\n                    case 'dataChanged':\n                        // changeFlags.dataChanged may be `false`, a string (reason) or an array of ranges\n                        const dataChangedReason = flags[key];\n                        const prevDataChangedReason = changeFlags[key];\n                        if (dataChangedReason && Array.isArray(prevDataChangedReason)) {\n                            // Merge partial updates\n                            changeFlags.dataChanged = Array.isArray(dataChangedReason)\n                                ? prevDataChangedReason.concat(dataChangedReason)\n                                : dataChangedReason;\n                            flagChanged = true;\n                        }\n                    default:\n                        if (!changeFlags[key]) {\n                            changeFlags[key] = flags[key];\n                            flagChanged = true;\n                        }\n                }\n                if (flagChanged) {\n                    debug(TRACE_CHANGE_FLAG, this, key, flags);\n                }\n            }\n        }\n        /* eslint-enable no-fallthrough, max-depth */\n        // Update composite flags\n        const propsOrDataChanged = Boolean(changeFlags.dataChanged ||\n            changeFlags.updateTriggersChanged ||\n            changeFlags.propsChanged ||\n            changeFlags.extensionsChanged);\n        changeFlags.propsOrDataChanged = propsOrDataChanged;\n        changeFlags.somethingChanged =\n            propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;\n    }\n    /* eslint-enable complexity */\n    /** Clear all changeFlags, typically after an update */\n    _clearChangeFlags() {\n        // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n        this.internalState.changeFlags = {\n            dataChanged: false,\n            propsChanged: false,\n            updateTriggersChanged: false,\n            viewportChanged: false,\n            stateChanged: false,\n            extensionsChanged: false,\n            propsOrDataChanged: false,\n            somethingChanged: false\n        };\n    }\n    /** Compares the layers props with old props from a matched older layer\n        and extracts change flags that describe what has change so that state\n        can be update correctly with minimal effort */\n    _diffProps(newProps, oldProps) {\n        const changeFlags = diffProps(newProps, oldProps);\n        // iterate over changedTriggers\n        if (changeFlags.updateTriggersChanged) {\n            for (const key in changeFlags.updateTriggersChanged) {\n                if (changeFlags.updateTriggersChanged[key]) {\n                    this.invalidateAttribute(key);\n                }\n            }\n        }\n        // trigger uniform transitions\n        if (changeFlags.transitionsChanged) {\n            for (const key in changeFlags.transitionsChanged) {\n                // prop changed and transition is enabled\n                // @ts-ignore (TS2531) internalState is always defined when this method is called\n                this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], newProps.transitions?.[key]);\n            }\n        }\n        return this.setChangeFlags(changeFlags);\n    }\n    /** (Internal) called by layer manager to perform extra props validation (in development only) */\n    validateProps() {\n        validateProps(this.props);\n    }\n    /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */\n    updateAutoHighlight(info) {\n        if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {\n            this._updateAutoHighlight(info);\n        }\n    }\n    // May be overriden by subclasses\n    // TODO - simplify subclassing interface\n    /** Update picking module parameters to highlight the hovered object */\n    _updateAutoHighlight(info) {\n        const picking = {\n            // @ts-expect-error stricter luma gl types\n            highlightedObjectColor: info.picked ? info.color : null\n        };\n        const { highlightColor } = this.props;\n        if (info.picked && typeof highlightColor === 'function') {\n            // @ts-expect-error stricter luma gl types\n            picking.highlightColor = highlightColor(info);\n        }\n        this.setShaderModuleProps({ picking });\n        // setShaderModuleProps does not trigger redraw\n        this.setNeedsRedraw();\n    }\n    /** Create new attribute manager */\n    _getAttributeManager() {\n        const context = this.context;\n        return new AttributeManager(context.device, {\n            id: this.props.id,\n            stats: context.stats,\n            timeline: context.timeline\n        });\n    }\n    // Private methods\n    /** Called after updateState to perform common tasks */\n    _postUpdate(updateParams, forceUpdate) {\n        const { props, oldProps } = updateParams;\n        this.setNeedsRedraw();\n        // Check if attributes need recalculation\n        this._updateAttributes();\n        // Note: Automatic instance count update only works for single layers\n        const model = this.state.model;\n        if (model?.isInstanced) {\n            model.setInstanceCount(this.getNumInstances());\n        }\n        // Set picking module parameters to match props\n        const { autoHighlight, highlightedObjectIndex, highlightColor } = props;\n        if (forceUpdate ||\n            oldProps.autoHighlight !== autoHighlight ||\n            oldProps.highlightedObjectIndex !== highlightedObjectIndex ||\n            oldProps.highlightColor !== highlightColor) {\n            const picking = {};\n            if (Array.isArray(highlightColor)) {\n                // @ts-expect-error stricter luma gl types\n                picking.highlightColor = highlightColor;\n            }\n            // highlightedObjectIndex will overwrite any settings from auto highlighting.\n            // Do not reset unless the value has changed.\n            if (forceUpdate ||\n                oldProps.autoHighlight !== autoHighlight ||\n                highlightedObjectIndex !== oldProps.highlightedObjectIndex) {\n                // @ts-expect-error stricter luma gl types\n                picking.highlightedObjectColor =\n                    Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0\n                        ? this.encodePickingColor(highlightedObjectIndex)\n                        : null;\n            }\n            this.setShaderModuleProps({ picking });\n        }\n    }\n    _getUpdateParams() {\n        return {\n            props: this.props,\n            // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n            oldProps: this.internalState.getOldProps(),\n            context: this.context,\n            // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n            changeFlags: this.internalState.changeFlags\n        };\n    }\n    /** Checks state of attributes and model */\n    _getNeedsRedraw(opts) {\n        // this method may be called by the render loop as soon a the layer\n        // has been created, so guard against uninitialized state\n        if (!this.internalState) {\n            return false;\n        }\n        let redraw = false;\n        redraw = redraw || (this.internalState.needsRedraw && this.id);\n        // TODO - is attribute manager needed? - Model should be enough.\n        const attributeManager = this.getAttributeManager();\n        const attributeManagerNeedsRedraw = attributeManager\n            ? attributeManager.getNeedsRedraw(opts)\n            : false;\n        redraw = redraw || attributeManagerNeedsRedraw;\n        if (redraw) {\n            for (const extension of this.props.extensions) {\n                extension.onNeedsRedraw.call(this, extension);\n            }\n        }\n        this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;\n        return redraw;\n    }\n    /** Callback when asyn prop is loaded */\n    _onAsyncPropUpdated() {\n        // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n        this._diffProps(this.props, this.internalState.getOldProps());\n        this.setNeedsUpdate();\n    }\n}\nLayer.defaultProps = defaultProps;\nLayer.layerName = 'Layer';\nexport default Layer;\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { glsl } from \"../../../lib/glsl-utils/highlight.js\";\n// cyan color\nconst DEFAULT_HIGHLIGHT_COLOR = [0, 1, 1, 1];\nconst vs = `\\\nuniform pickingUniforms {\nfloat isActive;\nfloat isAttribute;\nfloat isHighlightActive;\nfloat useFloatColors;\nvec3 highlightedObjectColor;\nvec4 highlightColor;\n} picking;\nout vec4 picking_vRGBcolor_Avalid;\nvec3 picking_normalizeColor(vec3 color) {\nreturn picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\nvec4 picking_normalizeColor(vec4 color) {\nreturn picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\nbool picking_isColorZero(vec3 color) {\nreturn dot(color, vec3(1.0)) < 0.00001;\n}\nbool picking_isColorValid(vec3 color) {\nreturn dot(color, vec3(1.0)) > 0.00001;\n}\nbool isVertexHighlighted(vec3 vertexColor) {\nvec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\nreturn\nbool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\nvoid picking_setPickingColor(vec3 pickingColor) {\npickingColor = picking_normalizeColor(pickingColor);\nif (bool(picking.isActive)) {\npicking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\nif (!bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rgb = pickingColor;\n}\n} else {\npicking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n}\n}\nvoid picking_setPickingAttribute(float value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.r = value;\n}\n}\nvoid picking_setPickingAttribute(vec2 value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rg = value;\n}\n}\nvoid picking_setPickingAttribute(vec3 value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rgb = value;\n}\n}\n`;\nconst fs = `\\\nuniform pickingUniforms {\nfloat isActive;\nfloat isAttribute;\nfloat isHighlightActive;\nfloat useFloatColors;\nvec3 highlightedObjectColor;\nvec4 highlightColor;\n} picking;\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\nif (picking.isActive > 0.5) {\nreturn color;\n}\nbool selected = bool(picking_vRGBcolor_Avalid.a);\nif (selected) {\nfloat highLightAlpha = picking.highlightColor.a;\nfloat blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\nfloat highLightRatio = highLightAlpha / blendedAlpha;\nvec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\nreturn vec4(blendedRGB, blendedAlpha);\n} else {\nreturn color;\n}\n}\nvec4 picking_filterPickingColor(vec4 color) {\nif (bool(picking.isActive)) {\nif (picking_vRGBcolor_Avalid.a == 0.0) {\ndiscard;\n}\nreturn picking_vRGBcolor_Avalid;\n}\nreturn color;\n}\nvec4 picking_filterColor(vec4 color) {\nvec4 highlightColor = picking_filterHighlightColor(color);\nreturn picking_filterPickingColor(highlightColor);\n}\n`;\n/**\n * Provides support for color-coding-based picking and highlighting.\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n */\nexport const picking = {\n    name: 'picking',\n    vs,\n    fs,\n    uniformTypes: {\n        isActive: 'f32',\n        isAttribute: 'f32',\n        isHighlightActive: 'f32',\n        useFloatColors: 'f32',\n        highlightedObjectColor: 'vec3<f32>',\n        highlightColor: 'vec4<f32>'\n    },\n    defaultUniforms: {\n        isActive: false,\n        isAttribute: false,\n        isHighlightActive: false,\n        useFloatColors: true,\n        highlightedObjectColor: [0, 0, 0],\n        highlightColor: DEFAULT_HIGHLIGHT_COLOR\n    },\n    getUniforms\n};\nfunction getUniforms(opts = {}, prevUniforms) {\n    const uniforms = {};\n    if (opts.highlightedObjectColor === undefined) {\n        // Unless highlightedObjectColor explicitly null or set, do not update state\n    }\n    else if (opts.highlightedObjectColor === null) {\n        uniforms.isHighlightActive = false;\n    }\n    else {\n        uniforms.isHighlightActive = true;\n        const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);\n        uniforms.highlightedObjectColor = highlightedObjectColor;\n    }\n    if (opts.highlightColor) {\n        const color = Array.from(opts.highlightColor, x => x / 255);\n        if (!Number.isFinite(color[3])) {\n            color[3] = 1;\n        }\n        uniforms.highlightColor = color;\n    }\n    if (opts.isActive !== undefined) {\n        uniforms.isActive = Boolean(opts.isActive);\n        uniforms.isAttribute = Boolean(opts.isAttribute);\n    }\n    if (opts.useFloatColors !== undefined) {\n        uniforms.useFloatColors = Boolean(opts.useFloatColors);\n    }\n    return uniforms;\n}\n","import { picking } from '@luma.gl/shadertools';\nexport default {\n    ...picking,\n    defaultUniforms: { ...picking.defaultUniforms, useFloatColors: false },\n    inject: {\n        'vs:DECKGL_FILTER_GL_POSITION': `\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  `,\n        'vs:DECKGL_FILTER_COLOR': `\n  picking_setPickingColor(geometry.pickingColor);\n  `,\n        'fs:DECKGL_FILTER_COLOR': {\n            order: 99,\n            injection: `\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    `\n        }\n    }\n};\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport project from \"../project/project.js\";\nconst vs = `\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n`;\nexport default {\n    name: 'project32',\n    dependencies: [project],\n    vs\n};\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME arc-layer-vertex-shader\nin vec3 positions;\nin vec4 instanceSourceColors;\nin vec4 instanceTargetColors;\nin vec3 instanceSourcePositions;\nin vec3 instanceSourcePositions64Low;\nin vec3 instanceTargetPositions;\nin vec3 instanceTargetPositions64Low;\nin vec3 instancePickingColors;\nin float instanceWidths;\nin float instanceHeights;\nin float instanceTilts;\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\nout vec4 vColor;\nout vec2 uv;\nout float isValid;\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\nfloat deltaZ = targetZ - sourceZ;\nfloat dh = distance * instanceHeights;\nif (dh == 0.0) {\nreturn sourceZ + deltaZ * ratio;\n}\nfloat unitZ = deltaZ / dh;\nfloat p2 = unitZ * unitZ + 1.0;\nfloat dir = step(deltaZ, 0.0);\nfloat z0 = mix(sourceZ, targetZ, dir);\nfloat r = mix(ratio, 1.0 - ratio, dir);\nreturn sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\nvec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\ndir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\nreturn dir_screenspace * offset_direction * width / 2.0;\n}\nfloat getSegmentRatio(float index) {\nreturn smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\nfloat distance = length(source.xy - target.xy);\nfloat z = paraboloid(distance, source.z, target.z, segmentRatio);\nfloat tiltAngle = radians(instanceTilts);\nvec2 tiltDirection = normalize(target.xy - source.xy);\nvec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\nreturn vec3(\nmix(source.xy, target.xy, segmentRatio) + tilt,\nz * cos(tiltAngle)\n);\n}\nfloat getAngularDist (vec2 source, vec2 target) {\nvec2 sourceRadians = radians(source);\nvec2 targetRadians = radians(target);\nvec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\nvec2 shd_sq = sin_half_delta * sin_half_delta;\nfloat a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\nreturn 2.0 * asin(sqrt(a));\n}\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\nvec2 lngLat;\nif(abs(angularDist - PI) < 0.001) {\nlngLat = (1.0 - t) * source.xy + t * target.xy;\n} else {\nfloat a = sin((1.0 - t) * angularDist);\nfloat b = sin(t * angularDist);\nvec3 p = source3D.yxz * a + target3D.yxz * b;\nlngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n}\nfloat z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\nreturn vec3(lngLat, z);\n}\nvoid main(void) {\ngeometry.worldPosition = instanceSourcePositions;\ngeometry.worldPositionAlt = instanceTargetPositions;\nfloat segmentIndex = positions.x;\nfloat segmentRatio = getSegmentRatio(segmentIndex);\nfloat prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\nfloat nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\nfloat indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\nisValid = 1.0;\nuv = vec2(segmentRatio, positions.y);\ngeometry.uv = uv;\ngeometry.pickingColor = instancePickingColors;\nvec4 curr;\nvec4 next;\nvec3 source;\nvec3 target;\nif ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nsource = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\ntarget = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\nfloat angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\nvec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\nvec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\nvec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\nif (abs(currPos.x - prevPos.x) > 180.0) {\nindexDir = -1.0;\nisValid = 0.0;\n} else if (abs(currPos.x - nextPos.x) > 180.0) {\nindexDir = 1.0;\nisValid = 0.0;\n}\nnextPos = indexDir < 0.0 ? prevPos : nextPos;\nnextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\nif (isValid == 0.0) {\nnextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\nfloat t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\ncurrPos = mix(currPos, nextPos, t);\nsegmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n}\nvec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\nvec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\ncurr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\nnext = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n} else {\nvec3 source_world = instanceSourcePositions;\nvec3 target_world = instanceTargetPositions;\nif (useShortestPath) {\nsource_world.x = mod(source_world.x + 180., 360.0) - 180.;\ntarget_world.x = mod(target_world.x + 180., 360.0) - 180.;\nfloat deltaLng = target_world.x - source_world.x;\nif (deltaLng > 180.) target_world.x -= 360.;\nif (deltaLng < -180.) source_world.x -= 360.;\n}\nsource = project_position(source_world, instanceSourcePositions64Low);\ntarget = project_position(target_world, instanceTargetPositions64Low);\nfloat antiMeridianX = 0.0;\nif (useShortestPath) {\nif (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\nantiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n}\nfloat thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\nif (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\nisValid = 0.0;\nindexDir = sign(segmentRatio - thresholdRatio);\nsegmentRatio = thresholdRatio;\n}\n}\nnextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\nvec3 currPos = interpolateFlat(source, target, segmentRatio);\nvec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\nif (useShortestPath) {\nif (nextPos.x < antiMeridianX) {\ncurrPos.x += TILE_SIZE;\nnextPos.x += TILE_SIZE;\n}\n}\ncurr = project_common_position_to_clipspace(vec4(currPos, 1.0));\nnext = project_common_position_to_clipspace(vec4(nextPos, 1.0));\ngeometry.position = vec4(currPos, 1.0);\n}\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceWidths * widthScale, widthUnits),\nwidthMinPixels, widthMaxPixels\n);\nvec3 offset = vec3(\ngetExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\nDECKGL_FILTER_GL_POSITION(curr, geometry);\ngl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\nvec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\nvColor = vec4(color.rgb, color.a * opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { Geometry } from '@luma.gl/engine';\nimport { Model } from '@luma.gl/engine';\nimport vs from \"./arc-layer-vertex.glsl.js\";\nimport fs from \"./arc-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n    getSourcePosition: { type: 'accessor', value: (x) => x.sourcePosition },\n    getTargetPosition: { type: 'accessor', value: (x) => x.targetPosition },\n    getSourceColor: { type: 'accessor', value: DEFAULT_COLOR },\n    getTargetColor: { type: 'accessor', value: DEFAULT_COLOR },\n    getWidth: { type: 'accessor', value: 1 },\n    getHeight: { type: 'accessor', value: 1 },\n    getTilt: { type: 'accessor', value: 0 },\n    greatCircle: false,\n    numSegments: { type: 'number', value: 50, min: 1 },\n    widthUnits: 'pixels',\n    widthScale: { type: 'number', value: 1, min: 0 },\n    widthMinPixels: { type: 'number', value: 0, min: 0 },\n    widthMaxPixels: { type: 'number', value: Number.MAX_SAFE_INTEGER, min: 0 }\n};\n/** Render raised arcs joining pairs of source and target coordinates. */\nclass ArcLayer extends Layer {\n    getBounds() {\n        return this.getAttributeManager()?.getBounds([\n            'instanceSourcePositions',\n            'instanceTargetPositions'\n        ]);\n    }\n    getShaders() {\n        return super.getShaders({ vs, fs, modules: [project32, picking] }); // 'project' module added by default.\n    }\n    // This layer has its own wrapLongitude logic\n    get wrapLongitude() {\n        return false;\n    }\n    initializeState() {\n        const attributeManager = this.getAttributeManager();\n        /* eslint-disable max-len */\n        attributeManager.addInstanced({\n            instanceSourcePositions: {\n                size: 3,\n                type: 'float64',\n                fp64: this.use64bitPositions(),\n                transition: true,\n                accessor: 'getSourcePosition'\n            },\n            instanceTargetPositions: {\n                size: 3,\n                type: 'float64',\n                fp64: this.use64bitPositions(),\n                transition: true,\n                accessor: 'getTargetPosition'\n            },\n            instanceSourceColors: {\n                size: this.props.colorFormat.length,\n                type: 'unorm8',\n                transition: true,\n                accessor: 'getSourceColor',\n                defaultValue: DEFAULT_COLOR\n            },\n            instanceTargetColors: {\n                size: this.props.colorFormat.length,\n                type: 'unorm8',\n                transition: true,\n                accessor: 'getTargetColor',\n                defaultValue: DEFAULT_COLOR\n            },\n            instanceWidths: {\n                size: 1,\n                transition: true,\n                accessor: 'getWidth',\n                defaultValue: 1\n            },\n            instanceHeights: {\n                size: 1,\n                transition: true,\n                accessor: 'getHeight',\n                defaultValue: 1\n            },\n            instanceTilts: {\n                size: 1,\n                transition: true,\n                accessor: 'getTilt',\n                defaultValue: 0\n            }\n        });\n        /* eslint-enable max-len */\n    }\n    updateState(opts) {\n        super.updateState(opts);\n        const { props, oldProps, changeFlags } = opts;\n        // Re-generate model if geometry changed\n        if (changeFlags.extensionsChanged || props.numSegments !== oldProps.numSegments) {\n            this.state.model?.destroy();\n            this.state.model = this._getModel();\n            this.getAttributeManager().invalidateAll();\n        }\n    }\n    draw({ uniforms }) {\n        const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, greatCircle, wrapLongitude } = this.props;\n        const model = this.state.model;\n        model.setUniforms(uniforms);\n        model.setUniforms({\n            greatCircle,\n            widthUnits: UNIT[widthUnits],\n            widthScale,\n            widthMinPixels,\n            widthMaxPixels,\n            useShortestPath: wrapLongitude\n        });\n        model.draw(this.context.renderPass);\n    }\n    _getModel() {\n        const { numSegments } = this.props;\n        let positions = [];\n        /*\n         *  (0, -1)-------------_(1, -1)\n         *       |          _,-\"  |\n         *       o      _,-\"      o\n         *       |  _,-\"          |\n         *   (0, 1)\"-------------(1, 1)\n         */\n        for (let i = 0; i < numSegments; i++) {\n            positions = positions.concat([i, 1, 0, i, -1, 0]);\n        }\n        const model = new Model(this.context.device, {\n            ...this.getShaders(),\n            id: this.props.id,\n            bufferLayout: this.getAttributeManager().getBufferLayouts(),\n            geometry: new Geometry({\n                topology: 'triangle-strip',\n                attributes: {\n                    positions: { size: 3, value: new Float32Array(positions) }\n                }\n            }),\n            isInstanced: true\n        });\n        model.setUniforms({ numSegments });\n        return model;\n    }\n}\nArcLayer.layerName = 'ArcLayer';\nArcLayer.defaultProps = defaultProps;\nexport default ArcLayer;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME arc-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 uv;\nin float isValid;\nout vec4 fragColor;\nvoid main(void) {\nif (isValid == 0.0) {\ndiscard;\n}\nfragColor = vColor;\ngeometry.uv = uv;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME scatterplot-layer-vertex-shader\nin vec3 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceRadius;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\nout vec4 vFillColor;\nout vec4 vLineColor;\nout vec2 unitPosition;\nout float innerUnitRadius;\nout float outerRadiusPixels;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nouterRadiusPixels = clamp(\nproject_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\nradiusMinPixels, radiusMaxPixels\n);\nfloat lineWidthPixels = clamp(\nproject_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\nlineWidthMinPixels, lineWidthMaxPixels\n);\nouterRadiusPixels += stroked * lineWidthPixels / 2.0;\nfloat edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\nunitPosition = edgePadding * positions.xy;\ngeometry.uv = unitPosition;\ngeometry.pickingColor = instancePickingColors;\ninnerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\nif (billboard) {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = edgePadding * positions * outerRadiusPixels;\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\nDECKGL_FILTER_COLOR(vFillColor, geometry);\nvLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\nDECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { Geometry } from '@luma.gl/engine';\nimport { Model } from '@luma.gl/engine';\nimport vs from \"./scatterplot-layer-vertex.glsl.js\";\nimport fs from \"./scatterplot-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n    radiusUnits: 'meters',\n    radiusScale: { type: 'number', min: 0, value: 1 },\n    radiusMinPixels: { type: 'number', min: 0, value: 0 }, //  min point radius in pixels\n    radiusMaxPixels: { type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER }, // max point radius in pixels\n    lineWidthUnits: 'meters',\n    lineWidthScale: { type: 'number', min: 0, value: 1 },\n    lineWidthMinPixels: { type: 'number', min: 0, value: 0 },\n    lineWidthMaxPixels: { type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER },\n    stroked: false,\n    filled: true,\n    billboard: false,\n    antialiasing: true,\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    getRadius: { type: 'accessor', value: 1 },\n    getFillColor: { type: 'accessor', value: DEFAULT_COLOR },\n    getLineColor: { type: 'accessor', value: DEFAULT_COLOR },\n    getLineWidth: { type: 'accessor', value: 1 },\n    // deprecated\n    strokeWidth: { deprecatedFor: 'getLineWidth' },\n    outline: { deprecatedFor: 'stroked' },\n    getColor: { deprecatedFor: ['getFillColor', 'getLineColor'] }\n};\n/** Render circles at given coordinates. */\nclass ScatterplotLayer extends Layer {\n    getShaders() {\n        return super.getShaders({ vs, fs, modules: [project32, picking] });\n    }\n    initializeState() {\n        this.getAttributeManager().addInstanced({\n            instancePositions: {\n                size: 3,\n                type: 'float64',\n                fp64: this.use64bitPositions(),\n                transition: true,\n                accessor: 'getPosition'\n            },\n            instanceRadius: {\n                size: 1,\n                transition: true,\n                accessor: 'getRadius',\n                defaultValue: 1\n            },\n            instanceFillColors: {\n                size: this.props.colorFormat.length,\n                transition: true,\n                type: 'unorm8',\n                accessor: 'getFillColor',\n                defaultValue: [0, 0, 0, 255]\n            },\n            instanceLineColors: {\n                size: this.props.colorFormat.length,\n                transition: true,\n                type: 'unorm8',\n                accessor: 'getLineColor',\n                defaultValue: [0, 0, 0, 255]\n            },\n            instanceLineWidths: {\n                size: 1,\n                transition: true,\n                accessor: 'getLineWidth',\n                defaultValue: 1\n            }\n        });\n    }\n    updateState(params) {\n        super.updateState(params);\n        if (params.changeFlags.extensionsChanged) {\n            this.state.model?.destroy();\n            this.state.model = this._getModel();\n            this.getAttributeManager().invalidateAll();\n        }\n    }\n    draw({ uniforms }) {\n        const { radiusUnits, radiusScale, radiusMinPixels, radiusMaxPixels, stroked, filled, billboard, antialiasing, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels } = this.props;\n        const model = this.state.model;\n        model.setUniforms(uniforms);\n        model.setUniforms({\n            stroked: stroked ? 1 : 0,\n            filled,\n            billboard,\n            antialiasing,\n            radiusUnits: UNIT[radiusUnits],\n            radiusScale,\n            radiusMinPixels,\n            radiusMaxPixels,\n            lineWidthUnits: UNIT[lineWidthUnits],\n            lineWidthScale,\n            lineWidthMinPixels,\n            lineWidthMaxPixels\n        });\n        model.draw(this.context.renderPass);\n    }\n    _getModel() {\n        // a square that minimally cover the unit circle\n        const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];\n        return new Model(this.context.device, {\n            ...this.getShaders(),\n            id: this.props.id,\n            bufferLayout: this.getAttributeManager().getBufferLayouts(),\n            geometry: new Geometry({\n                topology: 'triangle-strip',\n                attributes: {\n                    positions: { size: 3, value: new Float32Array(positions) }\n                }\n            }),\n            isInstanced: true\n        });\n    }\n}\nScatterplotLayer.defaultProps = defaultProps;\nScatterplotLayer.layerName = 'ScatterplotLayer';\nexport default ScatterplotLayer;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME scatterplot-layer-fragment-shader\nprecision highp float;\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\nin vec4 vFillColor;\nin vec4 vLineColor;\nin vec2 unitPosition;\nin float innerUnitRadius;\nin float outerRadiusPixels;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = unitPosition;\nfloat distToCenter = length(unitPosition) * outerRadiusPixels;\nfloat inCircle = antialiasing ?\nsmoothedge(distToCenter, outerRadiusPixels) :\nstep(distToCenter, outerRadiusPixels);\nif (inCircle == 0.0) {\ndiscard;\n}\nif (stroked > 0.5) {\nfloat isLine = antialiasing ?\nsmoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\nstep(innerUnitRadius * outerRadiusPixels, distToCenter);\nif (filled) {\nfragColor = mix(vFillColor, vLineColor, isLine);\n} else {\nif (isLine == 0.0) {\ndiscard;\n}\nfragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n}\n} else if (!filled) {\ndiscard;\n} else {\nfragColor = vFillColor;\n}\nfragColor.a *= inCircle;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function getDataTypeFromTypedArray(arrayOrType) {\n    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n    switch (type) {\n        case Float32Array:\n            return 'float32';\n        case Uint16Array:\n            return 'uint16';\n        case Uint32Array:\n            return 'uint32';\n        case Uint8Array:\n        case Uint8ClampedArray:\n            return 'uint8';\n        case Int8Array:\n            return 'sint8';\n        case Int16Array:\n            return 'sint16';\n        case Int32Array:\n            return 'sint32';\n        default:\n            // Failed to deduce data type from typed array\n            throw new Error(type.constructor.name);\n    }\n}\nexport function getTypedArrayFromDataType(dataType) {\n    switch (dataType) {\n        case 'float32':\n            return Float32Array;\n        case 'uint32':\n            return Uint32Array;\n        case 'sint32':\n            return Int32Array;\n        case 'uint16':\n        case 'unorm16':\n            return Uint16Array;\n        case 'sint16':\n        case 'snorm16':\n            return Int16Array;\n        case 'uint8':\n        case 'unorm8':\n            return Uint8Array;\n        case 'sint8':\n        case 'snorm8':\n            return Int8Array;\n        default:\n            // Failed to deduce typed array from data type\n            throw new Error(dataType);\n    }\n}\n/** Get the vertex format for an attribute with TypedArray and size */\nexport function getVertexFormatFromAttribute(typedArray, size, normalized) {\n    if (!size || size > 4) {\n        throw new Error(`size ${size}`);\n    }\n    const components = size;\n    let dataType = getDataTypeFromTypedArray(typedArray);\n    // TODO - Special cases for WebGL (not supported on WebGPU), overrides the check below\n    if (dataType === 'uint8' && normalized && components === 1) {\n        return 'unorm8-webgl';\n    }\n    if (dataType === 'uint8' && normalized && components === 3) {\n        return 'unorm8x3-webgl';\n    }\n    if (dataType === 'uint8' || dataType === 'sint8') {\n        if (components === 1 || components === 3) {\n            // WebGPU 8 bit formats must be aligned to 16 bit boundaries');\n            throw new Error(`size: ${size}`);\n        }\n        if (normalized) {\n            dataType = dataType.replace('int', 'norm');\n        }\n        return `${dataType}x${components}`;\n    }\n    if (dataType === 'uint16' || dataType === 'sint16') {\n        if (components === 1 || components === 3) {\n            // WebGPU 16 bit formats must be aligned to 32 bit boundaries\n            throw new Error(`size: ${size}`);\n        }\n        if (normalized) {\n            dataType = dataType.replace('int', 'norm');\n        }\n        return `${dataType}x${components}`;\n    }\n    if (components === 1) {\n        return dataType;\n    }\n    return `${dataType}x${components}`;\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { uid, assert } from '@luma.gl/core';\nexport class Geometry {\n    id;\n    /** Determines how vertices are read from the 'vertex' attributes */\n    topology;\n    vertexCount;\n    indices;\n    attributes;\n    userData = {};\n    constructor(props) {\n        const { attributes = {}, indices = null, vertexCount = null } = props;\n        this.id = props.id || uid('geometry');\n        this.topology = props.topology;\n        if (indices) {\n            this.indices = ArrayBuffer.isView(indices) ? { value: indices, size: 1 } : indices;\n        }\n        // @ts-expect-error\n        this.attributes = {};\n        for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n            // Wrap \"unwrapped\" arrays and try to autodetect their type\n            const attribute = ArrayBuffer.isView(attributeValue)\n                ? { value: attributeValue }\n                : attributeValue;\n            assert(ArrayBuffer.isView(attribute.value), `${this._print(attributeName)}: must be typed array or object with value as typed array`);\n            if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n                attribute.size = 3;\n            }\n            // Move indices to separate field\n            if (attributeName === 'indices') {\n                assert(!this.indices);\n                this.indices = attribute;\n            }\n            else {\n                this.attributes[attributeName] = attribute;\n            }\n        }\n        if (this.indices && this.indices.isIndexed !== undefined) {\n            this.indices = Object.assign({}, this.indices);\n            delete this.indices.isIndexed;\n        }\n        this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n    }\n    getVertexCount() {\n        return this.vertexCount;\n    }\n    /**\n     * Return an object with all attributes plus indices added as a field.\n     * TODO Geometry types are a mess\n     */\n    getAttributes() {\n        return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;\n    }\n    // PRIVATE\n    _print(attributeName) {\n        return `Geometry ${this.id} attribute ${attributeName}`;\n    }\n    /**\n     * GeometryAttribute\n     * value: typed array\n     * type: indices, vertices, uvs\n     * size: elements per vertex\n     * target: WebGL buffer type (string or constant)\n     *\n     * @param attributes\n     * @param indices\n     * @returns\n     */\n    _setAttributes(attributes, indices) {\n        return this;\n    }\n    _calculateVertexCount(attributes, indices) {\n        if (indices) {\n            return indices.value.length;\n        }\n        let vertexCount = Infinity;\n        for (const attribute of Object.values(attributes)) {\n            const { value, size, constant } = attribute;\n            if (!constant && value && size >= 1) {\n                vertexCount = Math.min(vertexCount, value.length / size);\n            }\n        }\n        assert(Number.isFinite(vertexCount));\n        return vertexCount;\n    }\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { arrayEqual, arrayCopy } from \"../../utils/array-equal.js\";\n/**\n * A uniform block holds values of the of uniform values for one uniform block / buffer.\n * It also does some book keeping on what has changed, to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformBlock {\n    name;\n    uniforms = {};\n    modifiedUniforms = {};\n    modified = true;\n    bindingLayout = {};\n    needsRedraw = 'initialized';\n    constructor(props) {\n        this.name = props?.name;\n        // TODO - Extract uniform layout from the shaderLayout object\n        if (props?.name && props?.shaderLayout) {\n            const binding = props?.shaderLayout.bindings?.find(binding => binding.type === 'uniform' && binding.name === props?.name);\n            if (!binding) {\n                throw new Error(props?.name);\n            }\n            const uniformBlock = binding;\n            for (const uniform of uniformBlock.uniforms || []) {\n                this.bindingLayout[uniform.name] = uniform;\n            }\n        }\n    }\n    /** Set a map of uniforms */\n    setUniforms(uniforms) {\n        for (const [key, value] of Object.entries(uniforms)) {\n            this._setUniform(key, value);\n            if (!this.needsRedraw) {\n                this.setNeedsRedraw(`${this.name}.${key}=${value}`);\n            }\n        }\n    }\n    setNeedsRedraw(reason) {\n        this.needsRedraw = this.needsRedraw || reason;\n    }\n    /** Returns all uniforms */\n    getAllUniforms() {\n        // @ts-expect-error\n        this.modifiedUniforms = {};\n        this.needsRedraw = false;\n        return (this.uniforms || {});\n    }\n    /** Set a single uniform */\n    _setUniform(key, value) {\n        if (arrayEqual(this.uniforms[key], value)) {\n            return;\n        }\n        this.uniforms[key] = arrayCopy(value);\n        this.modifiedUniforms[key] = true;\n        this.modified = true;\n    }\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isNumberArray } from \"./is-array.js\";\n/** Test if two arrays are deep equal, with a length limit that defaults to 16 */\nexport function arrayEqual(a, b, limit = 16) {\n    if (a !== b) {\n        return false;\n    }\n    const arrayA = isNumberArray(a);\n    if (!arrayA) {\n        return false;\n    }\n    const arrayB = isNumberArray(b);\n    if (arrayB && arrayA.length === arrayB.length) {\n        for (let i = 0; i < arrayA.length; ++i) {\n            if (arrayB[i] !== arrayA[i]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/** Copy a value */\nexport function arrayCopy(a) {\n    const numberArray = isNumberArray(a);\n    if (numberArray) {\n        return numberArray.slice();\n    }\n    return a;\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from \"../../utils/assert.js\";\nconst UNIFORM_FORMATS = {\n    f32: { type: 'f32', components: 1 },\n    i32: { type: 'i32', components: 1 },\n    u32: { type: 'u32', components: 1 },\n    // 'bool-webgl': {type: 'bool-webgl', components: 1},\n    'vec2<f32>': { type: 'f32', components: 2 },\n    'vec3<f32>': { type: 'f32', components: 3 },\n    'vec4<f32>': { type: 'f32', components: 4 },\n    'vec2<i32>': { type: 'i32', components: 2 },\n    'vec3<i32>': { type: 'i32', components: 3 },\n    'vec4<i32>': { type: 'i32', components: 4 },\n    'vec2<u32>': { type: 'u32', components: 2 },\n    'vec3<u32>': { type: 'u32', components: 3 },\n    'vec4<u32>': { type: 'u32', components: 4 },\n    'mat2x2<f32>': { type: 'f32', components: 4 },\n    'mat2x3<f32>': { type: 'f32', components: 6 },\n    'mat2x4<f32>': { type: 'f32', components: 8 },\n    'mat3x2<f32>': { type: 'f32', components: 6 },\n    'mat3x3<f32>': { type: 'f32', components: 9 },\n    'mat3x4<f32>': { type: 'f32', components: 12 },\n    'mat4x2<f32>': { type: 'f32', components: 8 },\n    'mat4x3<f32>': { type: 'f32', components: 12 },\n    'mat4x4<f32>': { type: 'f32', components: 16 }\n};\n/** Split a uniform type string into type and components */\nexport function decodeShaderUniformType(format) {\n    const decoded = UNIFORM_FORMATS[format];\n    assert(format);\n    return decoded;\n}\n/** Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes) */\nexport function alignTo(size, count) {\n    // prettier-ignore\n    switch (count) {\n        case 1: return size; // Pad upwards to even multiple of 2\n        case 2: return size + (size % 2); // Pad upwards to even multiple of 2\n        default: return size + ((4 - (size % 4)) % 4); // Pad upwards to even multiple of 4\n    }\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { decodeShaderUniformType, alignTo } from \"../../adapter/type-utils/decode-shader-types.js\";\nimport { getScratchArrayBuffer } from \"../../utils/array-utils-flat.js\";\nimport { isNumberArray } from \"../../utils/is-array.js\";\nimport { log } from \"../../utils/log.js\";\n/**\n * Smallest buffer size that can be used for uniform buffers.\n * TODO - does this depend on device?\n */\nconst minBufferSize = 1024;\n/**\n * Std140 layout for uniform buffers\n * Supports manual listing of uniforms\n */\nexport class UniformBufferLayout {\n    layout = {};\n    /** number of bytes needed for buffer allocation */\n    byteLength;\n    /** Create a new UniformBufferLayout given a map of attributes. */\n    constructor(uniformTypes) {\n        /** number of 4 byte slots taken */\n        let size = 0;\n        // Add layout (type, size and offset) definitions for each uniform in the layout\n        for (const [key, uniformType] of Object.entries(uniformTypes)) {\n            const typeAndComponents = decodeShaderUniformType(uniformType);\n            const { type, components: count } = typeAndComponents;\n            // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n            size = alignTo(size, count);\n            // Use the aligned size as the offset of the current uniform.\n            const offset = size;\n            // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n            size += count;\n            this.layout[key] = { type, size: count, offset };\n        }\n        size += (4 - (size % 4)) % 4;\n        const actualByteLength = size * 4;\n        this.byteLength = Math.max(actualByteLength, minBufferSize);\n    }\n    /** Get the data for the complete buffer */\n    getData(uniformValues) {\n        const bufferSize = Math.max(this.byteLength, minBufferSize);\n        // Allocate three typed arrays pointing at same memory\n        const arrayBuffer = getScratchArrayBuffer(bufferSize);\n        const typedArrays = {\n            i32: new Int32Array(arrayBuffer),\n            u32: new Uint32Array(arrayBuffer),\n            f32: new Float32Array(arrayBuffer),\n            // TODO not implemented\n            f16: new Uint16Array(arrayBuffer)\n        };\n        // TODO is this needed?\n        // typedArrays.i32.fill(0);\n        for (const [name, value] of Object.entries(uniformValues)) {\n            const uniformLayout = this.layout[name];\n            if (!uniformLayout) {\n                log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();\n                // eslint-disable-next-line no-continue\n                continue;\n            }\n            const { type, size, offset } = uniformLayout;\n            const typedArray = typedArrays[type];\n            if (size === 1) {\n                if (typeof value !== 'number' && typeof value !== 'boolean') {\n                    log.warn(`Supplied value for single component uniform ${name} is not a number: ${value}`)();\n                    // eslint-disable-next-line no-continue\n                    continue;\n                }\n                // single value -> just set it\n                typedArray[offset] = Number(value);\n            }\n            else {\n                const numericArray = isNumberArray(value);\n                if (!numericArray) {\n                    log.warn(`Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`)();\n                    // eslint-disable-next-line no-continue\n                    continue;\n                }\n                // vector/matrix -> copy the supplied (typed) array, starting from offset\n                // TODO: we should limit or check size in case the supplied data overflows\n                typedArray.set(numericArray, offset);\n            }\n        }\n        return new Uint8Array(arrayBuffer);\n    }\n    /** Does this layout have a field with specified name */\n    has(name) {\n        return Boolean(this.layout[name]);\n    }\n    /** Get offset and size for a field with specified name */\n    get(name) {\n        const layout = this.layout[name];\n        return layout;\n    }\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer } from \"../../adapter/resources/buffer.js\";\nimport { UniformBlock } from \"./uniform-block.js\";\nimport { UniformBufferLayout } from \"./uniform-buffer-layout.js\";\nimport { log } from \"../../utils/log.js\";\n/**\n * A uniform store holds a uniform values for one or more uniform blocks,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformStore {\n    /** Stores the uniform values for each uniform block */\n    uniformBlocks = new Map();\n    /** Can generate data for a uniform buffer for each block from data */\n    uniformBufferLayouts = new Map();\n    /** Actual buffer for the blocks */\n    uniformBuffers = new Map();\n    /**\n     * Create a new UniformStore instance\n     * @param blocks\n     */\n    constructor(blocks) {\n        for (const [bufferName, block] of Object.entries(blocks)) {\n            const uniformBufferName = bufferName;\n            // Create a layout object to help us generate correctly formatted binary uniform buffers\n            const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});\n            this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);\n            // Create a Uniform block to store the uniforms for each buffer.\n            const uniformBlock = new UniformBlock({ name: bufferName });\n            uniformBlock.setUniforms(block.defaultUniforms || {});\n            this.uniformBlocks.set(uniformBufferName, uniformBlock);\n        }\n    }\n    /** Destroy any managed uniform buffers */\n    destroy() {\n        for (const uniformBuffer of this.uniformBuffers.values()) {\n            uniformBuffer.destroy();\n        }\n    }\n    /**\n     * Set uniforms\n     * Makes all properties partial\n     */\n    setUniforms(uniforms) {\n        for (const [blockName, uniformValues] of Object.entries(uniforms)) {\n            this.uniformBlocks.get(blockName).setUniforms(uniformValues);\n            // We leverage logging in updateUniformBuffers(), even though slightly less efficient\n            // this.updateUniformBuffer(blockName);\n        }\n        this.updateUniformBuffers();\n    }\n    /** Get the required minimum length of the uniform buffer */\n    getUniformBufferByteLength(uniformBufferName) {\n        return this.uniformBufferLayouts.get(uniformBufferName).byteLength;\n    }\n    /** Get formatted binary memory that can be uploaded to a buffer */\n    getUniformBufferData(uniformBufferName) {\n        const uniformValues = this.uniformBlocks.get(uniformBufferName).getAllUniforms();\n        return this.uniformBufferLayouts.get(uniformBufferName).getData(uniformValues);\n    }\n    /**\n     * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)\n     * The new buffer is initialized with current / supplied values\n     */\n    createUniformBuffer(device, uniformBufferName, uniforms) {\n        if (uniforms) {\n            this.setUniforms(uniforms);\n        }\n        const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n        const uniformBuffer = device.createBuffer({\n            usage: Buffer.UNIFORM | Buffer.COPY_DST,\n            byteLength\n        });\n        // Note that this clears the needs redraw flag\n        const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n        uniformBuffer.write(uniformBufferData);\n        return uniformBuffer;\n    }\n    /** Get the managed uniform buffer. \"managed\" resources are destroyed when the uniformStore is destroyed. */\n    getManagedUniformBuffer(device, uniformBufferName) {\n        if (!this.uniformBuffers.get(uniformBufferName)) {\n            const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n            const uniformBuffer = device.createBuffer({\n                usage: Buffer.UNIFORM | Buffer.COPY_DST,\n                byteLength\n            });\n            this.uniformBuffers.set(uniformBufferName, uniformBuffer);\n        }\n        // this.updateUniformBuffers();\n        return this.uniformBuffers.get(uniformBufferName);\n    }\n    /** Updates all uniform buffers where values have changed */\n    updateUniformBuffers() {\n        let reason = false;\n        for (const uniformBufferName of this.uniformBlocks.keys()) {\n            const bufferReason = this.updateUniformBuffer(uniformBufferName);\n            reason ||= bufferReason;\n        }\n        if (reason) {\n            log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();\n        }\n        return reason;\n    }\n    /** Update one uniform buffer. Only updates if values have changed */\n    updateUniformBuffer(uniformBufferName) {\n        const uniformBlock = this.uniformBlocks.get(uniformBufferName);\n        const uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n        let reason = false;\n        if (uniformBuffer && uniformBlock.needsRedraw) {\n            reason ||= uniformBlock.needsRedraw;\n            // This clears the needs redraw flag\n            const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n            const uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n            uniformBuffer.write(uniformBufferData);\n            // logging - TODO - don't query the values unnecessarily\n            const uniformValues = this.uniformBlocks.get(uniformBufferName).getAllUniforms();\n            log.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();\n        }\n        return reason;\n    }\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Fast partial deep equal for prop.\n *\n * @param a Prop\n * @param b Prop to compare against `a`\n * @param depth Depth to which to recurse in nested Objects/Arrays. Use 0 (default) for shallow comparison, -1 for infinite depth\n */\n/* eslint-disable complexity */\nexport function deepEqual(a, b, depth) {\n    if (a === b) {\n        return true;\n    }\n    if (!depth || !a || !b) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b) || a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (!deepEqual(a[i], b[i], depth - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (Array.isArray(b)) {\n        return false;\n    }\n    if (typeof a === 'object' && typeof b === 'object') {\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        if (aKeys.length !== bKeys.length) {\n            return false;\n        }\n        for (const key of aKeys) {\n            if (!b.hasOwnProperty(key)) {\n                return false;\n            }\n            if (!deepEqual(a[key], b[key], depth - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n","class ParseContext {\n    constructor() {\n        this.constants = new Map();\n        this.aliases = new Map();\n        this.structs = new Map();\n    }\n}\n/**\n * @class Node\n * @category AST\n * Base class for AST nodes parsed from a WGSL shader.\n */\nclass Node {\n    constructor() { }\n    get isAstNode() {\n        return true;\n    }\n    get astNodeType() {\n        return \"\";\n    }\n    evaluate(context) {\n        throw new Error(\"Cannot evaluate node\");\n    }\n    evaluateString(context) {\n        return this.evaluate(context).toString();\n    }\n    search(callback) { }\n    searchBlock(block, callback) {\n        if (block) {\n            callback(_BlockStart.instance);\n            for (const node of block) {\n                if (node instanceof Array) {\n                    this.searchBlock(node, callback);\n                }\n                else {\n                    node.search(callback);\n                }\n            }\n            callback(_BlockEnd.instance);\n        }\n    }\n}\n// For internal use only\nclass _BlockStart extends Node {\n}\n_BlockStart.instance = new _BlockStart();\n// For internal use only\nclass _BlockEnd extends Node {\n}\n_BlockEnd.instance = new _BlockEnd();\n/**\n * @class Statement\n * @extends Node\n * @category AST\n */\nclass Statement extends Node {\n    constructor() {\n        super();\n    }\n}\n/**\n * @class Function\n * @extends Statement\n * @category AST\n */\nclass Function extends Statement {\n    constructor(name, args, returnType, body, startLine, endLine) {\n        super();\n        this.calls = new Set();\n        this.name = name;\n        this.args = args;\n        this.returnType = returnType;\n        this.body = body;\n        this.startLine = startLine;\n        this.endLine = endLine;\n    }\n    get astNodeType() {\n        return \"function\";\n    }\n    search(callback) {\n        this.searchBlock(this.body, callback);\n    }\n}\n/**\n * @class StaticAssert\n * @extends Statement\n * @category AST\n */\nclass StaticAssert extends Statement {\n    constructor(expression) {\n        super();\n        this.expression = expression;\n    }\n    get astNodeType() {\n        return \"staticAssert\";\n    }\n    search(callback) {\n        this.expression.search(callback);\n    }\n}\n/**\n * @class While\n * @extends Statement\n * @category AST\n */\nclass While extends Statement {\n    constructor(condition, body) {\n        super();\n        this.condition = condition;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"while\";\n    }\n    search(callback) {\n        this.condition.search(callback);\n        this.searchBlock(this.body, callback);\n    }\n}\n/**\n * @class Continuing\n * @extends Statement\n * @category AST\n */\nclass Continuing extends Statement {\n    constructor(body) {\n        super();\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"continuing\";\n    }\n    search(callback) {\n        this.searchBlock(this.body, callback);\n    }\n}\n/**\n * @class For\n * @extends Statement\n * @category AST\n */\nclass For extends Statement {\n    constructor(init, condition, increment, body) {\n        super();\n        this.init = init;\n        this.condition = condition;\n        this.increment = increment;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"for\";\n    }\n    search(callback) {\n        var _a, _b, _c;\n        (_a = this.init) === null || _a === void 0 ? void 0 : _a.search(callback);\n        (_b = this.condition) === null || _b === void 0 ? void 0 : _b.search(callback);\n        (_c = this.increment) === null || _c === void 0 ? void 0 : _c.search(callback);\n        this.searchBlock(this.body, callback);\n    }\n}\n/**\n * @class Var\n * @extends Statement\n * @category AST\n */\nclass Var extends Statement {\n    constructor(name, type, storage, access, value) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.storage = storage;\n        this.access = access;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"var\";\n    }\n    search(callback) {\n        var _a;\n        callback(this);\n        (_a = this.value) === null || _a === void 0 ? void 0 : _a.search(callback);\n    }\n}\n/**\n * @class Override\n * @extends Statement\n * @category AST\n */\nclass Override extends Statement {\n    constructor(name, type, value) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"override\";\n    }\n    search(callback) {\n        var _a;\n        (_a = this.value) === null || _a === void 0 ? void 0 : _a.search(callback);\n    }\n}\n/**\n * @class Let\n * @extends Statement\n * @category AST\n */\nclass Let extends Statement {\n    constructor(name, type, storage, access, value) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.storage = storage;\n        this.access = access;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"let\";\n    }\n    search(callback) {\n        var _a;\n        callback(this);\n        (_a = this.value) === null || _a === void 0 ? void 0 : _a.search(callback);\n    }\n}\n/**\n * @class Const\n * @extends Statement\n * @category AST\n */\nclass Const extends Statement {\n    constructor(name, type, storage, access, value) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.storage = storage;\n        this.access = access;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"const\";\n    }\n    evaluate(context) {\n        return this.value.evaluate(context);\n    }\n    search(callback) {\n        var _a;\n        callback(this);\n        (_a = this.value) === null || _a === void 0 ? void 0 : _a.search(callback);\n    }\n}\nvar IncrementOperator;\n(function (IncrementOperator) {\n    IncrementOperator[\"increment\"] = \"++\";\n    IncrementOperator[\"decrement\"] = \"--\";\n})(IncrementOperator || (IncrementOperator = {}));\n(function (IncrementOperator) {\n    function parse(val) {\n        const key = val;\n        if (key == \"parse\")\n            throw new Error(\"Invalid value for IncrementOperator\");\n        return IncrementOperator[key];\n    }\n    IncrementOperator.parse = parse;\n})(IncrementOperator || (IncrementOperator = {}));\n/**\n * @class Increment\n * @extends Statement\n * @category AST\n */\nclass Increment extends Statement {\n    constructor(operator, variable) {\n        super();\n        this.operator = operator;\n        this.variable = variable;\n    }\n    get astNodeType() {\n        return \"increment\";\n    }\n    search(callback) {\n        this.variable.search(callback);\n    }\n}\nvar AssignOperator;\n(function (AssignOperator) {\n    AssignOperator[\"assign\"] = \"=\";\n    AssignOperator[\"addAssign\"] = \"+=\";\n    AssignOperator[\"subtractAssin\"] = \"-=\";\n    AssignOperator[\"multiplyAssign\"] = \"*=\";\n    AssignOperator[\"divideAssign\"] = \"/=\";\n    AssignOperator[\"moduloAssign\"] = \"%=\";\n    AssignOperator[\"andAssign\"] = \"&=\";\n    AssignOperator[\"orAssign\"] = \"|=\";\n    AssignOperator[\"xorAssign\"] = \"^=\";\n    AssignOperator[\"shiftLeftAssign\"] = \"<<=\";\n    AssignOperator[\"shiftRightAssign\"] = \">>=\";\n})(AssignOperator || (AssignOperator = {}));\n(function (AssignOperator) {\n    function parse(val) {\n        const key = val;\n        if (key == \"parse\") {\n            throw new Error(\"Invalid value for AssignOperator\");\n        }\n        //return AssignOperator[key];\n        return key;\n    }\n    AssignOperator.parse = parse;\n})(AssignOperator || (AssignOperator = {}));\n/**\n * @class Assign\n * @extends Statement\n * @category AST\n */\nclass Assign extends Statement {\n    constructor(operator, variable, value) {\n        super();\n        this.operator = operator;\n        this.variable = variable;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"assign\";\n    }\n    search(callback) {\n        this.variable.search(callback);\n        this.value.search(callback);\n    }\n}\n/**\n * @class Call\n * @extends Statement\n * @category AST\n */\nclass Call extends Statement {\n    constructor(name, args) {\n        super();\n        this.name = name;\n        this.args = args;\n    }\n    get astNodeType() {\n        return \"call\";\n    }\n    search(callback) {\n        for (const node of this.args) {\n            node.search(callback);\n        }\n        callback(this);\n    }\n}\n/**\n * @class Loop\n * @extends Statement\n * @category AST\n */\nclass Loop extends Statement {\n    constructor(body, continuing) {\n        super();\n        this.body = body;\n        this.continuing = continuing;\n    }\n    get astNodeType() {\n        return \"loop\";\n    }\n}\n/**\n * @class Switch\n * @extends Statement\n * @category AST\n */\nclass Switch extends Statement {\n    constructor(condition, body) {\n        super();\n        this.condition = condition;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"body\";\n    }\n}\n/**\n * @class If\n * @extends Statement\n * @category AST\n */\nclass If extends Statement {\n    constructor(condition, body, elseif, _else) {\n        super();\n        this.condition = condition;\n        this.body = body;\n        this.elseif = elseif;\n        this.else = _else;\n    }\n    get astNodeType() {\n        return \"if\";\n    }\n    search(callback) {\n        this.condition.search(callback);\n        this.searchBlock(this.body, callback);\n        this.searchBlock(this.elseif, callback);\n        this.searchBlock(this.else, callback);\n    }\n}\n/**\n * @class Return\n * @extends Statement\n * @category AST\n */\nclass Return extends Statement {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"return\";\n    }\n    search(callback) {\n        var _a;\n        (_a = this.value) === null || _a === void 0 ? void 0 : _a.search(callback);\n    }\n}\n/**\n * @class Enable\n * @extends Statement\n * @category AST\n */\nclass Enable extends Statement {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    get astNodeType() {\n        return \"enable\";\n    }\n}\n/**\n * @class Requires\n * @extends Statement\n * @category AST\n */\nclass Requires extends Statement {\n    constructor(extensions) {\n        super();\n        this.extensions = extensions;\n    }\n    get astNodeType() {\n        return \"requires\";\n    }\n}\n/**\n * @class Diagnostic\n * @extends Statement\n * @category AST\n */\nclass Diagnostic extends Statement {\n    constructor(severity, rule) {\n        super();\n        this.severity = severity;\n        this.rule = rule;\n    }\n    get astNodeType() {\n        return \"diagnostic\";\n    }\n}\n/**\n * @class Alias\n * @extends Statement\n * @category AST\n */\nclass Alias extends Statement {\n    constructor(name, type) {\n        super();\n        this.name = name;\n        this.type = type;\n    }\n    get astNodeType() {\n        return \"alias\";\n    }\n}\n/**\n * @class Discard\n * @extends Statement\n * @category AST\n */\nclass Discard extends Statement {\n    constructor() {\n        super();\n    }\n    get astNodeType() {\n        return \"discard\";\n    }\n}\n/**\n * @class Break\n * @extends Statement\n * @category AST\n */\nclass Break extends Statement {\n    constructor() {\n        super();\n    }\n    get astNodeType() {\n        return \"break\";\n    }\n}\n/**\n * @class Continue\n * @extends Statement\n * @category AST\n */\nclass Continue extends Statement {\n    constructor() {\n        super();\n    }\n    get astNodeType() {\n        return \"continue\";\n    }\n}\n/**\n * @class Type\n * @extends Statement\n * @category AST\n */\nclass Type extends Statement {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    get astNodeType() {\n        return \"type\";\n    }\n    get isStruct() {\n        return false;\n    }\n    get isArray() {\n        return false;\n    }\n}\n/**\n * @class StructType\n * @extends Type\n * @category AST\n */\nclass Struct extends Type {\n    constructor(name, members, startLine, endLine) {\n        super(name);\n        this.members = members;\n        this.startLine = startLine;\n        this.endLine = endLine;\n    }\n    get astNodeType() {\n        return \"struct\";\n    }\n    get isStruct() {\n        return true;\n    }\n    /// Return the index of the member with the given name, or -1 if not found.\n    getMemberIndex(name) {\n        for (let i = 0; i < this.members.length; i++) {\n            if (this.members[i].name == name)\n                return i;\n        }\n        return -1;\n    }\n}\n/**\n * @class TemplateType\n * @extends Type\n * @category AST\n */\nclass TemplateType extends Type {\n    constructor(name, format, access) {\n        super(name);\n        this.format = format;\n        this.access = access;\n    }\n    get astNodeType() {\n        return \"template\";\n    }\n}\n/**\n * @class PointerType\n * @extends Type\n * @category AST\n */\nclass PointerType extends Type {\n    constructor(name, storage, type, access) {\n        super(name);\n        this.storage = storage;\n        this.type = type;\n        this.access = access;\n    }\n    get astNodeType() {\n        return \"pointer\";\n    }\n}\n/**\n * @class ArrayType\n * @extends Type\n * @category AST\n */\nclass ArrayType extends Type {\n    constructor(name, attributes, format, count) {\n        super(name);\n        this.attributes = attributes;\n        this.format = format;\n        this.count = count;\n    }\n    get astNodeType() {\n        return \"array\";\n    }\n    get isArray() {\n        return true;\n    }\n}\n/**\n * @class SamplerType\n * @extends Type\n * @category AST\n */\nclass SamplerType extends Type {\n    constructor(name, format, access) {\n        super(name);\n        this.format = format;\n        this.access = access;\n    }\n    get astNodeType() {\n        return \"sampler\";\n    }\n}\n/**\n * @class Expression\n * @extends Node\n * @category AST\n */\nclass Expression extends Node {\n    constructor() {\n        super();\n    }\n}\n/**\n * @class StringExpr\n * @extends Expression\n * @category AST\n */\nclass StringExpr extends Expression {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"stringExpr\";\n    }\n    toString() {\n        return this.value;\n    }\n    evaluateString() {\n        return this.value;\n    }\n}\n/**\n * @class CreateExpr\n * @extends Expression\n * @category AST\n */\nclass CreateExpr extends Expression {\n    constructor(type, args) {\n        super();\n        this.type = type;\n        this.args = args;\n    }\n    get astNodeType() {\n        return \"createExpr\";\n    }\n    search(callback) {\n        callback(this);\n        for (const node of this.args) {\n            node.search(callback);\n        }\n    }\n}\n/**\n * @class CallExpr\n * @extends Expression\n * @category AST\n */\nclass CallExpr extends Expression {\n    constructor(name, args) {\n        super();\n        this.name = name;\n        this.args = args;\n    }\n    get astNodeType() {\n        return \"callExpr\";\n    }\n    evaluate(context) {\n        switch (this.name) {\n            case \"abs\":\n                return Math.abs(this.args[0].evaluate(context));\n            case \"acos\":\n                return Math.acos(this.args[0].evaluate(context));\n            case \"acosh\":\n                return Math.acosh(this.args[0].evaluate(context));\n            case \"asin\":\n                return Math.asin(this.args[0].evaluate(context));\n            case \"asinh\":\n                return Math.asinh(this.args[0].evaluate(context));\n            case \"atan\":\n                return Math.atan(this.args[0].evaluate(context));\n            case \"atan2\":\n                return Math.atan2(this.args[0].evaluate(context), this.args[1].evaluate(context));\n            case \"atanh\":\n                return Math.atanh(this.args[0].evaluate(context));\n            case \"ceil\":\n                return Math.ceil(this.args[0].evaluate(context));\n            case \"clamp\":\n                return Math.min(Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context)), this.args[2].evaluate(context));\n            case \"cos\":\n                return Math.cos(this.args[0].evaluate(context));\n            //case \"cross\":\n            //TODO: (x[i] * y[j] - x[j] * y[i])\n            case \"degrees\":\n                return (this.args[0].evaluate(context) * 180) / Math.PI;\n            //case \"determinant\":\n            //TODO implement\n            case \"distance\":\n                return Math.sqrt(Math.pow(this.args[0].evaluate(context) - this.args[1].evaluate(context), 2));\n            case \"dot\":\n            //TODO: (x[i] * y[i])\n            case \"exp\":\n                return Math.exp(this.args[0].evaluate(context));\n            case \"exp2\":\n                return Math.pow(2, this.args[0].evaluate(context));\n            //case \"extractBits\":\n            //TODO: implement\n            //case \"firstLeadingBit\":\n            //TODO: implement\n            case \"floor\":\n                return Math.floor(this.args[0].evaluate(context));\n            case \"fma\":\n                return (this.args[0].evaluate(context) * this.args[1].evaluate(context) +\n                    this.args[2].evaluate(context));\n            case \"fract\":\n                return (this.args[0].evaluate(context) -\n                    Math.floor(this.args[0].evaluate(context)));\n            //case \"frexp\":\n            //TODO: implement\n            case \"inverseSqrt\":\n                return 1 / Math.sqrt(this.args[0].evaluate(context));\n            //case \"length\":\n            //TODO: implement\n            case \"log\":\n                return Math.log(this.args[0].evaluate(context));\n            case \"log2\":\n                return Math.log2(this.args[0].evaluate(context));\n            case \"max\":\n                return Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context));\n            case \"min\":\n                return Math.min(this.args[0].evaluate(context), this.args[1].evaluate(context));\n            case \"mix\":\n                return (this.args[0].evaluate(context) *\n                    (1 - this.args[2].evaluate(context)) +\n                    this.args[1].evaluate(context) * this.args[2].evaluate(context));\n            case \"modf\":\n                return (this.args[0].evaluate(context) -\n                    Math.floor(this.args[0].evaluate(context)));\n            case \"pow\":\n                return Math.pow(this.args[0].evaluate(context), this.args[1].evaluate(context));\n            case \"radians\":\n                return (this.args[0].evaluate(context) * Math.PI) / 180;\n            case \"round\":\n                return Math.round(this.args[0].evaluate(context));\n            case \"sign\":\n                return Math.sign(this.args[0].evaluate(context));\n            case \"sin\":\n                return Math.sin(this.args[0].evaluate(context));\n            case \"sinh\":\n                return Math.sinh(this.args[0].evaluate(context));\n            case \"saturate\":\n                return Math.min(Math.max(this.args[0].evaluate(context), 0), 1);\n            case \"smoothstep\":\n                return (this.args[0].evaluate(context) *\n                    this.args[0].evaluate(context) *\n                    (3 - 2 * this.args[0].evaluate(context)));\n            case \"sqrt\":\n                return Math.sqrt(this.args[0].evaluate(context));\n            case \"step\":\n                return this.args[0].evaluate(context) < this.args[1].evaluate(context)\n                    ? 0\n                    : 1;\n            case \"tan\":\n                return Math.tan(this.args[0].evaluate(context));\n            case \"tanh\":\n                return Math.tanh(this.args[0].evaluate(context));\n            case \"trunc\":\n                return Math.trunc(this.args[0].evaluate(context));\n            default:\n                throw new Error(\"Non const function: \" + this.name);\n        }\n    }\n    search(callback) {\n        for (const node of this.args) {\n            node.search(callback);\n        }\n        callback(this);\n    }\n}\n/**\n * @class VariableExpr\n * @extends Expression\n * @category AST\n */\nclass VariableExpr extends Expression {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    get astNodeType() {\n        return \"varExpr\";\n    }\n    search(callback) {\n        callback(this);\n        if (this.postfix) {\n            this.postfix.search(callback);\n        }\n    }\n    evaluate(context) {\n        const constant = context.constants.get(this.name);\n        if (!constant) {\n            throw new Error(\"Cannot evaluate node\");\n        }\n        return constant.evaluate(context);\n    }\n}\n/**\n * @class ConstExpr\n * @extends Expression\n * @category AST\n */\nclass ConstExpr extends Expression {\n    constructor(name, initializer) {\n        super();\n        this.name = name;\n        this.initializer = initializer;\n    }\n    get astNodeType() {\n        return \"constExpr\";\n    }\n    evaluate(context) {\n        var _a, _b;\n        if (this.initializer instanceof CreateExpr) {\n            // This is a struct constant\n            const property = (_a = this.postfix) === null || _a === void 0 ? void 0 : _a.evaluateString(context);\n            const type = (_b = this.initializer.type) === null || _b === void 0 ? void 0 : _b.name;\n            const struct = context.structs.get(type);\n            const memberIndex = struct === null || struct === void 0 ? void 0 : struct.getMemberIndex(property);\n            if (memberIndex != -1) {\n                const value = this.initializer.args[memberIndex].evaluate(context);\n                return value;\n            }\n            console.log(memberIndex);\n        }\n        return this.initializer.evaluate(context);\n    }\n    search(callback) {\n        this.initializer.search(callback);\n    }\n}\n/**\n * @class LiteralExpr\n * @extends Expression\n * @category AST\n */\nclass LiteralExpr extends Expression {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"literalExpr\";\n    }\n    evaluate() {\n        return this.value;\n    }\n}\n/**\n * @class BitcastExpr\n * @extends Expression\n * @category AST\n */\nclass BitcastExpr extends Expression {\n    constructor(type, value) {\n        super();\n        this.type = type;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"bitcastExpr\";\n    }\n    search(callback) {\n        this.value.search(callback);\n    }\n}\n/**\n * @class TypecastExpr\n * @extends Expression\n * @category AST\n */\nclass TypecastExpr extends Expression {\n    constructor(type, args) {\n        super();\n        this.type = type;\n        this.args = args;\n    }\n    get astNodeType() {\n        return \"typecastExpr\";\n    }\n    evaluate(context) {\n        return this.args[0].evaluate(context);\n    }\n    search(callback) {\n        this.searchBlock(this.args, callback);\n    }\n}\n/**\n * @class GroupingExpr\n * @extends Expression\n * @category AST\n */\nclass GroupingExpr extends Expression {\n    constructor(contents) {\n        super();\n        this.contents = contents;\n    }\n    get astNodeType() {\n        return \"groupExpr\";\n    }\n    evaluate(context) {\n        return this.contents[0].evaluate(context);\n    }\n    search(callback) {\n        this.searchBlock(this.contents, callback);\n    }\n}\n/**\n * @class ArrayIndex\n * @extends Expression\n * @category AST\n */\nclass ArrayIndex extends Expression {\n    constructor(index) {\n        super();\n        this.index = index;\n    }\n    search(callback) {\n        this.index.search(callback);\n    }\n}\n/**\n * @class Operator\n * @extends Expression\n * @category AST\n */\nclass Operator extends Expression {\n    constructor() {\n        super();\n    }\n}\n/**\n * @class UnaryOperator\n * @extends Operator\n * @category AST\n * @property {string} operator +, -, !, ~\n */\nclass UnaryOperator extends Operator {\n    constructor(operator, right) {\n        super();\n        this.operator = operator;\n        this.right = right;\n    }\n    get astNodeType() {\n        return \"unaryOp\";\n    }\n    evaluate(context) {\n        switch (this.operator) {\n            case \"+\":\n                return this.right.evaluate(context);\n            case \"-\":\n                return -this.right.evaluate(context);\n            case \"!\":\n                return this.right.evaluate(context) ? 0 : 1;\n            case \"~\":\n                return ~this.right.evaluate(context);\n            default:\n                throw new Error(\"Unknown unary operator: \" + this.operator);\n        }\n    }\n    search(callback) {\n        this.right.search(callback);\n    }\n}\n/**\n * @class BinaryOperator\n * @extends Operator\n * @category AST\n * @property {string} operator +, -, *, /, %, ==, !=, <, >, <=, >=, &&, ||\n */\nclass BinaryOperator extends Operator {\n    constructor(operator, left, right) {\n        super();\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n    get astNodeType() {\n        return \"binaryOp\";\n    }\n    evaluate(context) {\n        switch (this.operator) {\n            case \"+\":\n                return this.left.evaluate(context) + this.right.evaluate(context);\n            case \"-\":\n                return this.left.evaluate(context) - this.right.evaluate(context);\n            case \"*\":\n                return this.left.evaluate(context) * this.right.evaluate(context);\n            case \"/\":\n                return this.left.evaluate(context) / this.right.evaluate(context);\n            case \"%\":\n                return this.left.evaluate(context) % this.right.evaluate(context);\n            case \"==\":\n                return this.left.evaluate(context) == this.right.evaluate(context)\n                    ? 1\n                    : 0;\n            case \"!=\":\n                return this.left.evaluate(context) != this.right.evaluate(context)\n                    ? 1\n                    : 0;\n            case \"<\":\n                return this.left.evaluate(context) < this.right.evaluate(context)\n                    ? 1\n                    : 0;\n            case \">\":\n                return this.left.evaluate(context) > this.right.evaluate(context)\n                    ? 1\n                    : 0;\n            case \"<=\":\n                return this.left.evaluate(context) <= this.right.evaluate(context)\n                    ? 1\n                    : 0;\n            case \">=\":\n                return this.left.evaluate(context) >= this.right.evaluate(context)\n                    ? 1\n                    : 0;\n            case \"&&\":\n                return this.left.evaluate(context) && this.right.evaluate(context)\n                    ? 1\n                    : 0;\n            case \"||\":\n                return this.left.evaluate(context) || this.right.evaluate(context)\n                    ? 1\n                    : 0;\n            default:\n                throw new Error(`Unknown operator ${this.operator}`);\n        }\n    }\n    search(callback) {\n        this.left.search(callback);\n        this.right.search(callback);\n    }\n}\n/**\n * @class SwitchCase\n * @extends Node\n * @category AST\n */\nclass SwitchCase extends Node {\n    constructor() {\n        super();\n    }\n}\n/**\n * @class Case\n * @extends SwitchCase\n * @category AST\n */\nclass Case extends SwitchCase {\n    constructor(selector, body) {\n        super();\n        this.selector = selector;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"case\";\n    }\n    search(callback) {\n        this.searchBlock(this.body, callback);\n    }\n}\n/**\n * @class Default\n * @extends SwitchCase\n * @category AST\n */\nclass Default extends SwitchCase {\n    constructor(body) {\n        super();\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"default\";\n    }\n    search(callback) {\n        this.searchBlock(this.body, callback);\n    }\n}\n/**\n * @class Argument\n * @extends Node\n * @category AST\n */\nclass Argument extends Node {\n    constructor(name, type, attributes) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.attributes = attributes;\n    }\n    get astNodeType() {\n        return \"argument\";\n    }\n}\n/**\n * @class ElseIf\n * @extends Node\n * @category AST\n */\nclass ElseIf extends Node {\n    constructor(condition, body) {\n        super();\n        this.condition = condition;\n        this.body = body;\n    }\n    get astNodeType() {\n        return \"elseif\";\n    }\n    search(callback) {\n        this.condition.search(callback);\n        this.searchBlock(this.body, callback);\n    }\n}\n/**\n * @class Member\n * @extends Node\n * @category AST\n */\nclass Member extends Node {\n    constructor(name, type, attributes) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.attributes = attributes;\n    }\n    get astNodeType() {\n        return \"member\";\n    }\n}\n/**\n * @class Attribute\n * @extends Node\n * @category AST\n */\nclass Attribute extends Node {\n    constructor(name, value) {\n        super();\n        this.name = name;\n        this.value = value;\n    }\n    get astNodeType() {\n        return \"attribute\";\n    }\n}\n\nvar _a;\nvar TokenClass;\n(function (TokenClass) {\n    TokenClass[TokenClass[\"token\"] = 0] = \"token\";\n    TokenClass[TokenClass[\"keyword\"] = 1] = \"keyword\";\n    TokenClass[TokenClass[\"reserved\"] = 2] = \"reserved\";\n})(TokenClass || (TokenClass = {}));\nclass TokenType {\n    constructor(name, type, rule) {\n        this.name = name;\n        this.type = type;\n        this.rule = rule;\n    }\n    toString() {\n        return this.name;\n    }\n}\n/// Catalog of defined token types, keywords, and reserved words.\nclass TokenTypes {\n}\n_a = TokenTypes;\nTokenTypes.none = new TokenType(\"\", TokenClass.reserved, \"\");\nTokenTypes.eof = new TokenType(\"EOF\", TokenClass.token, \"\");\nTokenTypes.reserved = {\n    asm: new TokenType(\"asm\", TokenClass.reserved, \"asm\"),\n    bf16: new TokenType(\"bf16\", TokenClass.reserved, \"bf16\"),\n    do: new TokenType(\"do\", TokenClass.reserved, \"do\"),\n    enum: new TokenType(\"enum\", TokenClass.reserved, \"enum\"),\n    f16: new TokenType(\"f16\", TokenClass.reserved, \"f16\"),\n    f64: new TokenType(\"f64\", TokenClass.reserved, \"f64\"),\n    handle: new TokenType(\"handle\", TokenClass.reserved, \"handle\"),\n    i8: new TokenType(\"i8\", TokenClass.reserved, \"i8\"),\n    i16: new TokenType(\"i16\", TokenClass.reserved, \"i16\"),\n    i64: new TokenType(\"i64\", TokenClass.reserved, \"i64\"),\n    mat: new TokenType(\"mat\", TokenClass.reserved, \"mat\"),\n    premerge: new TokenType(\"premerge\", TokenClass.reserved, \"premerge\"),\n    regardless: new TokenType(\"regardless\", TokenClass.reserved, \"regardless\"),\n    typedef: new TokenType(\"typedef\", TokenClass.reserved, \"typedef\"),\n    u8: new TokenType(\"u8\", TokenClass.reserved, \"u8\"),\n    u16: new TokenType(\"u16\", TokenClass.reserved, \"u16\"),\n    u64: new TokenType(\"u64\", TokenClass.reserved, \"u64\"),\n    unless: new TokenType(\"unless\", TokenClass.reserved, \"unless\"),\n    using: new TokenType(\"using\", TokenClass.reserved, \"using\"),\n    vec: new TokenType(\"vec\", TokenClass.reserved, \"vec\"),\n    void: new TokenType(\"void\", TokenClass.reserved, \"void\"),\n};\nTokenTypes.keywords = {\n    array: new TokenType(\"array\", TokenClass.keyword, \"array\"),\n    atomic: new TokenType(\"atomic\", TokenClass.keyword, \"atomic\"),\n    bool: new TokenType(\"bool\", TokenClass.keyword, \"bool\"),\n    f32: new TokenType(\"f32\", TokenClass.keyword, \"f32\"),\n    i32: new TokenType(\"i32\", TokenClass.keyword, \"i32\"),\n    mat2x2: new TokenType(\"mat2x2\", TokenClass.keyword, \"mat2x2\"),\n    mat2x3: new TokenType(\"mat2x3\", TokenClass.keyword, \"mat2x3\"),\n    mat2x4: new TokenType(\"mat2x4\", TokenClass.keyword, \"mat2x4\"),\n    mat3x2: new TokenType(\"mat3x2\", TokenClass.keyword, \"mat3x2\"),\n    mat3x3: new TokenType(\"mat3x3\", TokenClass.keyword, \"mat3x3\"),\n    mat3x4: new TokenType(\"mat3x4\", TokenClass.keyword, \"mat3x4\"),\n    mat4x2: new TokenType(\"mat4x2\", TokenClass.keyword, \"mat4x2\"),\n    mat4x3: new TokenType(\"mat4x3\", TokenClass.keyword, \"mat4x3\"),\n    mat4x4: new TokenType(\"mat4x4\", TokenClass.keyword, \"mat4x4\"),\n    ptr: new TokenType(\"ptr\", TokenClass.keyword, \"ptr\"),\n    sampler: new TokenType(\"sampler\", TokenClass.keyword, \"sampler\"),\n    sampler_comparison: new TokenType(\"sampler_comparison\", TokenClass.keyword, \"sampler_comparison\"),\n    struct: new TokenType(\"struct\", TokenClass.keyword, \"struct\"),\n    texture_1d: new TokenType(\"texture_1d\", TokenClass.keyword, \"texture_1d\"),\n    texture_2d: new TokenType(\"texture_2d\", TokenClass.keyword, \"texture_2d\"),\n    texture_2d_array: new TokenType(\"texture_2d_array\", TokenClass.keyword, \"texture_2d_array\"),\n    texture_3d: new TokenType(\"texture_3d\", TokenClass.keyword, \"texture_3d\"),\n    texture_cube: new TokenType(\"texture_cube\", TokenClass.keyword, \"texture_cube\"),\n    texture_cube_array: new TokenType(\"texture_cube_array\", TokenClass.keyword, \"texture_cube_array\"),\n    texture_multisampled_2d: new TokenType(\"texture_multisampled_2d\", TokenClass.keyword, \"texture_multisampled_2d\"),\n    texture_storage_1d: new TokenType(\"texture_storage_1d\", TokenClass.keyword, \"texture_storage_1d\"),\n    texture_storage_2d: new TokenType(\"texture_storage_2d\", TokenClass.keyword, \"texture_storage_2d\"),\n    texture_storage_2d_array: new TokenType(\"texture_storage_2d_array\", TokenClass.keyword, \"texture_storage_2d_array\"),\n    texture_storage_3d: new TokenType(\"texture_storage_3d\", TokenClass.keyword, \"texture_storage_3d\"),\n    texture_depth_2d: new TokenType(\"texture_depth_2d\", TokenClass.keyword, \"texture_depth_2d\"),\n    texture_depth_2d_array: new TokenType(\"texture_depth_2d_array\", TokenClass.keyword, \"texture_depth_2d_array\"),\n    texture_depth_cube: new TokenType(\"texture_depth_cube\", TokenClass.keyword, \"texture_depth_cube\"),\n    texture_depth_cube_array: new TokenType(\"texture_depth_cube_array\", TokenClass.keyword, \"texture_depth_cube_array\"),\n    texture_depth_multisampled_2d: new TokenType(\"texture_depth_multisampled_2d\", TokenClass.keyword, \"texture_depth_multisampled_2d\"),\n    texture_external: new TokenType(\"texture_external\", TokenClass.keyword, \"texture_external\"),\n    u32: new TokenType(\"u32\", TokenClass.keyword, \"u32\"),\n    vec2: new TokenType(\"vec2\", TokenClass.keyword, \"vec2\"),\n    vec3: new TokenType(\"vec3\", TokenClass.keyword, \"vec3\"),\n    vec4: new TokenType(\"vec4\", TokenClass.keyword, \"vec4\"),\n    bitcast: new TokenType(\"bitcast\", TokenClass.keyword, \"bitcast\"),\n    block: new TokenType(\"block\", TokenClass.keyword, \"block\"),\n    break: new TokenType(\"break\", TokenClass.keyword, \"break\"),\n    case: new TokenType(\"case\", TokenClass.keyword, \"case\"),\n    continue: new TokenType(\"continue\", TokenClass.keyword, \"continue\"),\n    continuing: new TokenType(\"continuing\", TokenClass.keyword, \"continuing\"),\n    default: new TokenType(\"default\", TokenClass.keyword, \"default\"),\n    diagnostic: new TokenType(\"diagnostic\", TokenClass.keyword, \"diagnostic\"),\n    discard: new TokenType(\"discard\", TokenClass.keyword, \"discard\"),\n    else: new TokenType(\"else\", TokenClass.keyword, \"else\"),\n    enable: new TokenType(\"enable\", TokenClass.keyword, \"enable\"),\n    fallthrough: new TokenType(\"fallthrough\", TokenClass.keyword, \"fallthrough\"),\n    false: new TokenType(\"false\", TokenClass.keyword, \"false\"),\n    fn: new TokenType(\"fn\", TokenClass.keyword, \"fn\"),\n    for: new TokenType(\"for\", TokenClass.keyword, \"for\"),\n    function: new TokenType(\"function\", TokenClass.keyword, \"function\"),\n    if: new TokenType(\"if\", TokenClass.keyword, \"if\"),\n    let: new TokenType(\"let\", TokenClass.keyword, \"let\"),\n    const: new TokenType(\"const\", TokenClass.keyword, \"const\"),\n    loop: new TokenType(\"loop\", TokenClass.keyword, \"loop\"),\n    while: new TokenType(\"while\", TokenClass.keyword, \"while\"),\n    private: new TokenType(\"private\", TokenClass.keyword, \"private\"),\n    read: new TokenType(\"read\", TokenClass.keyword, \"read\"),\n    read_write: new TokenType(\"read_write\", TokenClass.keyword, \"read_write\"),\n    return: new TokenType(\"return\", TokenClass.keyword, \"return\"),\n    requires: new TokenType(\"requires\", TokenClass.keyword, \"requires\"),\n    storage: new TokenType(\"storage\", TokenClass.keyword, \"storage\"),\n    switch: new TokenType(\"switch\", TokenClass.keyword, \"switch\"),\n    true: new TokenType(\"true\", TokenClass.keyword, \"true\"),\n    alias: new TokenType(\"alias\", TokenClass.keyword, \"alias\"),\n    type: new TokenType(\"type\", TokenClass.keyword, \"type\"),\n    uniform: new TokenType(\"uniform\", TokenClass.keyword, \"uniform\"),\n    var: new TokenType(\"var\", TokenClass.keyword, \"var\"),\n    override: new TokenType(\"override\", TokenClass.keyword, \"override\"),\n    workgroup: new TokenType(\"workgroup\", TokenClass.keyword, \"workgroup\"),\n    write: new TokenType(\"write\", TokenClass.keyword, \"write\"),\n    r8unorm: new TokenType(\"r8unorm\", TokenClass.keyword, \"r8unorm\"),\n    r8snorm: new TokenType(\"r8snorm\", TokenClass.keyword, \"r8snorm\"),\n    r8uint: new TokenType(\"r8uint\", TokenClass.keyword, \"r8uint\"),\n    r8sint: new TokenType(\"r8sint\", TokenClass.keyword, \"r8sint\"),\n    r16uint: new TokenType(\"r16uint\", TokenClass.keyword, \"r16uint\"),\n    r16sint: new TokenType(\"r16sint\", TokenClass.keyword, \"r16sint\"),\n    r16float: new TokenType(\"r16float\", TokenClass.keyword, \"r16float\"),\n    rg8unorm: new TokenType(\"rg8unorm\", TokenClass.keyword, \"rg8unorm\"),\n    rg8snorm: new TokenType(\"rg8snorm\", TokenClass.keyword, \"rg8snorm\"),\n    rg8uint: new TokenType(\"rg8uint\", TokenClass.keyword, \"rg8uint\"),\n    rg8sint: new TokenType(\"rg8sint\", TokenClass.keyword, \"rg8sint\"),\n    r32uint: new TokenType(\"r32uint\", TokenClass.keyword, \"r32uint\"),\n    r32sint: new TokenType(\"r32sint\", TokenClass.keyword, \"r32sint\"),\n    r32float: new TokenType(\"r32float\", TokenClass.keyword, \"r32float\"),\n    rg16uint: new TokenType(\"rg16uint\", TokenClass.keyword, \"rg16uint\"),\n    rg16sint: new TokenType(\"rg16sint\", TokenClass.keyword, \"rg16sint\"),\n    rg16float: new TokenType(\"rg16float\", TokenClass.keyword, \"rg16float\"),\n    rgba8unorm: new TokenType(\"rgba8unorm\", TokenClass.keyword, \"rgba8unorm\"),\n    rgba8unorm_srgb: new TokenType(\"rgba8unorm_srgb\", TokenClass.keyword, \"rgba8unorm_srgb\"),\n    rgba8snorm: new TokenType(\"rgba8snorm\", TokenClass.keyword, \"rgba8snorm\"),\n    rgba8uint: new TokenType(\"rgba8uint\", TokenClass.keyword, \"rgba8uint\"),\n    rgba8sint: new TokenType(\"rgba8sint\", TokenClass.keyword, \"rgba8sint\"),\n    bgra8unorm: new TokenType(\"bgra8unorm\", TokenClass.keyword, \"bgra8unorm\"),\n    bgra8unorm_srgb: new TokenType(\"bgra8unorm_srgb\", TokenClass.keyword, \"bgra8unorm_srgb\"),\n    rgb10a2unorm: new TokenType(\"rgb10a2unorm\", TokenClass.keyword, \"rgb10a2unorm\"),\n    rg11b10float: new TokenType(\"rg11b10float\", TokenClass.keyword, \"rg11b10float\"),\n    rg32uint: new TokenType(\"rg32uint\", TokenClass.keyword, \"rg32uint\"),\n    rg32sint: new TokenType(\"rg32sint\", TokenClass.keyword, \"rg32sint\"),\n    rg32float: new TokenType(\"rg32float\", TokenClass.keyword, \"rg32float\"),\n    rgba16uint: new TokenType(\"rgba16uint\", TokenClass.keyword, \"rgba16uint\"),\n    rgba16sint: new TokenType(\"rgba16sint\", TokenClass.keyword, \"rgba16sint\"),\n    rgba16float: new TokenType(\"rgba16float\", TokenClass.keyword, \"rgba16float\"),\n    rgba32uint: new TokenType(\"rgba32uint\", TokenClass.keyword, \"rgba32uint\"),\n    rgba32sint: new TokenType(\"rgba32sint\", TokenClass.keyword, \"rgba32sint\"),\n    rgba32float: new TokenType(\"rgba32float\", TokenClass.keyword, \"rgba32float\"),\n    static_assert: new TokenType(\"static_assert\", TokenClass.keyword, \"static_assert\"),\n    // WGSL grammar has a few keywords that have different token names than the strings they\n    // represent. Aliasing them here.\n    /*int32: new TokenType(\"i32\", TokenClass.keyword, \"i32\"),\n        uint32: new TokenType(\"u32\", TokenClass.keyword, \"u32\"),\n        float32: new TokenType(\"f32\", TokenClass.keyword, \"f32\"),\n        pointer: new TokenType(\"ptr\", TokenClass.keyword, \"ptr\"),*/\n};\nTokenTypes.tokens = {\n    decimal_float_literal: new TokenType(\"decimal_float_literal\", TokenClass.token, /((-?[0-9]*\\.[0-9]+|-?[0-9]+\\.[0-9]*)((e|E)(\\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\\+|-)?[0-9]+f?)|([0-9]+f)/),\n    hex_float_literal: new TokenType(\"hex_float_literal\", TokenClass.token, /-?0x((([0-9a-fA-F]*\\.[0-9a-fA-F]+|[0-9a-fA-F]+\\.[0-9a-fA-F]*)((p|P)(\\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\\+|-)?[0-9]+f?))/),\n    int_literal: new TokenType(\"int_literal\", TokenClass.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),\n    uint_literal: new TokenType(\"uint_literal\", TokenClass.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),\n    ident: new TokenType(\"ident\", TokenClass.token, /[_a-zA-Z][0-9a-zA-Z_]*/),\n    and: new TokenType(\"and\", TokenClass.token, \"&\"),\n    and_and: new TokenType(\"and_and\", TokenClass.token, \"&&\"),\n    arrow: new TokenType(\"arrow \", TokenClass.token, \"->\"),\n    attr: new TokenType(\"attr\", TokenClass.token, \"@\"),\n    forward_slash: new TokenType(\"forward_slash\", TokenClass.token, \"/\"),\n    bang: new TokenType(\"bang\", TokenClass.token, \"!\"),\n    bracket_left: new TokenType(\"bracket_left\", TokenClass.token, \"[\"),\n    bracket_right: new TokenType(\"bracket_right\", TokenClass.token, \"]\"),\n    brace_left: new TokenType(\"brace_left\", TokenClass.token, \"{\"),\n    brace_right: new TokenType(\"brace_right\", TokenClass.token, \"}\"),\n    colon: new TokenType(\"colon\", TokenClass.token, \":\"),\n    comma: new TokenType(\"comma\", TokenClass.token, \",\"),\n    equal: new TokenType(\"equal\", TokenClass.token, \"=\"),\n    equal_equal: new TokenType(\"equal_equal\", TokenClass.token, \"==\"),\n    not_equal: new TokenType(\"not_equal\", TokenClass.token, \"!=\"),\n    greater_than: new TokenType(\"greater_than\", TokenClass.token, \">\"),\n    greater_than_equal: new TokenType(\"greater_than_equal\", TokenClass.token, \">=\"),\n    shift_right: new TokenType(\"shift_right\", TokenClass.token, \">>\"),\n    less_than: new TokenType(\"less_than\", TokenClass.token, \"<\"),\n    less_than_equal: new TokenType(\"less_than_equal\", TokenClass.token, \"<=\"),\n    shift_left: new TokenType(\"shift_left\", TokenClass.token, \"<<\"),\n    modulo: new TokenType(\"modulo\", TokenClass.token, \"%\"),\n    minus: new TokenType(\"minus\", TokenClass.token, \"-\"),\n    minus_minus: new TokenType(\"minus_minus\", TokenClass.token, \"--\"),\n    period: new TokenType(\"period\", TokenClass.token, \".\"),\n    plus: new TokenType(\"plus\", TokenClass.token, \"+\"),\n    plus_plus: new TokenType(\"plus_plus\", TokenClass.token, \"++\"),\n    or: new TokenType(\"or\", TokenClass.token, \"|\"),\n    or_or: new TokenType(\"or_or\", TokenClass.token, \"||\"),\n    paren_left: new TokenType(\"paren_left\", TokenClass.token, \"(\"),\n    paren_right: new TokenType(\"paren_right\", TokenClass.token, \")\"),\n    semicolon: new TokenType(\"semicolon\", TokenClass.token, \";\"),\n    star: new TokenType(\"star\", TokenClass.token, \"*\"),\n    tilde: new TokenType(\"tilde\", TokenClass.token, \"~\"),\n    underscore: new TokenType(\"underscore\", TokenClass.token, \"_\"),\n    xor: new TokenType(\"xor\", TokenClass.token, \"^\"),\n    plus_equal: new TokenType(\"plus_equal\", TokenClass.token, \"+=\"),\n    minus_equal: new TokenType(\"minus_equal\", TokenClass.token, \"-=\"),\n    times_equal: new TokenType(\"times_equal\", TokenClass.token, \"*=\"),\n    division_equal: new TokenType(\"division_equal\", TokenClass.token, \"/=\"),\n    modulo_equal: new TokenType(\"modulo_equal\", TokenClass.token, \"%=\"),\n    and_equal: new TokenType(\"and_equal\", TokenClass.token, \"&=\"),\n    or_equal: new TokenType(\"or_equal\", TokenClass.token, \"|=\"),\n    xor_equal: new TokenType(\"xor_equal\", TokenClass.token, \"^=\"),\n    shift_right_equal: new TokenType(\"shift_right_equal\", TokenClass.token, \">>=\"),\n    shift_left_equal: new TokenType(\"shift_left_equal\", TokenClass.token, \"<<=\"),\n};\nTokenTypes.simpleTokens = {\n    \"@\": _a.tokens.attr,\n    \"{\": _a.tokens.brace_left,\n    \"}\": _a.tokens.brace_right,\n    \":\": _a.tokens.colon,\n    \",\": _a.tokens.comma,\n    \"(\": _a.tokens.paren_left,\n    \")\": _a.tokens.paren_right,\n    \";\": _a.tokens.semicolon,\n};\nTokenTypes.literalTokens = {\n    \"&\": _a.tokens.and,\n    \"&&\": _a.tokens.and_and,\n    \"->\": _a.tokens.arrow,\n    \"/\": _a.tokens.forward_slash,\n    \"!\": _a.tokens.bang,\n    \"[\": _a.tokens.bracket_left,\n    \"]\": _a.tokens.bracket_right,\n    \"=\": _a.tokens.equal,\n    \"==\": _a.tokens.equal_equal,\n    \"!=\": _a.tokens.not_equal,\n    \">\": _a.tokens.greater_than,\n    \">=\": _a.tokens.greater_than_equal,\n    \">>\": _a.tokens.shift_right,\n    \"<\": _a.tokens.less_than,\n    \"<=\": _a.tokens.less_than_equal,\n    \"<<\": _a.tokens.shift_left,\n    \"%\": _a.tokens.modulo,\n    \"-\": _a.tokens.minus,\n    \"--\": _a.tokens.minus_minus,\n    \".\": _a.tokens.period,\n    \"+\": _a.tokens.plus,\n    \"++\": _a.tokens.plus_plus,\n    \"|\": _a.tokens.or,\n    \"||\": _a.tokens.or_or,\n    \"*\": _a.tokens.star,\n    \"~\": _a.tokens.tilde,\n    \"_\": _a.tokens.underscore,\n    \"^\": _a.tokens.xor,\n    \"+=\": _a.tokens.plus_equal,\n    \"-=\": _a.tokens.minus_equal,\n    \"*=\": _a.tokens.times_equal,\n    \"/=\": _a.tokens.division_equal,\n    \"%=\": _a.tokens.modulo_equal,\n    \"&=\": _a.tokens.and_equal,\n    \"|=\": _a.tokens.or_equal,\n    \"^=\": _a.tokens.xor_equal,\n    \">>=\": _a.tokens.shift_right_equal,\n    \"<<=\": _a.tokens.shift_left_equal,\n};\nTokenTypes.regexTokens = {\n    decimal_float_literal: _a.tokens.decimal_float_literal,\n    hex_float_literal: _a.tokens.hex_float_literal,\n    int_literal: _a.tokens.int_literal,\n    uint_literal: _a.tokens.uint_literal,\n    ident: _a.tokens.ident,\n};\nTokenTypes.storage_class = [\n    _a.keywords.function,\n    _a.keywords.private,\n    _a.keywords.workgroup,\n    _a.keywords.uniform,\n    _a.keywords.storage,\n];\nTokenTypes.access_mode = [\n    _a.keywords.read,\n    _a.keywords.write,\n    _a.keywords.read_write,\n];\nTokenTypes.sampler_type = [\n    _a.keywords.sampler,\n    _a.keywords.sampler_comparison,\n];\nTokenTypes.sampled_texture_type = [\n    _a.keywords.texture_1d,\n    _a.keywords.texture_2d,\n    _a.keywords.texture_2d_array,\n    _a.keywords.texture_3d,\n    _a.keywords.texture_cube,\n    _a.keywords.texture_cube_array,\n];\nTokenTypes.multisampled_texture_type = [\n    _a.keywords.texture_multisampled_2d,\n];\nTokenTypes.storage_texture_type = [\n    _a.keywords.texture_storage_1d,\n    _a.keywords.texture_storage_2d,\n    _a.keywords.texture_storage_2d_array,\n    _a.keywords.texture_storage_3d,\n];\nTokenTypes.depth_texture_type = [\n    _a.keywords.texture_depth_2d,\n    _a.keywords.texture_depth_2d_array,\n    _a.keywords.texture_depth_cube,\n    _a.keywords.texture_depth_cube_array,\n    _a.keywords.texture_depth_multisampled_2d,\n];\nTokenTypes.texture_external_type = [_a.keywords.texture_external];\nTokenTypes.any_texture_type = [\n    ..._a.sampled_texture_type,\n    ..._a.multisampled_texture_type,\n    ..._a.storage_texture_type,\n    ..._a.depth_texture_type,\n    ..._a.texture_external_type,\n];\nTokenTypes.texel_format = [\n    _a.keywords.r8unorm,\n    _a.keywords.r8snorm,\n    _a.keywords.r8uint,\n    _a.keywords.r8sint,\n    _a.keywords.r16uint,\n    _a.keywords.r16sint,\n    _a.keywords.r16float,\n    _a.keywords.rg8unorm,\n    _a.keywords.rg8snorm,\n    _a.keywords.rg8uint,\n    _a.keywords.rg8sint,\n    _a.keywords.r32uint,\n    _a.keywords.r32sint,\n    _a.keywords.r32float,\n    _a.keywords.rg16uint,\n    _a.keywords.rg16sint,\n    _a.keywords.rg16float,\n    _a.keywords.rgba8unorm,\n    _a.keywords.rgba8unorm_srgb,\n    _a.keywords.rgba8snorm,\n    _a.keywords.rgba8uint,\n    _a.keywords.rgba8sint,\n    _a.keywords.bgra8unorm,\n    _a.keywords.bgra8unorm_srgb,\n    _a.keywords.rgb10a2unorm,\n    _a.keywords.rg11b10float,\n    _a.keywords.rg32uint,\n    _a.keywords.rg32sint,\n    _a.keywords.rg32float,\n    _a.keywords.rgba16uint,\n    _a.keywords.rgba16sint,\n    _a.keywords.rgba16float,\n    _a.keywords.rgba32uint,\n    _a.keywords.rgba32sint,\n    _a.keywords.rgba32float,\n];\nTokenTypes.const_literal = [\n    _a.tokens.int_literal,\n    _a.tokens.uint_literal,\n    _a.tokens.decimal_float_literal,\n    _a.tokens.hex_float_literal,\n    _a.keywords.true,\n    _a.keywords.false,\n];\nTokenTypes.literal_or_ident = [\n    _a.tokens.ident,\n    _a.tokens.int_literal,\n    _a.tokens.uint_literal,\n    _a.tokens.decimal_float_literal,\n    _a.tokens.hex_float_literal,\n];\nTokenTypes.element_count_expression = [\n    _a.tokens.int_literal,\n    _a.tokens.uint_literal,\n    _a.tokens.ident,\n];\nTokenTypes.template_types = [\n    _a.keywords.vec2,\n    _a.keywords.vec3,\n    _a.keywords.vec4,\n    _a.keywords.mat2x2,\n    _a.keywords.mat2x3,\n    _a.keywords.mat2x4,\n    _a.keywords.mat3x2,\n    _a.keywords.mat3x3,\n    _a.keywords.mat3x4,\n    _a.keywords.mat4x2,\n    _a.keywords.mat4x3,\n    _a.keywords.mat4x4,\n    _a.keywords.atomic,\n    _a.keywords.bitcast,\n    ..._a.any_texture_type,\n];\n// The grammar calls out 'block', but attribute grammar is defined to use a 'ident'.\n// The attribute grammar should be ident | block.\nTokenTypes.attribute_name = [_a.tokens.ident, _a.keywords.block, _a.keywords.diagnostic];\nTokenTypes.assignment_operators = [\n    _a.tokens.equal,\n    _a.tokens.plus_equal,\n    _a.tokens.minus_equal,\n    _a.tokens.times_equal,\n    _a.tokens.division_equal,\n    _a.tokens.modulo_equal,\n    _a.tokens.and_equal,\n    _a.tokens.or_equal,\n    _a.tokens.xor_equal,\n    _a.tokens.shift_right_equal,\n    _a.tokens.shift_left_equal,\n];\nTokenTypes.increment_operators = [\n    _a.tokens.plus_plus,\n    _a.tokens.minus_minus,\n];\n/// A token parsed by the WgslScanner.\nclass Token {\n    constructor(type, lexeme, line) {\n        this.type = type;\n        this.lexeme = lexeme;\n        this.line = line;\n    }\n    toString() {\n        return this.lexeme;\n    }\n    isTemplateType() {\n        return TokenTypes.template_types.indexOf(this.type) != -1;\n    }\n    isArrayType() {\n        return this.type == TokenTypes.keywords.array;\n    }\n    isArrayOrTemplateType() {\n        return this.isArrayType() || this.isTemplateType();\n    }\n}\n/// Lexical scanner for the WGSL language. This takes an input source text and generates a list\n/// of Token objects, which can then be fed into the WgslParser to generate an AST.\nclass WgslScanner {\n    constructor(source) {\n        this._tokens = [];\n        this._start = 0;\n        this._current = 0;\n        this._line = 1;\n        this._source = source !== null && source !== void 0 ? source : \"\";\n    }\n    /// Scan all tokens from the source.\n    scanTokens() {\n        while (!this._isAtEnd()) {\n            this._start = this._current;\n            if (!this.scanToken()) {\n                throw `Invalid syntax at line ${this._line}`;\n            }\n        }\n        this._tokens.push(new Token(TokenTypes.eof, \"\", this._line));\n        return this._tokens;\n    }\n    /// Scan a single token from the source.\n    scanToken() {\n        // Find the longest consecutive set of characters that match a rule.\n        let lexeme = this._advance();\n        // Skip line-feed, adding to the line counter.\n        if (lexeme == \"\\n\") {\n            this._line++;\n            return true;\n        }\n        // Skip whitespace\n        if (this._isWhitespace(lexeme)) {\n            return true;\n        }\n        if (lexeme == \"/\") {\n            // If it's a // comment, skip everything until the next line-feed.\n            if (this._peekAhead() == \"/\") {\n                while (lexeme != \"\\n\") {\n                    if (this._isAtEnd()) {\n                        return true;\n                    }\n                    lexeme = this._advance();\n                }\n                // skip the linefeed\n                this._line++;\n                return true;\n            }\n            else if (this._peekAhead() == \"*\") {\n                // If it's a / * block comment, skip everything until the matching * /,\n                // allowing for nested block comments.\n                this._advance();\n                let commentLevel = 1;\n                while (commentLevel > 0) {\n                    if (this._isAtEnd()) {\n                        return true;\n                    }\n                    lexeme = this._advance();\n                    if (lexeme == \"\\n\") {\n                        this._line++;\n                    }\n                    else if (lexeme == \"*\") {\n                        if (this._peekAhead() == \"/\") {\n                            this._advance();\n                            commentLevel--;\n                            if (commentLevel == 0) {\n                                return true;\n                            }\n                        }\n                    }\n                    else if (lexeme == \"/\") {\n                        if (this._peekAhead() == \"*\") {\n                            this._advance();\n                            commentLevel++;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        // Shortcut single character tokens\n        const simpleToken = TokenTypes.simpleTokens[lexeme];\n        if (simpleToken) {\n            this._addToken(simpleToken);\n            return true;\n        }\n        // Shortcut keywords and identifiers\n        let matchType = TokenTypes.none;\n        const isAlpha = this._isAlpha(lexeme);\n        const isUnderscore = lexeme === \"_\";\n        if (this._isAlphaNumeric(lexeme)) {\n            let nextChar = this._peekAhead();\n            while (this._isAlphaNumeric(nextChar)) {\n                lexeme += this._advance();\n                nextChar = this._peekAhead();\n            }\n        }\n        if (isAlpha) {\n            const matchedType = TokenTypes.keywords[lexeme];\n            if (matchedType) {\n                this._addToken(matchedType);\n                return true;\n            }\n        }\n        if (isAlpha || isUnderscore) {\n            this._addToken(TokenTypes.tokens.ident);\n            return true;\n        }\n        // Scan for the next valid token type\n        for (;;) {\n            let matchedType = this._findType(lexeme);\n            // An exception to \"longest lexeme\" rule is '>>'. In the case of 1>>2, it's a\n            // shift_right.\n            // In the case of array<vec4<f32>>, it's two greater_than's (one to close the vec4,\n            // and one to close the array).\n            // Another ambiguity is '>='. In the case of vec2<i32>=vec2(1,2),\n            // it's a greather_than and an equal, not a greater_than_equal.\n            // Another ambiguity is '-'. In the case of a-2, it's a minus; in the case of a*-2, it's a -2;\n            // in the case of foo()->int, it's a ->; in the case of foo-- or --foo, it's a -- decrement.\n            // WGSL requires context sensitive parsing to resolve these ambiguities. Both of these cases\n            // are predicated on it the > either closing a template, or being part of an operator.\n            // The solution here is to check if there was a less_than up to some number of tokens\n            // previously, and the token prior to that is a keyword that requires a '<', then it will be\n            // split into two operators; otherwise it's a single operator.\n            const nextLexeme = this._peekAhead();\n            if (lexeme == \"-\" && this._tokens.length > 0) {\n                if (nextLexeme == \"=\") {\n                    this._current++;\n                    lexeme += nextLexeme;\n                    this._addToken(TokenTypes.tokens.minus_equal);\n                    return true;\n                }\n                if (nextLexeme == \"-\") {\n                    this._current++;\n                    lexeme += nextLexeme;\n                    this._addToken(TokenTypes.tokens.minus_minus);\n                    return true;\n                }\n                const ti = this._tokens.length - 1;\n                const isIdentOrLiteral = TokenTypes.literal_or_ident.indexOf(this._tokens[ti].type) != -1;\n                if ((isIdentOrLiteral || this._tokens[ti].type == TokenTypes.tokens.paren_right) && nextLexeme != \">\") {\n                    this._addToken(matchedType);\n                    return true;\n                }\n            }\n            if (lexeme == \">\" && (nextLexeme == \">\" || nextLexeme == \"=\")) {\n                let foundLessThan = false;\n                let ti = this._tokens.length - 1;\n                for (let count = 0; count < 5 && ti >= 0; ++count, --ti) {\n                    if (TokenTypes.assignment_operators.indexOf(this._tokens[ti].type) !== -1) {\n                        break;\n                    }\n                    if (this._tokens[ti].type === TokenTypes.tokens.less_than) {\n                        if (ti > 0 && this._tokens[ti - 1].isArrayOrTemplateType()) {\n                            foundLessThan = true;\n                        }\n                        break;\n                    }\n                }\n                // If there was a less_than in the recent token history, then this is probably a\n                // greater_than.\n                if (foundLessThan) {\n                    this._addToken(matchedType);\n                    return true;\n                }\n            }\n            // The current lexeme may not match any rule, but some token types may be invalid for\n            // part of the string but valid after a few more characters.\n            // For example, 0x.5 is a hex_float_literal. But as it's being scanned,\n            // \"0\" is a int_literal, then \"0x\" is invalid. If we stopped there, it would return\n            // the int_literal \"0\", but that's incorrect. So if we look forward a few characters,\n            // we'd get \"0x.\", which is still invalid, followed by \"0x.5\" which is the correct\n            // hex_float_literal. So that means if we hit an non-matching string, we should look\n            // ahead up to two characters to see if the string starts matching a valid rule again.\n            if (matchedType === TokenTypes.none) {\n                let lookAheadLexeme = lexeme;\n                let lookAhead = 0;\n                const maxLookAhead = 2;\n                for (let li = 0; li < maxLookAhead; ++li) {\n                    lookAheadLexeme += this._peekAhead(li);\n                    matchedType = this._findType(lookAheadLexeme);\n                    if (matchedType !== TokenTypes.none) {\n                        lookAhead = li;\n                        break;\n                    }\n                }\n                if (matchedType === TokenTypes.none) {\n                    if (matchType === TokenTypes.none) {\n                        return false;\n                    }\n                    this._current--;\n                    this._addToken(matchType);\n                    return true;\n                }\n                lexeme = lookAheadLexeme;\n                this._current += lookAhead + 1;\n            }\n            matchType = matchedType;\n            if (this._isAtEnd()) {\n                break;\n            }\n            lexeme += this._advance();\n        }\n        // We got to the end of the input stream. Then the token we've ready so far is it.\n        if (matchType === TokenTypes.none) {\n            return false;\n        }\n        this._addToken(matchType);\n        return true;\n    }\n    _findType(lexeme) {\n        for (const name in TokenTypes.regexTokens) {\n            const type = TokenTypes.regexTokens[name];\n            if (this._match(lexeme, type.rule)) {\n                return type;\n            }\n        }\n        const type = TokenTypes.literalTokens[lexeme];\n        if (type) {\n            return type;\n        }\n        return TokenTypes.none;\n    }\n    _match(lexeme, rule) {\n        const match = rule.exec(lexeme);\n        return match && match.index == 0 && match[0] == lexeme;\n    }\n    _isAtEnd() {\n        return this._current >= this._source.length;\n    }\n    _isAlpha(c) {\n        return (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n    }\n    _isAlphaNumeric(c) {\n        return (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\") || c == \"_\" || (c >= \"0\" && c <= \"9\");\n    }\n    _isWhitespace(c) {\n        return c == \" \" || c == \"\\t\" || c == \"\\r\";\n    }\n    _advance(amount = 0) {\n        let c = this._source[this._current];\n        amount = amount || 0;\n        amount++;\n        this._current += amount;\n        return c;\n    }\n    _peekAhead(offset = 0) {\n        offset = offset || 0;\n        if (this._current + offset >= this._source.length) {\n            return \"\\0\";\n        }\n        return this._source[this._current + offset];\n    }\n    _addToken(type) {\n        const text = this._source.substring(this._start, this._current);\n        this._tokens.push(new Token(type, text, this._line));\n    }\n}\n\n/**\n * @author Brendan Duncan / https://github.com/brendan-duncan\n */\n/// Parse a sequence of tokens from the WgslScanner into an Abstract Syntax Tree (AST).\nclass WgslParser {\n    constructor() {\n        this._tokens = [];\n        this._current = 0;\n        this._currentLine = 0;\n        this._context = new ParseContext();\n        this._deferArrayCountEval = [];\n    }\n    parse(tokensOrCode) {\n        this._initialize(tokensOrCode);\n        this._deferArrayCountEval.length = 0;\n        const statements = [];\n        while (!this._isAtEnd()) {\n            const statement = this._global_decl_or_directive();\n            if (!statement) {\n                break;\n            }\n            statements.push(statement);\n        }\n        // Since constants can be declared after they are used, and\n        // constants can be used to size arrays, defer calculating the\n        // size until after the shader has finished parsing.\n        if (this._deferArrayCountEval.length > 0) {\n            for (const arrayDecl of this._deferArrayCountEval) {\n                const arrayType = arrayDecl[\"arrayType\"];\n                const countNode = arrayDecl[\"countNode\"];\n                if (countNode instanceof VariableExpr) {\n                    const variable = countNode;\n                    const name = variable.name;\n                    const constant = this._context.constants.get(name);\n                    if (constant) {\n                        try {\n                            const count = constant.evaluate(this._context);\n                            arrayType.count = count;\n                        }\n                        catch (e) {\n                        }\n                    }\n                }\n            }\n            this._deferArrayCountEval.length = 0;\n        }\n        return statements;\n    }\n    _initialize(tokensOrCode) {\n        if (tokensOrCode) {\n            if (typeof tokensOrCode == \"string\") {\n                const scanner = new WgslScanner(tokensOrCode);\n                this._tokens = scanner.scanTokens();\n            }\n            else {\n                this._tokens = tokensOrCode;\n            }\n        }\n        else {\n            this._tokens = [];\n        }\n        this._current = 0;\n    }\n    _error(token, message) {\n        return {\n            token,\n            message,\n            toString: function () {\n                return `${message}`;\n            },\n        };\n    }\n    _isAtEnd() {\n        return (this._current >= this._tokens.length ||\n            this._peek().type == TokenTypes.eof);\n    }\n    _match(types) {\n        if (types instanceof TokenType) {\n            if (this._check(types)) {\n                this._advance();\n                return true;\n            }\n            return false;\n        }\n        for (let i = 0, l = types.length; i < l; ++i) {\n            const type = types[i];\n            if (this._check(type)) {\n                this._advance();\n                return true;\n            }\n        }\n        return false;\n    }\n    _consume(types, message) {\n        if (this._check(types)) {\n            return this._advance();\n        }\n        throw this._error(this._peek(), message);\n    }\n    _check(types) {\n        if (this._isAtEnd()) {\n            return false;\n        }\n        const tk = this._peek();\n        if (types instanceof Array) {\n            const t = tk.type;\n            const index = types.indexOf(t);\n            return index != -1;\n        }\n        return tk.type == types;\n    }\n    _advance() {\n        var _a, _b;\n        this._currentLine = (_b = (_a = this._peek()) === null || _a === void 0 ? void 0 : _a.line) !== null && _b !== void 0 ? _b : -1;\n        if (!this._isAtEnd()) {\n            this._current++;\n        }\n        return this._previous();\n    }\n    _peek() {\n        return this._tokens[this._current];\n    }\n    _previous() {\n        return this._tokens[this._current - 1];\n    }\n    _global_decl_or_directive() {\n        // semicolon\n        // global_variable_decl semicolon\n        // global_constant_decl semicolon\n        // type_alias semicolon\n        // struct_decl\n        // function_decl\n        // enable_directive\n        // Ignore any stand-alone semicolons\n        while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())\n            ;\n        if (this._match(TokenTypes.keywords.alias)) {\n            const type = this._type_alias();\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\n            return type;\n        }\n        if (this._match(TokenTypes.keywords.diagnostic)) {\n            const directive = this._diagnostic();\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\n            return directive;\n        }\n        if (this._match(TokenTypes.keywords.requires)) {\n            const requires = this._requires_directive();\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\n            return requires;\n        }\n        if (this._match(TokenTypes.keywords.enable)) {\n            const enable = this._enable_directive();\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\n            return enable;\n        }\n        // The following statements have an optional attribute*\n        const attrs = this._attribute();\n        if (this._check(TokenTypes.keywords.var)) {\n            const _var = this._global_variable_decl();\n            if (_var != null) {\n                _var.attributes = attrs;\n            }\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\n            return _var;\n        }\n        if (this._check(TokenTypes.keywords.override)) {\n            const _override = this._override_variable_decl();\n            if (_override != null) {\n                _override.attributes = attrs;\n            }\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\n            return _override;\n        }\n        if (this._check(TokenTypes.keywords.let)) {\n            const _let = this._global_let_decl();\n            if (_let != null) {\n                _let.attributes = attrs;\n            }\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\n            return _let;\n        }\n        if (this._check(TokenTypes.keywords.const)) {\n            const _const = this._global_const_decl();\n            if (_const != null) {\n                _const.attributes = attrs;\n            }\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\n            return _const;\n        }\n        if (this._check(TokenTypes.keywords.struct)) {\n            const _struct = this._struct_decl();\n            if (_struct != null) {\n                _struct.attributes = attrs;\n            }\n            return _struct;\n        }\n        if (this._check(TokenTypes.keywords.fn)) {\n            const _fn = this._function_decl();\n            if (_fn != null) {\n                _fn.attributes = attrs;\n            }\n            return _fn;\n        }\n        return null;\n    }\n    _function_decl() {\n        // attribute* function_header compound_statement\n        // function_header: fn ident paren_left param_list? paren_right (arrow attribute* type_decl)?\n        if (!this._match(TokenTypes.keywords.fn)) {\n            return null;\n        }\n        const startLine = this._currentLine;\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected function name.\").toString();\n        this._consume(TokenTypes.tokens.paren_left, \"Expected '(' for function arguments.\");\n        const args = [];\n        if (!this._check(TokenTypes.tokens.paren_right)) {\n            do {\n                if (this._check(TokenTypes.tokens.paren_right)) {\n                    break;\n                }\n                const argAttrs = this._attribute();\n                const name = this._consume(TokenTypes.tokens.ident, \"Expected argument name.\").toString();\n                this._consume(TokenTypes.tokens.colon, \"Expected ':' for argument type.\");\n                const typeAttrs = this._attribute();\n                const type = this._type_decl();\n                if (type != null) {\n                    type.attributes = typeAttrs;\n                    args.push(new Argument(name, type, argAttrs));\n                }\n            } while (this._match(TokenTypes.tokens.comma));\n        }\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')' after function arguments.\");\n        let _return = null;\n        if (this._match(TokenTypes.tokens.arrow)) {\n            const attrs = this._attribute();\n            _return = this._type_decl();\n            if (_return != null) {\n                _return.attributes = attrs;\n            }\n        }\n        const body = this._compound_statement();\n        const endLine = this._currentLine;\n        return new Function(name, args, _return, body, startLine, endLine);\n    }\n    _compound_statement() {\n        // brace_left statement* brace_right\n        const statements = [];\n        this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for block.\");\n        while (!this._check(TokenTypes.tokens.brace_right)) {\n            const statement = this._statement();\n            if (statement !== null) {\n                statements.push(statement);\n            }\n        }\n        this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for block.\");\n        return statements;\n    }\n    _statement() {\n        // semicolon\n        // return_statement semicolon\n        // if_statement\n        // switch_statement\n        // loop_statement\n        // for_statement\n        // func_call_statement semicolon\n        // variable_statement semicolon\n        // break_statement semicolon\n        // continue_statement semicolon\n        // continuing_statement compound_statement\n        // discard semicolon\n        // assignment_statement semicolon\n        // compound_statement\n        // increment_statement semicolon\n        // decrement_statement semicolon\n        // static_assert_statement semicolon\n        // Ignore any stand-alone semicolons\n        while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())\n            ;\n        if (this._check(TokenTypes.tokens.attr)) {\n            this._attribute();\n        }\n        if (this._check(TokenTypes.keywords.if)) {\n            return this._if_statement();\n        }\n        if (this._check(TokenTypes.keywords.switch)) {\n            return this._switch_statement();\n        }\n        if (this._check(TokenTypes.keywords.loop)) {\n            return this._loop_statement();\n        }\n        if (this._check(TokenTypes.keywords.for)) {\n            return this._for_statement();\n        }\n        if (this._check(TokenTypes.keywords.while)) {\n            return this._while_statement();\n        }\n        if (this._check(TokenTypes.keywords.continuing)) {\n            return this._continuing_statement();\n        }\n        if (this._check(TokenTypes.keywords.static_assert)) {\n            return this._static_assert_statement();\n        }\n        if (this._check(TokenTypes.tokens.brace_left)) {\n            return this._compound_statement();\n        }\n        let result = null;\n        if (this._check(TokenTypes.keywords.return)) {\n            result = this._return_statement();\n        }\n        else if (this._check([\n            TokenTypes.keywords.var,\n            TokenTypes.keywords.let,\n            TokenTypes.keywords.const,\n        ])) {\n            result = this._variable_statement();\n        }\n        else if (this._match(TokenTypes.keywords.discard)) {\n            result = new Discard();\n        }\n        else if (this._match(TokenTypes.keywords.break)) {\n            result = new Break();\n        }\n        else if (this._match(TokenTypes.keywords.continue)) {\n            result = new Continue();\n        }\n        else {\n            result =\n                this._increment_decrement_statement() ||\n                    this._func_call_statement() ||\n                    this._assignment_statement();\n        }\n        if (result != null) {\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';' after statement.\");\n        }\n        return result;\n    }\n    _static_assert_statement() {\n        if (!this._match(TokenTypes.keywords.static_assert)) {\n            return null;\n        }\n        const expression = this._optional_paren_expression();\n        return new StaticAssert(expression);\n    }\n    _while_statement() {\n        if (!this._match(TokenTypes.keywords.while)) {\n            return null;\n        }\n        const condition = this._optional_paren_expression();\n        if (this._check(TokenTypes.tokens.attr)) {\n            this._attribute();\n        }\n        const block = this._compound_statement();\n        return new While(condition, block);\n    }\n    _continuing_statement() {\n        if (!this._match(TokenTypes.keywords.continuing)) {\n            return null;\n        }\n        const block = this._compound_statement();\n        return new Continuing(block);\n    }\n    _for_statement() {\n        // for paren_left for_header paren_right compound_statement\n        if (!this._match(TokenTypes.keywords.for)) {\n            return null;\n        }\n        this._consume(TokenTypes.tokens.paren_left, \"Expected '('.\");\n        // for_header: (variable_statement assignment_statement func_call_statement)? semicolon short_circuit_or_expression? semicolon (assignment_statement func_call_statement)?\n        const init = !this._check(TokenTypes.tokens.semicolon)\n            ? this._for_init()\n            : null;\n        this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\n        const condition = !this._check(TokenTypes.tokens.semicolon)\n            ? this._short_circuit_or_expression()\n            : null;\n        this._consume(TokenTypes.tokens.semicolon, \"Expected ';'.\");\n        const increment = !this._check(TokenTypes.tokens.paren_right)\n            ? this._for_increment()\n            : null;\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')'.\");\n        if (this._check(TokenTypes.tokens.attr)) {\n            this._attribute();\n        }\n        const body = this._compound_statement();\n        return new For(init, condition, increment, body);\n    }\n    _for_init() {\n        // (variable_statement assignment_statement func_call_statement)?\n        return (this._variable_statement() ||\n            this._func_call_statement() ||\n            this._assignment_statement());\n    }\n    _for_increment() {\n        // (assignment_statement func_call_statement increment_statement)?\n        return (this._func_call_statement() ||\n            this._increment_decrement_statement() ||\n            this._assignment_statement());\n    }\n    _variable_statement() {\n        // variable_decl\n        // variable_decl equal short_circuit_or_expression\n        // let (ident variable_ident_decl) equal short_circuit_or_expression\n        // const (ident variable_ident_decl) equal short_circuit_or_expression\n        if (this._check(TokenTypes.keywords.var)) {\n            const _var = this._variable_decl();\n            if (_var === null) {\n                throw this._error(this._peek(), \"Variable declaration expected.\");\n            }\n            let value = null;\n            if (this._match(TokenTypes.tokens.equal)) {\n                value = this._short_circuit_or_expression();\n            }\n            return new Var(_var.name, _var.type, _var.storage, _var.access, value);\n        }\n        if (this._match(TokenTypes.keywords.let)) {\n            const name = this._consume(TokenTypes.tokens.ident, \"Expected name for let.\").toString();\n            let type = null;\n            if (this._match(TokenTypes.tokens.colon)) {\n                const typeAttrs = this._attribute();\n                type = this._type_decl();\n                if (type != null) {\n                    type.attributes = typeAttrs;\n                }\n            }\n            this._consume(TokenTypes.tokens.equal, \"Expected '=' for let.\");\n            const value = this._short_circuit_or_expression();\n            return new Let(name, type, null, null, value);\n        }\n        if (this._match(TokenTypes.keywords.const)) {\n            const name = this._consume(TokenTypes.tokens.ident, \"Expected name for const.\").toString();\n            let type = null;\n            if (this._match(TokenTypes.tokens.colon)) {\n                const typeAttrs = this._attribute();\n                type = this._type_decl();\n                if (type != null) {\n                    type.attributes = typeAttrs;\n                }\n            }\n            this._consume(TokenTypes.tokens.equal, \"Expected '=' for const.\");\n            const value = this._short_circuit_or_expression();\n            return new Const(name, type, null, null, value);\n        }\n        return null;\n    }\n    _increment_decrement_statement() {\n        const savedPos = this._current;\n        const _var = this._unary_expression();\n        if (_var == null) {\n            return null;\n        }\n        if (!this._check(TokenTypes.increment_operators)) {\n            this._current = savedPos;\n            return null;\n        }\n        const token = this._consume(TokenTypes.increment_operators, \"Expected increment operator\");\n        return new Increment(token.type === TokenTypes.tokens.plus_plus\n            ? IncrementOperator.increment\n            : IncrementOperator.decrement, _var);\n    }\n    _assignment_statement() {\n        // (unary_expression underscore) equal short_circuit_or_expression\n        let _var = null;\n        if (this._check(TokenTypes.tokens.brace_right)) {\n            return null;\n        }\n        let isUnderscore = this._match(TokenTypes.tokens.underscore);\n        if (!isUnderscore) {\n            _var = this._unary_expression();\n        }\n        if (!isUnderscore && _var == null) {\n            return null;\n        }\n        const type = this._consume(TokenTypes.assignment_operators, \"Expected assignment operator.\");\n        const value = this._short_circuit_or_expression();\n        return new Assign(AssignOperator.parse(type.lexeme), _var, value);\n    }\n    _func_call_statement() {\n        // ident argument_expression_list\n        if (!this._check(TokenTypes.tokens.ident)) {\n            return null;\n        }\n        const savedPos = this._current;\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected function name.\");\n        const args = this._argument_expression_list();\n        if (args === null) {\n            this._current = savedPos;\n            return null;\n        }\n        return new Call(name.lexeme, args);\n    }\n    _loop_statement() {\n        // loop brace_left statement* continuing_statement? brace_right\n        if (!this._match(TokenTypes.keywords.loop)) {\n            return null;\n        }\n        if (this._check(TokenTypes.tokens.attr)) {\n            this._attribute();\n        }\n        this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for loop.\");\n        // statement*\n        const statements = [];\n        let statement = this._statement();\n        while (statement !== null) {\n            if (Array.isArray(statement)) {\n                for (let s of statement) {\n                    statements.push(s);\n                }\n            }\n            else {\n                statements.push(statement);\n            }\n            statement = this._statement();\n        }\n        // continuing_statement: continuing compound_statement\n        let continuing = null;\n        if (this._match(TokenTypes.keywords.continuing)) {\n            continuing = this._compound_statement();\n        }\n        this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for loop.\");\n        return new Loop(statements, continuing);\n    }\n    _switch_statement() {\n        // switch optional_paren_expression brace_left switch_body+ brace_right\n        if (!this._match(TokenTypes.keywords.switch)) {\n            return null;\n        }\n        const condition = this._optional_paren_expression();\n        if (this._check(TokenTypes.tokens.attr)) {\n            this._attribute();\n        }\n        this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for switch.\");\n        const body = this._switch_body();\n        if (body == null || body.length == 0) {\n            throw this._error(this._previous(), \"Expected 'case' or 'default'.\");\n        }\n        this._consume(TokenTypes.tokens.brace_right, \"Expected '}' for switch.\");\n        return new Switch(condition, body);\n    }\n    _switch_body() {\n        // case case_selectors colon brace_left case_body? brace_right\n        // default colon brace_left case_body? brace_right\n        const cases = [];\n        if (this._match(TokenTypes.keywords.case)) {\n            const selector = this._case_selectors();\n            this._match(TokenTypes.tokens.colon); // colon is optional\n            if (this._check(TokenTypes.tokens.attr)) {\n                this._attribute();\n            }\n            this._consume(TokenTypes.tokens.brace_left, \"Exected '{' for switch case.\");\n            const body = this._case_body();\n            this._consume(TokenTypes.tokens.brace_right, \"Exected '}' for switch case.\");\n            cases.push(new Case(selector, body));\n        }\n        if (this._match(TokenTypes.keywords.default)) {\n            this._match(TokenTypes.tokens.colon); // colon is optional\n            if (this._check(TokenTypes.tokens.attr)) {\n                this._attribute();\n            }\n            this._consume(TokenTypes.tokens.brace_left, \"Exected '{' for switch default.\");\n            const body = this._case_body();\n            this._consume(TokenTypes.tokens.brace_right, \"Exected '}' for switch default.\");\n            cases.push(new Default(body));\n        }\n        if (this._check([TokenTypes.keywords.default, TokenTypes.keywords.case])) {\n            const _cases = this._switch_body();\n            cases.push(_cases[0]);\n        }\n        return cases;\n    }\n    _case_selectors() {\n        // const_literal (comma const_literal)* comma?\n        const selectors = [\n            this._shift_expression(), //?.evaluate(this._context).toString() ?? \"\",\n        ];\n        while (this._match(TokenTypes.tokens.comma)) {\n            selectors.push(this._shift_expression());\n        }\n        return selectors;\n    }\n    _case_body() {\n        // statement case_body?\n        // fallthrough semicolon\n        if (this._match(TokenTypes.keywords.fallthrough)) {\n            this._consume(TokenTypes.tokens.semicolon, \"Expected ';'\");\n            return [];\n        }\n        let statement = this._statement();\n        if (statement == null) {\n            return [];\n        }\n        if (!(statement instanceof Array)) {\n            statement = [statement];\n        }\n        const nextStatement = this._case_body();\n        if (nextStatement.length == 0) {\n            return statement;\n        }\n        return [...statement, nextStatement[0]];\n    }\n    _if_statement() {\n        // if optional_paren_expression compound_statement elseif_statement? else_statement?\n        if (!this._match(TokenTypes.keywords.if)) {\n            return null;\n        }\n        const condition = this._optional_paren_expression();\n        if (this._check(TokenTypes.tokens.attr)) {\n            this._attribute();\n        }\n        const block = this._compound_statement();\n        let elseif = [];\n        if (this._match_elseif()) {\n            if (this._check(TokenTypes.tokens.attr)) {\n                this._attribute();\n            }\n            elseif = this._elseif_statement(elseif);\n        }\n        let _else = null;\n        if (this._match(TokenTypes.keywords.else)) {\n            if (this._check(TokenTypes.tokens.attr)) {\n                this._attribute();\n            }\n            _else = this._compound_statement();\n        }\n        return new If(condition, block, elseif, _else);\n    }\n    _match_elseif() {\n        if (this._tokens[this._current].type === TokenTypes.keywords.else &&\n            this._tokens[this._current + 1].type === TokenTypes.keywords.if) {\n            this._advance();\n            this._advance();\n            return true;\n        }\n        return false;\n    }\n    _elseif_statement(elseif = []) {\n        // else_if optional_paren_expression compound_statement elseif_statement?\n        const condition = this._optional_paren_expression();\n        const block = this._compound_statement();\n        elseif.push(new ElseIf(condition, block));\n        if (this._match_elseif()) {\n            if (this._check(TokenTypes.tokens.attr)) {\n                this._attribute();\n            }\n            this._elseif_statement(elseif);\n        }\n        return elseif;\n    }\n    _return_statement() {\n        // return short_circuit_or_expression?\n        if (!this._match(TokenTypes.keywords.return)) {\n            return null;\n        }\n        const value = this._short_circuit_or_expression();\n        return new Return(value);\n    }\n    _short_circuit_or_expression() {\n        // short_circuit_and_expression\n        // short_circuit_or_expression or_or short_circuit_and_expression\n        let expr = this._short_circuit_and_expr();\n        while (this._match(TokenTypes.tokens.or_or)) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._short_circuit_and_expr());\n        }\n        return expr;\n    }\n    _short_circuit_and_expr() {\n        // inclusive_or_expression\n        // short_circuit_and_expression and_and inclusive_or_expression\n        let expr = this._inclusive_or_expression();\n        while (this._match(TokenTypes.tokens.and_and)) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._inclusive_or_expression());\n        }\n        return expr;\n    }\n    _inclusive_or_expression() {\n        // exclusive_or_expression\n        // inclusive_or_expression or exclusive_or_expression\n        let expr = this._exclusive_or_expression();\n        while (this._match(TokenTypes.tokens.or)) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._exclusive_or_expression());\n        }\n        return expr;\n    }\n    _exclusive_or_expression() {\n        // and_expression\n        // exclusive_or_expression xor and_expression\n        let expr = this._and_expression();\n        while (this._match(TokenTypes.tokens.xor)) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._and_expression());\n        }\n        return expr;\n    }\n    _and_expression() {\n        // equality_expression\n        // and_expression and equality_expression\n        let expr = this._equality_expression();\n        while (this._match(TokenTypes.tokens.and)) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._equality_expression());\n        }\n        return expr;\n    }\n    _equality_expression() {\n        // relational_expression\n        // relational_expression equal_equal relational_expression\n        // relational_expression not_equal relational_expression\n        const expr = this._relational_expression();\n        if (this._match([TokenTypes.tokens.equal_equal, TokenTypes.tokens.not_equal])) {\n            return new BinaryOperator(this._previous().toString(), expr, this._relational_expression());\n        }\n        return expr;\n    }\n    _relational_expression() {\n        // shift_expression\n        // relational_expression less_than shift_expression\n        // relational_expression greater_than shift_expression\n        // relational_expression less_than_equal shift_expression\n        // relational_expression greater_than_equal shift_expression\n        let expr = this._shift_expression();\n        while (this._match([\n            TokenTypes.tokens.less_than,\n            TokenTypes.tokens.greater_than,\n            TokenTypes.tokens.less_than_equal,\n            TokenTypes.tokens.greater_than_equal,\n        ])) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._shift_expression());\n        }\n        return expr;\n    }\n    _shift_expression() {\n        // additive_expression\n        // shift_expression shift_left additive_expression\n        // shift_expression shift_right additive_expression\n        let expr = this._additive_expression();\n        while (this._match([TokenTypes.tokens.shift_left, TokenTypes.tokens.shift_right])) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._additive_expression());\n        }\n        return expr;\n    }\n    _additive_expression() {\n        // multiplicative_expression\n        // additive_expression plus multiplicative_expression\n        // additive_expression minus multiplicative_expression\n        let expr = this._multiplicative_expression();\n        while (this._match([TokenTypes.tokens.plus, TokenTypes.tokens.minus])) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._multiplicative_expression());\n        }\n        return expr;\n    }\n    _multiplicative_expression() {\n        // unary_expression\n        // multiplicative_expression star unary_expression\n        // multiplicative_expression forward_slash unary_expression\n        // multiplicative_expression modulo unary_expression\n        let expr = this._unary_expression();\n        while (this._match([\n            TokenTypes.tokens.star,\n            TokenTypes.tokens.forward_slash,\n            TokenTypes.tokens.modulo,\n        ])) {\n            expr = new BinaryOperator(this._previous().toString(), expr, this._unary_expression());\n        }\n        return expr;\n    }\n    _unary_expression() {\n        // singular_expression\n        // minus unary_expression\n        // bang unary_expression\n        // tilde unary_expression\n        // star unary_expression\n        // and unary_expression\n        if (this._match([\n            TokenTypes.tokens.minus,\n            TokenTypes.tokens.bang,\n            TokenTypes.tokens.tilde,\n            TokenTypes.tokens.star,\n            TokenTypes.tokens.and,\n        ])) {\n            return new UnaryOperator(this._previous().toString(), this._unary_expression());\n        }\n        return this._singular_expression();\n    }\n    _singular_expression() {\n        // primary_expression postfix_expression ?\n        const expr = this._primary_expression();\n        const p = this._postfix_expression();\n        if (p) {\n            expr.postfix = p;\n        }\n        return expr;\n    }\n    _postfix_expression() {\n        // bracket_left short_circuit_or_expression bracket_right postfix_expression?\n        if (this._match(TokenTypes.tokens.bracket_left)) {\n            const expr = this._short_circuit_or_expression();\n            this._consume(TokenTypes.tokens.bracket_right, \"Expected ']'.\");\n            const arrayIndex = new ArrayIndex(expr);\n            const p = this._postfix_expression();\n            if (p) {\n                arrayIndex.postfix = p;\n            }\n            return arrayIndex;\n        }\n        // period ident postfix_expression?\n        if (this._match(TokenTypes.tokens.period)) {\n            const name = this._consume(TokenTypes.tokens.ident, \"Expected member name.\");\n            const p = this._postfix_expression();\n            const expr = new StringExpr(name.lexeme);\n            if (p) {\n                expr.postfix = p;\n            }\n            return expr;\n        }\n        return null;\n    }\n    _getStruct(name) {\n        if (this._context.aliases.has(name)) {\n            const alias = this._context.aliases.get(name).type;\n            return alias;\n        }\n        if (this._context.structs.has(name)) {\n            const struct = this._context.structs.get(name);\n            return struct;\n        }\n        return null;\n    }\n    _primary_expression() {\n        // ident argument_expression_list?\n        if (this._match(TokenTypes.tokens.ident)) {\n            const name = this._previous().toString();\n            if (this._check(TokenTypes.tokens.paren_left)) {\n                const args = this._argument_expression_list();\n                const struct = this._getStruct(name);\n                if (struct != null) {\n                    return new CreateExpr(struct, args);\n                }\n                return new CallExpr(name, args);\n            }\n            if (this._context.constants.has(name)) {\n                const c = this._context.constants.get(name);\n                return new ConstExpr(name, c.value);\n            }\n            return new VariableExpr(name);\n        }\n        // const_literal\n        if (this._match(TokenTypes.const_literal)) {\n            return new LiteralExpr(parseFloat(this._previous().toString()));\n        }\n        // paren_expression\n        if (this._check(TokenTypes.tokens.paren_left)) {\n            return this._paren_expression();\n        }\n        // bitcast less_than type_decl greater_than paren_expression\n        if (this._match(TokenTypes.keywords.bitcast)) {\n            this._consume(TokenTypes.tokens.less_than, \"Expected '<'.\");\n            const type = this._type_decl();\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>'.\");\n            const value = this._paren_expression();\n            return new BitcastExpr(type, value);\n        }\n        // type_decl argument_expression_list\n        const type = this._type_decl();\n        const args = this._argument_expression_list();\n        return new TypecastExpr(type, args);\n    }\n    _argument_expression_list() {\n        // paren_left ((short_circuit_or_expression comma)* short_circuit_or_expression comma?)? paren_right\n        if (!this._match(TokenTypes.tokens.paren_left)) {\n            return null;\n        }\n        const args = [];\n        do {\n            if (this._check(TokenTypes.tokens.paren_right)) {\n                break;\n            }\n            const arg = this._short_circuit_or_expression();\n            args.push(arg);\n        } while (this._match(TokenTypes.tokens.comma));\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')' for agument list\");\n        return args;\n    }\n    _optional_paren_expression() {\n        // [paren_left] short_circuit_or_expression [paren_right]\n        this._match(TokenTypes.tokens.paren_left);\n        const expr = this._short_circuit_or_expression();\n        this._match(TokenTypes.tokens.paren_right);\n        return new GroupingExpr([expr]);\n    }\n    _paren_expression() {\n        // paren_left short_circuit_or_expression paren_right\n        this._consume(TokenTypes.tokens.paren_left, \"Expected '('.\");\n        const expr = this._short_circuit_or_expression();\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')'.\");\n        return new GroupingExpr([expr]);\n    }\n    _struct_decl() {\n        // attribute* struct ident struct_body_decl\n        if (!this._match(TokenTypes.keywords.struct)) {\n            return null;\n        }\n        const startLine = this._currentLine;\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected name for struct.\").toString();\n        // struct_body_decl: brace_left (struct_member comma)* struct_member comma? brace_right\n        this._consume(TokenTypes.tokens.brace_left, \"Expected '{' for struct body.\");\n        const members = [];\n        while (!this._check(TokenTypes.tokens.brace_right)) {\n            // struct_member: attribute* variable_ident_decl\n            const memberAttrs = this._attribute();\n            const memberName = this._consume(TokenTypes.tokens.ident, \"Expected variable name.\").toString();\n            this._consume(TokenTypes.tokens.colon, \"Expected ':' for struct member type.\");\n            const typeAttrs = this._attribute();\n            const memberType = this._type_decl();\n            if (memberType != null) {\n                memberType.attributes = typeAttrs;\n            }\n            if (!this._check(TokenTypes.tokens.brace_right))\n                this._consume(TokenTypes.tokens.comma, \"Expected ',' for struct member.\");\n            else\n                this._match(TokenTypes.tokens.comma); // trailing comma optional.\n            members.push(new Member(memberName, memberType, memberAttrs));\n        }\n        this._consume(TokenTypes.tokens.brace_right, \"Expected '}' after struct body.\");\n        const endLine = this._currentLine;\n        const structNode = new Struct(name, members, startLine, endLine);\n        this._context.structs.set(name, structNode);\n        return structNode;\n    }\n    _global_variable_decl() {\n        // attribute* variable_decl (equal const_expression)?\n        const _var = this._variable_decl();\n        if (_var && this._match(TokenTypes.tokens.equal)) {\n            _var.value = this._const_expression();\n        }\n        return _var;\n    }\n    _override_variable_decl() {\n        // attribute* override_decl (equal const_expression)?\n        const _override = this._override_decl();\n        if (_override && this._match(TokenTypes.tokens.equal)) {\n            _override.value = this._const_expression();\n        }\n        return _override;\n    }\n    _global_const_decl() {\n        // attribute* const (ident variable_ident_decl) global_const_initializer?\n        if (!this._match(TokenTypes.keywords.const)) {\n            return null;\n        }\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected variable name\");\n        let type = null;\n        if (this._match(TokenTypes.tokens.colon)) {\n            const attrs = this._attribute();\n            type = this._type_decl();\n            if (type != null) {\n                type.attributes = attrs;\n            }\n        }\n        let value = null;\n        if (this._match(TokenTypes.tokens.equal)) {\n            const valueExpr = this._short_circuit_or_expression();\n            if (valueExpr instanceof CreateExpr) {\n                value = valueExpr;\n            }\n            else if (valueExpr instanceof ConstExpr &&\n                valueExpr.initializer instanceof CreateExpr) {\n                value = valueExpr.initializer;\n            }\n            else {\n                try {\n                    const constValue = valueExpr.evaluate(this._context);\n                    value = new LiteralExpr(constValue);\n                }\n                catch (_a) {\n                    value = valueExpr;\n                }\n            }\n        }\n        const c = new Const(name.toString(), type, \"\", \"\", value);\n        this._context.constants.set(c.name, c);\n        return c;\n    }\n    _global_let_decl() {\n        // attribute* let (ident variable_ident_decl) global_const_initializer?\n        if (!this._match(TokenTypes.keywords.let)) {\n            return null;\n        }\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected variable name\");\n        let type = null;\n        if (this._match(TokenTypes.tokens.colon)) {\n            const attrs = this._attribute();\n            type = this._type_decl();\n            if (type != null) {\n                type.attributes = attrs;\n            }\n        }\n        let value = null;\n        if (this._match(TokenTypes.tokens.equal)) {\n            value = this._const_expression();\n        }\n        return new Let(name.toString(), type, \"\", \"\", value);\n    }\n    _const_expression() {\n        // type_decl paren_left ((const_expression comma)* const_expression comma?)? paren_right\n        // const_literal\n        if (this._match(TokenTypes.const_literal)) {\n            return new StringExpr(this._previous().toString());\n        }\n        const type = this._type_decl();\n        this._consume(TokenTypes.tokens.paren_left, \"Expected '('.\");\n        let args = [];\n        while (!this._check(TokenTypes.tokens.paren_right)) {\n            args.push(this._const_expression());\n            if (!this._check(TokenTypes.tokens.comma)) {\n                break;\n            }\n            this._advance();\n        }\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')'.\");\n        return new CreateExpr(type, args);\n    }\n    _variable_decl() {\n        // var variable_qualifier? (ident variable_ident_decl)\n        if (!this._match(TokenTypes.keywords.var)) {\n            return null;\n        }\n        // variable_qualifier: less_than storage_class (comma access_mode)? greater_than\n        let storage = \"\";\n        let access = \"\";\n        if (this._match(TokenTypes.tokens.less_than)) {\n            storage = this._consume(TokenTypes.storage_class, \"Expected storage_class.\").toString();\n            if (this._match(TokenTypes.tokens.comma))\n                access = this._consume(TokenTypes.access_mode, \"Expected access_mode.\").toString();\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>'.\");\n        }\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected variable name\");\n        let type = null;\n        if (this._match(TokenTypes.tokens.colon)) {\n            const attrs = this._attribute();\n            type = this._type_decl();\n            if (type != null) {\n                type.attributes = attrs;\n            }\n        }\n        return new Var(name.toString(), type, storage, access, null);\n    }\n    _override_decl() {\n        // override (ident variable_ident_decl)\n        if (!this._match(TokenTypes.keywords.override)) {\n            return null;\n        }\n        const name = this._consume(TokenTypes.tokens.ident, \"Expected variable name\");\n        let type = null;\n        if (this._match(TokenTypes.tokens.colon)) {\n            const attrs = this._attribute();\n            type = this._type_decl();\n            if (type != null) {\n                type.attributes = attrs;\n            }\n        }\n        return new Override(name.toString(), type, null);\n    }\n    _diagnostic() {\n        // diagnostic(severity_control_name, diagnostic_rule_name)\n        this._consume(TokenTypes.tokens.paren_left, \"Expected '('\");\n        const severity = this._consume(TokenTypes.tokens.ident, \"Expected severity control name.\");\n        this._consume(TokenTypes.tokens.comma, \"Expected ','\");\n        const rule = this._consume(TokenTypes.tokens.ident, \"Expected diagnostic rule name.\");\n        this._consume(TokenTypes.tokens.paren_right, \"Expected ')'\");\n        return new Diagnostic(severity.toString(), rule.toString());\n    }\n    _enable_directive() {\n        // enable ident semicolon\n        const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\n        return new Enable(name.toString());\n    }\n    _requires_directive() {\n        // requires extension [, extension]* semicolon\n        const extensions = [this._consume(TokenTypes.tokens.ident, \"identity expected.\").toString()];\n        while (this._match(TokenTypes.tokens.comma)) {\n            const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\n            extensions.push(name.toString());\n        }\n        return new Requires(extensions);\n    }\n    _type_alias() {\n        // type ident equal type_decl\n        const name = this._consume(TokenTypes.tokens.ident, \"identity expected.\");\n        this._consume(TokenTypes.tokens.equal, \"Expected '=' for type alias.\");\n        let aliasType = this._type_decl();\n        if (aliasType === null) {\n            throw this._error(this._peek(), \"Expected Type for Alias.\");\n        }\n        if (this._context.aliases.has(aliasType.name)) {\n            aliasType = this._context.aliases.get(aliasType.name).type;\n        }\n        const aliasNode = new Alias(name.toString(), aliasType);\n        this._context.aliases.set(aliasNode.name, aliasNode);\n        return aliasNode;\n    }\n    _type_decl() {\n        // ident\n        // bool\n        // float32\n        // int32\n        // uint32\n        // vec2 less_than type_decl greater_than\n        // vec3 less_than type_decl greater_than\n        // vec4 less_than type_decl greater_than\n        // mat2x2 less_than type_decl greater_than\n        // mat2x3 less_than type_decl greater_than\n        // mat2x4 less_than type_decl greater_than\n        // mat3x2 less_than type_decl greater_than\n        // mat3x3 less_than type_decl greater_than\n        // mat3x4 less_than type_decl greater_than\n        // mat4x2 less_than type_decl greater_than\n        // mat4x3 less_than type_decl greater_than\n        // mat4x4 less_than type_decl greater_than\n        // atomic less_than type_decl greater_than\n        // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\n        // array_type_decl\n        // texture_sampler_types\n        if (this._check([\n            TokenTypes.tokens.ident,\n            ...TokenTypes.texel_format,\n            TokenTypes.keywords.bool,\n            TokenTypes.keywords.f32,\n            TokenTypes.keywords.i32,\n            TokenTypes.keywords.u32,\n        ])) {\n            const type = this._advance();\n            const typeName = type.toString();\n            if (this._context.structs.has(typeName)) {\n                return this._context.structs.get(typeName);\n            }\n            if (this._context.aliases.has(typeName)) {\n                return this._context.aliases.get(typeName).type;\n            }\n            return new Type(type.toString());\n        }\n        // texture_sampler_types\n        let type = this._texture_sampler_types();\n        if (type) {\n            return type;\n        }\n        if (this._check(TokenTypes.template_types)) {\n            let type = this._advance().toString();\n            let format = null;\n            let access = null;\n            if (this._match(TokenTypes.tokens.less_than)) {\n                format = this._type_decl();\n                access = null;\n                if (this._match(TokenTypes.tokens.comma)) {\n                    access = this._consume(TokenTypes.access_mode, \"Expected access_mode for pointer\").toString();\n                }\n                this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for type.\");\n            }\n            return new TemplateType(type, format, access);\n        }\n        // pointer less_than storage_class comma type_decl (comma access_mode)? greater_than\n        if (this._match(TokenTypes.keywords.ptr)) {\n            let pointer = this._previous().toString();\n            this._consume(TokenTypes.tokens.less_than, \"Expected '<' for pointer.\");\n            const storage = this._consume(TokenTypes.storage_class, \"Expected storage_class for pointer\");\n            this._consume(TokenTypes.tokens.comma, \"Expected ',' for pointer.\");\n            const decl = this._type_decl();\n            let access = null;\n            if (this._match(TokenTypes.tokens.comma)) {\n                access = this._consume(TokenTypes.access_mode, \"Expected access_mode for pointer\").toString();\n            }\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for pointer.\");\n            return new PointerType(pointer, storage.toString(), decl, access);\n        }\n        // The following type_decl's have an optional attribyte_list*\n        const attrs = this._attribute();\n        // attribute* array\n        // attribute* array less_than type_decl (comma element_count_expression)? greater_than\n        if (this._match(TokenTypes.keywords.array)) {\n            let format = null;\n            let countInt = -1;\n            const array = this._previous();\n            let countNode = null;\n            if (this._match(TokenTypes.tokens.less_than)) {\n                format = this._type_decl();\n                if (this._context.aliases.has(format.name)) {\n                    format = this._context.aliases.get(format.name).type;\n                }\n                let count = \"\";\n                if (this._match(TokenTypes.tokens.comma)) {\n                    countNode = this._shift_expression();\n                    // If we can't evaluate the node, defer evaluating it until after the shader has\n                    // finished being parsed, because const statements can be declared **after** they\n                    // are used.\n                    try {\n                        count = countNode.evaluate(this._context).toString();\n                        countNode = null;\n                    }\n                    catch (e) {\n                        count = \"1\";\n                    }\n                }\n                this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for array.\");\n                countInt = count ? parseInt(count) : 0;\n            }\n            const arrayType = new ArrayType(array.toString(), attrs, format, countInt);\n            if (countNode) {\n                this._deferArrayCountEval.push({ arrayType, countNode });\n            }\n            return arrayType;\n        }\n        return null;\n    }\n    _texture_sampler_types() {\n        // sampler_type\n        if (this._match(TokenTypes.sampler_type)) {\n            return new SamplerType(this._previous().toString(), null, null);\n        }\n        // depth_texture_type\n        if (this._match(TokenTypes.depth_texture_type)) {\n            return new SamplerType(this._previous().toString(), null, null);\n        }\n        // sampled_texture_type less_than type_decl greater_than\n        // multisampled_texture_type less_than type_decl greater_than\n        if (this._match(TokenTypes.sampled_texture_type) ||\n            this._match(TokenTypes.multisampled_texture_type)) {\n            const sampler = this._previous();\n            this._consume(TokenTypes.tokens.less_than, \"Expected '<' for sampler type.\");\n            const format = this._type_decl();\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for sampler type.\");\n            return new SamplerType(sampler.toString(), format, null);\n        }\n        // storage_texture_type less_than texel_format comma access_mode greater_than\n        if (this._match(TokenTypes.storage_texture_type)) {\n            const sampler = this._previous();\n            this._consume(TokenTypes.tokens.less_than, \"Expected '<' for sampler type.\");\n            const format = this._consume(TokenTypes.texel_format, \"Invalid texel format.\").toString();\n            this._consume(TokenTypes.tokens.comma, \"Expected ',' after texel format.\");\n            const access = this._consume(TokenTypes.access_mode, \"Expected access mode for storage texture type.\").toString();\n            this._consume(TokenTypes.tokens.greater_than, \"Expected '>' for sampler type.\");\n            return new SamplerType(sampler.toString(), format, access);\n        }\n        return null;\n    }\n    _attribute() {\n        // attr ident paren_left (literal_or_ident comma)* literal_or_ident paren_right\n        // attr ident\n        let attributes = [];\n        while (this._match(TokenTypes.tokens.attr)) {\n            const name = this._consume(TokenTypes.attribute_name, \"Expected attribute name\");\n            const attr = new Attribute(name.toString(), null);\n            if (this._match(TokenTypes.tokens.paren_left)) {\n                // literal_or_ident\n                attr.value = this._consume(TokenTypes.literal_or_ident, \"Expected attribute value\").toString();\n                if (this._check(TokenTypes.tokens.comma)) {\n                    this._advance();\n                    do {\n                        const v = this._consume(TokenTypes.literal_or_ident, \"Expected attribute value\").toString();\n                        if (!(attr.value instanceof Array)) {\n                            attr.value = [attr.value];\n                        }\n                        attr.value.push(v);\n                    } while (this._match(TokenTypes.tokens.comma));\n                }\n                this._consume(TokenTypes.tokens.paren_right, \"Expected ')'\");\n            }\n            attributes.push(attr);\n        }\n        if (attributes.length == 0) {\n            return null;\n        }\n        return attributes;\n    }\n}\n\n/**\n * @author Brendan Duncan / https://github.com/brendan-duncan\n */\nclass TypeInfo {\n    constructor(name, attributes) {\n        this.name = name;\n        this.attributes = attributes;\n        this.size = 0;\n    }\n    get isArray() {\n        return false;\n    }\n    get isStruct() {\n        return false;\n    }\n    get isTemplate() {\n        return false;\n    }\n}\nclass MemberInfo {\n    constructor(name, type, attributes) {\n        this.name = name;\n        this.type = type;\n        this.attributes = attributes;\n        this.offset = 0;\n        this.size = 0;\n    }\n    get isArray() {\n        return this.type.isArray;\n    }\n    get isStruct() {\n        return this.type.isStruct;\n    }\n    get isTemplate() {\n        return this.type.isTemplate;\n    }\n    get align() {\n        return this.type.isStruct ? this.type.align : 0;\n    }\n    get members() {\n        return this.type.isStruct ? this.type.members : null;\n    }\n    get format() {\n        return this.type.isArray\n            ? this.type.format\n            : this.type.isTemplate\n                ? this.type.format\n                : null;\n    }\n    get count() {\n        return this.type.isArray ? this.type.count : 0;\n    }\n    get stride() {\n        return this.type.isArray ? this.type.stride : this.size;\n    }\n}\nclass StructInfo extends TypeInfo {\n    constructor(name, attributes) {\n        super(name, attributes);\n        this.members = [];\n        this.align = 0;\n        this.startLine = -1;\n        this.endLine = -1;\n        this.inUse = false;\n    }\n    get isStruct() {\n        return true;\n    }\n}\nclass ArrayInfo extends TypeInfo {\n    constructor(name, attributes) {\n        super(name, attributes);\n        this.count = 0;\n        this.stride = 0;\n    }\n    get isArray() {\n        return true;\n    }\n}\nclass TemplateInfo extends TypeInfo {\n    constructor(name, format, attributes, access) {\n        super(name, attributes);\n        this.format = format;\n        this.access = access;\n    }\n    get isTemplate() {\n        return true;\n    }\n}\nvar ResourceType;\n(function (ResourceType) {\n    ResourceType[ResourceType[\"Uniform\"] = 0] = \"Uniform\";\n    ResourceType[ResourceType[\"Storage\"] = 1] = \"Storage\";\n    ResourceType[ResourceType[\"Texture\"] = 2] = \"Texture\";\n    ResourceType[ResourceType[\"Sampler\"] = 3] = \"Sampler\";\n    ResourceType[ResourceType[\"StorageTexture\"] = 4] = \"StorageTexture\";\n})(ResourceType || (ResourceType = {}));\nclass VariableInfo {\n    constructor(name, type, group, binding, attributes, resourceType, access) {\n        this.name = name;\n        this.type = type;\n        this.group = group;\n        this.binding = binding;\n        this.attributes = attributes;\n        this.resourceType = resourceType;\n        this.access = access;\n    }\n    get isArray() {\n        return this.type.isArray;\n    }\n    get isStruct() {\n        return this.type.isStruct;\n    }\n    get isTemplate() {\n        return this.type.isTemplate;\n    }\n    get size() {\n        return this.type.size;\n    }\n    get align() {\n        return this.type.isStruct ? this.type.align : 0;\n    }\n    get members() {\n        return this.type.isStruct ? this.type.members : null;\n    }\n    get format() {\n        return this.type.isArray\n            ? this.type.format\n            : this.type.isTemplate\n                ? this.type.format\n                : null;\n    }\n    get count() {\n        return this.type.isArray ? this.type.count : 0;\n    }\n    get stride() {\n        return this.type.isArray ? this.type.stride : this.size;\n    }\n}\nclass AliasInfo {\n    constructor(name, type) {\n        this.name = name;\n        this.type = type;\n    }\n}\nclass _TypeSize {\n    constructor(align, size) {\n        this.align = align;\n        this.size = size;\n    }\n}\nclass InputInfo {\n    constructor(name, type, locationType, location) {\n        this.name = name;\n        this.type = type;\n        this.locationType = locationType;\n        this.location = location;\n        this.interpolation = null;\n    }\n}\nclass OutputInfo {\n    constructor(name, type, locationType, location) {\n        this.name = name;\n        this.type = type;\n        this.locationType = locationType;\n        this.location = location;\n    }\n}\nclass FunctionInfo {\n    constructor(name, stage = null) {\n        this.stage = null;\n        this.inputs = [];\n        this.outputs = [];\n        this.resources = [];\n        this.startLine = -1;\n        this.endLine = -1;\n        this.inUse = false;\n        this.calls = new Set();\n        this.name = name;\n        this.stage = stage;\n    }\n}\nclass EntryFunctions {\n    constructor() {\n        this.vertex = [];\n        this.fragment = [];\n        this.compute = [];\n    }\n}\nclass OverrideInfo {\n    constructor(name, type, attributes, id) {\n        this.name = name;\n        this.type = type;\n        this.attributes = attributes;\n        this.id = id;\n    }\n}\nclass _FunctionResources {\n    constructor(node) {\n        this.resources = null;\n        this.inUse = false;\n        this.info = null;\n        this.node = node;\n    }\n}\nclass WgslReflect {\n    constructor(code) {\n        /// All top-level uniform vars in the shader.\n        this.uniforms = [];\n        /// All top-level storage vars in the shader.\n        this.storage = [];\n        /// All top-level texture vars in the shader;\n        this.textures = [];\n        // All top-level sampler vars in the shader.\n        this.samplers = [];\n        /// All top-level type aliases in the shader.\n        this.aliases = [];\n        /// All top-level overrides in the shader.\n        this.overrides = [];\n        /// All top-level structs in the shader.\n        this.structs = [];\n        /// All entry functions in the shader: vertex, fragment, and/or compute.\n        this.entry = new EntryFunctions();\n        /// All functions in the shader, including entry functions.\n        this.functions = [];\n        this._types = new Map();\n        this._functions = new Map();\n        if (code) {\n            this.update(code);\n        }\n    }\n    _isStorageTexture(type) {\n        return (type.name == \"texture_storage_1d\" ||\n            type.name == \"texture_storage_2d\" ||\n            type.name == \"texture_storage_2d_array\" ||\n            type.name == \"texture_storage_3d\");\n    }\n    update(code) {\n        const parser = new WgslParser();\n        const ast = parser.parse(code);\n        for (const node of ast) {\n            if (node instanceof Function) {\n                this._functions.set(node.name, new _FunctionResources(node));\n            }\n        }\n        for (const node of ast) {\n            if (node instanceof Struct) {\n                const info = this._getTypeInfo(node, null);\n                if (info instanceof StructInfo) {\n                    this.structs.push(info);\n                }\n            }\n        }\n        for (const node of ast) {\n            if (node instanceof Alias) {\n                this.aliases.push(this._getAliasInfo(node));\n                continue;\n            }\n            if (node instanceof Override) {\n                const v = node;\n                const id = this._getAttributeNum(v.attributes, \"id\", 0);\n                const type = v.type != null ? this._getTypeInfo(v.type, v.attributes) : null;\n                this.overrides.push(new OverrideInfo(v.name, type, v.attributes, id));\n                continue;\n            }\n            if (this._isUniformVar(node)) {\n                const v = node;\n                const g = this._getAttributeNum(v.attributes, \"group\", 0);\n                const b = this._getAttributeNum(v.attributes, \"binding\", 0);\n                const type = this._getTypeInfo(v.type, v.attributes);\n                const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, ResourceType.Uniform, v.access);\n                this.uniforms.push(varInfo);\n                continue;\n            }\n            if (this._isStorageVar(node)) {\n                const v = node;\n                const g = this._getAttributeNum(v.attributes, \"group\", 0);\n                const b = this._getAttributeNum(v.attributes, \"binding\", 0);\n                const type = this._getTypeInfo(v.type, v.attributes);\n                const isStorageTexture = this._isStorageTexture(type);\n                const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Storage, v.access);\n                this.storage.push(varInfo);\n                continue;\n            }\n            if (this._isTextureVar(node)) {\n                const v = node;\n                const g = this._getAttributeNum(v.attributes, \"group\", 0);\n                const b = this._getAttributeNum(v.attributes, \"binding\", 0);\n                const type = this._getTypeInfo(v.type, v.attributes);\n                const isStorageTexture = this._isStorageTexture(type);\n                const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Texture, v.access);\n                if (isStorageTexture) {\n                    this.storage.push(varInfo);\n                }\n                else {\n                    this.textures.push(varInfo);\n                }\n                continue;\n            }\n            if (this._isSamplerVar(node)) {\n                const v = node;\n                const g = this._getAttributeNum(v.attributes, \"group\", 0);\n                const b = this._getAttributeNum(v.attributes, \"binding\", 0);\n                const type = this._getTypeInfo(v.type, v.attributes);\n                const varInfo = new VariableInfo(v.name, type, g, b, v.attributes, ResourceType.Sampler, v.access);\n                this.samplers.push(varInfo);\n                continue;\n            }\n            if (node instanceof Function) {\n                const vertexStage = this._getAttribute(node, \"vertex\");\n                const fragmentStage = this._getAttribute(node, \"fragment\");\n                const computeStage = this._getAttribute(node, \"compute\");\n                const stage = vertexStage || fragmentStage || computeStage;\n                const fn = new FunctionInfo(node.name, stage === null || stage === void 0 ? void 0 : stage.name);\n                fn.startLine = node.startLine;\n                fn.endLine = node.endLine;\n                this.functions.push(fn);\n                this._functions.get(node.name).info = fn;\n                if (stage) {\n                    this._functions.get(node.name).inUse = true;\n                    fn.inUse = true;\n                    fn.resources = this._findResources(node, !!stage);\n                    fn.inputs = this._getInputs(node.args);\n                    fn.outputs = this._getOutputs(node.returnType);\n                    this.entry[stage.name].push(fn);\n                }\n                continue;\n            }\n        }\n        for (const fn of this._functions.values()) {\n            if (fn.info) {\n                fn.info.inUse = fn.inUse;\n                this._addCalls(fn.node, fn.info.calls);\n            }\n        }\n        for (const u of this.uniforms) {\n            this._markStructsInUse(u.type);\n        }\n        for (const s of this.storage) {\n            this._markStructsInUse(s.type);\n        }\n    }\n    _markStructsInUse(type) {\n        if (type.isStruct) {\n            type.inUse = true;\n            for (const m of type.members) {\n                this._markStructsInUse(m.type);\n            }\n        }\n        else if (type.isArray) {\n            this._markStructsInUse(type.format);\n        }\n        else if (type.isTemplate) {\n            this._markStructsInUse(type.format);\n        }\n        else {\n            const alias = this._getAlias(type.name);\n            if (alias) {\n                this._markStructsInUse(alias);\n            }\n        }\n    }\n    _addCalls(fn, calls) {\n        var _a;\n        for (const call of fn.calls) {\n            const info = (_a = this._functions.get(call.name)) === null || _a === void 0 ? void 0 : _a.info;\n            if (info) {\n                calls.add(info);\n            }\n        }\n    }\n    /// Find a resource by its group and binding.\n    findResource(group, binding) {\n        for (const u of this.uniforms) {\n            if (u.group == group && u.binding == binding) {\n                return u;\n            }\n        }\n        for (const s of this.storage) {\n            if (s.group == group && s.binding == binding) {\n                return s;\n            }\n        }\n        for (const t of this.textures) {\n            if (t.group == group && t.binding == binding) {\n                return t;\n            }\n        }\n        for (const s of this.samplers) {\n            if (s.group == group && s.binding == binding) {\n                return s;\n            }\n        }\n        return null;\n    }\n    _findResource(name) {\n        for (const u of this.uniforms) {\n            if (u.name == name) {\n                return u;\n            }\n        }\n        for (const s of this.storage) {\n            if (s.name == name) {\n                return s;\n            }\n        }\n        for (const t of this.textures) {\n            if (t.name == name) {\n                return t;\n            }\n        }\n        for (const s of this.samplers) {\n            if (s.name == name) {\n                return s;\n            }\n        }\n        return null;\n    }\n    _markStructsFromAST(type) {\n        const info = this._getTypeInfo(type, null);\n        this._markStructsInUse(info);\n    }\n    _findResources(fn, isEntry) {\n        const resources = [];\n        const self = this;\n        const varStack = [];\n        fn.search((node) => {\n            if (node instanceof _BlockStart) {\n                varStack.push({});\n            }\n            else if (node instanceof _BlockEnd) {\n                varStack.pop();\n            }\n            else if (node instanceof Var) {\n                const v = node;\n                if (isEntry && v.type !== null) {\n                    this._markStructsFromAST(v.type);\n                }\n                if (varStack.length > 0) {\n                    varStack[varStack.length - 1][v.name] = v;\n                }\n            }\n            else if (node instanceof CreateExpr) {\n                const c = node;\n                if (isEntry && c.type !== null) {\n                    this._markStructsFromAST(c.type);\n                }\n            }\n            else if (node instanceof Let) {\n                const v = node;\n                if (isEntry && v.type !== null) {\n                    this._markStructsFromAST(v.type);\n                }\n                if (varStack.length > 0) {\n                    varStack[varStack.length - 1][v.name] = v;\n                }\n            }\n            else if (node instanceof VariableExpr) {\n                const v = node;\n                // Check to see if the variable is a local variable before checking to see if it's\n                // a resource.\n                if (varStack.length > 0) {\n                    const varInfo = varStack[varStack.length - 1][v.name];\n                    if (varInfo) {\n                        return;\n                    }\n                }\n                const varInfo = self._findResource(v.name);\n                if (varInfo) {\n                    resources.push(varInfo);\n                }\n            }\n            else if (node instanceof CallExpr) {\n                const c = node;\n                const callFn = self._functions.get(c.name);\n                if (callFn) {\n                    if (isEntry) {\n                        callFn.inUse = true;\n                    }\n                    fn.calls.add(callFn.node);\n                    if (callFn.resources === null) {\n                        callFn.resources = self._findResources(callFn.node, isEntry);\n                    }\n                    resources.push(...callFn.resources);\n                }\n            }\n            else if (node instanceof Call) {\n                const c = node;\n                const callFn = self._functions.get(c.name);\n                if (callFn) {\n                    if (isEntry) {\n                        callFn.inUse = true;\n                    }\n                    fn.calls.add(callFn.node);\n                    if (callFn.resources === null) {\n                        callFn.resources = self._findResources(callFn.node, isEntry);\n                    }\n                    resources.push(...callFn.resources);\n                }\n            }\n        });\n        return [...new Map(resources.map(r => [r.name, r])).values()];\n    }\n    getBindGroups() {\n        const groups = [];\n        function _makeRoom(group, binding) {\n            if (group >= groups.length) {\n                groups.length = group + 1;\n            }\n            if (groups[group] === undefined) {\n                groups[group] = [];\n            }\n            if (binding >= groups[group].length) {\n                groups[group].length = binding + 1;\n            }\n        }\n        for (const u of this.uniforms) {\n            _makeRoom(u.group, u.binding);\n            const group = groups[u.group];\n            group[u.binding] = u;\n        }\n        for (const u of this.storage) {\n            _makeRoom(u.group, u.binding);\n            const group = groups[u.group];\n            group[u.binding] = u;\n        }\n        for (const t of this.textures) {\n            _makeRoom(t.group, t.binding);\n            const group = groups[t.group];\n            group[t.binding] = t;\n        }\n        for (const t of this.samplers) {\n            _makeRoom(t.group, t.binding);\n            const group = groups[t.group];\n            group[t.binding] = t;\n        }\n        return groups;\n    }\n    _getOutputs(type, outputs = undefined) {\n        if (outputs === undefined) {\n            outputs = [];\n        }\n        if (type instanceof Struct) {\n            this._getStructOutputs(type, outputs);\n        }\n        else {\n            const output = this._getOutputInfo(type);\n            if (output !== null) {\n                outputs.push(output);\n            }\n        }\n        return outputs;\n    }\n    _getStructOutputs(struct, outputs) {\n        for (const m of struct.members) {\n            if (m.type instanceof Struct) {\n                this._getStructOutputs(m.type, outputs);\n            }\n            else {\n                const location = this._getAttribute(m, \"location\") || this._getAttribute(m, \"builtin\");\n                if (location !== null) {\n                    const typeInfo = this._getTypeInfo(m.type, m.type.attributes);\n                    const locationValue = this._parseInt(location.value);\n                    const info = new OutputInfo(m.name, typeInfo, location.name, locationValue);\n                    outputs.push(info);\n                }\n            }\n        }\n    }\n    _getOutputInfo(type) {\n        const location = this._getAttribute(type, \"location\") ||\n            this._getAttribute(type, \"builtin\");\n        if (location !== null) {\n            const typeInfo = this._getTypeInfo(type, type.attributes);\n            const locationValue = this._parseInt(location.value);\n            const info = new OutputInfo(\"\", typeInfo, location.name, locationValue);\n            return info;\n        }\n        return null;\n    }\n    _getInputs(args, inputs = undefined) {\n        if (inputs === undefined) {\n            inputs = [];\n        }\n        for (const arg of args) {\n            if (arg.type instanceof Struct) {\n                this._getStructInputs(arg.type, inputs);\n            }\n            else {\n                const input = this._getInputInfo(arg);\n                if (input !== null) {\n                    inputs.push(input);\n                }\n            }\n        }\n        return inputs;\n    }\n    _getStructInputs(struct, inputs) {\n        for (const m of struct.members) {\n            if (m.type instanceof Struct) {\n                this._getStructInputs(m.type, inputs);\n            }\n            else {\n                const input = this._getInputInfo(m);\n                if (input !== null) {\n                    inputs.push(input);\n                }\n            }\n        }\n    }\n    _getInputInfo(node) {\n        const location = this._getAttribute(node, \"location\") ||\n            this._getAttribute(node, \"builtin\");\n        if (location !== null) {\n            const interpolation = this._getAttribute(node, \"interpolation\");\n            const type = this._getTypeInfo(node.type, node.attributes);\n            const locationValue = this._parseInt(location.value);\n            const info = new InputInfo(node.name, type, location.name, locationValue);\n            if (interpolation !== null) {\n                info.interpolation = this._parseString(interpolation.value);\n            }\n            return info;\n        }\n        return null;\n    }\n    _parseString(s) {\n        if (s instanceof Array) {\n            s = s[0];\n        }\n        return s;\n    }\n    _parseInt(s) {\n        if (s instanceof Array) {\n            s = s[0];\n        }\n        const n = parseInt(s);\n        return isNaN(n) ? s : n;\n    }\n    _getAlias(name) {\n        for (const a of this.aliases) {\n            if (a.name == name) {\n                return a.type;\n            }\n        }\n        return null;\n    }\n    _getAliasInfo(node) {\n        return new AliasInfo(node.name, this._getTypeInfo(node.type, null));\n    }\n    _getTypeInfo(type, attributes) {\n        if (this._types.has(type)) {\n            return this._types.get(type);\n        }\n        if (type instanceof ArrayType) {\n            const a = type;\n            const t = this._getTypeInfo(a.format, a.attributes);\n            const info = new ArrayInfo(a.name, attributes);\n            info.format = t;\n            info.count = a.count;\n            this._types.set(type, info);\n            this._updateTypeInfo(info);\n            return info;\n        }\n        if (type instanceof Struct) {\n            const s = type;\n            const info = new StructInfo(s.name, attributes);\n            info.startLine = s.startLine;\n            info.endLine = s.endLine;\n            for (const m of s.members) {\n                const t = this._getTypeInfo(m.type, m.attributes);\n                info.members.push(new MemberInfo(m.name, t, m.attributes));\n            }\n            this._types.set(type, info);\n            this._updateTypeInfo(info);\n            return info;\n        }\n        if (type instanceof SamplerType) {\n            const s = type;\n            const formatIsType = s.format instanceof Type;\n            const format = s.format\n                ? formatIsType\n                    ? this._getTypeInfo(s.format, null)\n                    : new TypeInfo(s.format, null)\n                : null;\n            const info = new TemplateInfo(s.name, format, attributes, s.access);\n            this._types.set(type, info);\n            this._updateTypeInfo(info);\n            return info;\n        }\n        if (type instanceof TemplateType) {\n            const t = type;\n            const format = t.format ? this._getTypeInfo(t.format, null) : null;\n            const info = new TemplateInfo(t.name, format, attributes, t.access);\n            this._types.set(type, info);\n            this._updateTypeInfo(info);\n            return info;\n        }\n        const info = new TypeInfo(type.name, attributes);\n        this._types.set(type, info);\n        this._updateTypeInfo(info);\n        return info;\n    }\n    _updateTypeInfo(type) {\n        var _a, _b;\n        const typeSize = this._getTypeSize(type);\n        type.size = (_a = typeSize === null || typeSize === void 0 ? void 0 : typeSize.size) !== null && _a !== void 0 ? _a : 0;\n        if (type instanceof ArrayInfo) {\n            const formatInfo = this._getTypeSize(type[\"format\"]);\n            type.stride = (_b = formatInfo === null || formatInfo === void 0 ? void 0 : formatInfo.size) !== null && _b !== void 0 ? _b : 0;\n            this._updateTypeInfo(type[\"format\"]);\n        }\n        if (type instanceof StructInfo) {\n            this._updateStructInfo(type);\n        }\n    }\n    _updateStructInfo(struct) {\n        var _a;\n        let offset = 0;\n        let lastSize = 0;\n        let lastOffset = 0;\n        let structAlign = 0;\n        for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {\n            const member = struct.members[mi];\n            const sizeInfo = this._getTypeSize(member);\n            if (!sizeInfo) {\n                continue;\n            }\n            (_a = this._getAlias(member.type.name)) !== null && _a !== void 0 ? _a : member.type;\n            const align = sizeInfo.align;\n            const size = sizeInfo.size;\n            offset = this._roundUp(align, offset + lastSize);\n            lastSize = size;\n            lastOffset = offset;\n            structAlign = Math.max(structAlign, align);\n            member.offset = offset;\n            member.size = size;\n            this._updateTypeInfo(member.type);\n        }\n        struct.size = this._roundUp(structAlign, lastOffset + lastSize);\n        struct.align = structAlign;\n    }\n    _getTypeSize(type) {\n        var _a, _b;\n        if (type === null || type === undefined) {\n            return null;\n        }\n        const explicitSize = this._getAttributeNum(type.attributes, \"size\", 0);\n        const explicitAlign = this._getAttributeNum(type.attributes, \"align\", 0);\n        if (type instanceof MemberInfo) {\n            type = type.type;\n        }\n        if (type instanceof TypeInfo) {\n            const alias = this._getAlias(type.name);\n            if (alias !== null) {\n                type = alias;\n            }\n        }\n        {\n            const info = WgslReflect._typeInfo[type.name];\n            if (info !== undefined) {\n                const divisor = ((_a = type[\"format\"]) === null || _a === void 0 ? void 0 : _a.name) === \"f16\" ? 2 : 1;\n                return new _TypeSize(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));\n            }\n        }\n        {\n            const info = WgslReflect._typeInfo[type.name.substring(0, type.name.length - 1)];\n            if (info) {\n                const divisor = type.name[type.name.length - 1] === \"h\" ? 2 : 1;\n                return new _TypeSize(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));\n            }\n        }\n        if (type instanceof ArrayInfo) {\n            let arrayType = type;\n            let align = 8;\n            let size = 8;\n            // Type                 AlignOf(T)          Sizeof(T)\n            // array<E, N>          AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))\n            // array<E>             AlignOf(E)          N * roundUp(AlignOf(E), SizeOf(E))  (N determined at runtime)\n            //\n            // @stride(Q)\n            // array<E, N>          AlignOf(E)          N * Q\n            //\n            // @stride(Q)\n            // array<E>             AlignOf(E)          Nruntime * Q\n            //const E = type.format.name;\n            const E = this._getTypeSize(arrayType.format);\n            if (E !== null) {\n                size = E.size;\n                align = E.align;\n            }\n            const N = arrayType.count;\n            const stride = this._getAttributeNum((_b = type === null || type === void 0 ? void 0 : type.attributes) !== null && _b !== void 0 ? _b : null, \"stride\", this._roundUp(align, size));\n            size = N * stride;\n            if (explicitSize) {\n                size = explicitSize;\n            }\n            return new _TypeSize(Math.max(explicitAlign, align), Math.max(explicitSize, size));\n        }\n        if (type instanceof StructInfo) {\n            let align = 0;\n            let size = 0;\n            // struct S     AlignOf:    max(AlignOfMember(S, M1), ... , AlignOfMember(S, MN))\n            //              SizeOf:     roundUp(AlignOf(S), OffsetOfMember(S, L) + SizeOfMember(S, L))\n            //                          Where L is the last member of the structure\n            let offset = 0;\n            let lastSize = 0;\n            let lastOffset = 0;\n            for (const m of type.members) {\n                const mi = this._getTypeSize(m.type);\n                if (mi !== null) {\n                    align = Math.max(mi.align, align);\n                    offset = this._roundUp(mi.align, offset + lastSize);\n                    lastSize = mi.size;\n                    lastOffset = offset;\n                }\n            }\n            size = this._roundUp(align, lastOffset + lastSize);\n            return new _TypeSize(Math.max(explicitAlign, align), Math.max(explicitSize, size));\n        }\n        return null;\n    }\n    _isUniformVar(node) {\n        return node instanceof Var && node.storage == \"uniform\";\n    }\n    _isStorageVar(node) {\n        return node instanceof Var && node.storage == \"storage\";\n    }\n    _isTextureVar(node) {\n        return (node instanceof Var &&\n            node.type !== null &&\n            WgslReflect._textureTypes.indexOf(node.type.name) != -1);\n    }\n    _isSamplerVar(node) {\n        return (node instanceof Var &&\n            node.type !== null &&\n            WgslReflect._samplerTypes.indexOf(node.type.name) != -1);\n    }\n    _getAttribute(node, name) {\n        const obj = node;\n        if (!obj || !obj[\"attributes\"]) {\n            return null;\n        }\n        const attrs = obj[\"attributes\"];\n        for (let a of attrs) {\n            if (a.name == name) {\n                return a;\n            }\n        }\n        return null;\n    }\n    _getAttributeNum(attributes, name, defaultValue) {\n        if (attributes === null) {\n            return defaultValue;\n        }\n        for (let a of attributes) {\n            if (a.name == name) {\n                let v = a !== null && a.value !== null ? a.value : defaultValue;\n                if (v instanceof Array) {\n                    v = v[0];\n                }\n                if (typeof v === \"number\") {\n                    return v;\n                }\n                if (typeof v === \"string\") {\n                    return parseInt(v);\n                }\n                return defaultValue;\n            }\n        }\n        return defaultValue;\n    }\n    _roundUp(k, n) {\n        return Math.ceil(n / k) * k;\n    }\n}\n// Type                 AlignOf(T)          Sizeof(T)\n// i32, u32, or f32     4                   4\n// atomic<T>            4                   4\n// vec2<T>              8                   8\n// vec3<T>              16                  12\n// vec4<T>              16                  16\n// mat2x2<f32>          8                   16\n// mat3x2<f32>          8                   24\n// mat4x2<f32>          8                   32\n// mat2x3<f32>          16                  32\n// mat3x3<f32>          16                  48\n// mat4x3<f32>          16                  64\n// mat2x4<f32>          16                  32\n// mat3x4<f32>          16                  48\n// mat4x4<f32>          16                  64\nWgslReflect._typeInfo = {\n    f16: { align: 2, size: 2 },\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    atomic: { align: 4, size: 4 },\n    vec2: { align: 8, size: 8 },\n    vec3: { align: 16, size: 12 },\n    vec4: { align: 16, size: 16 },\n    mat2x2: { align: 8, size: 16 },\n    mat3x2: { align: 8, size: 24 },\n    mat4x2: { align: 8, size: 32 },\n    mat2x3: { align: 16, size: 32 },\n    mat3x3: { align: 16, size: 48 },\n    mat4x3: { align: 16, size: 64 },\n    mat2x4: { align: 16, size: 32 },\n    mat3x4: { align: 16, size: 48 },\n    mat4x4: { align: 16, size: 64 },\n};\nWgslReflect._textureTypes = TokenTypes.any_texture_type.map((t) => {\n    return t.name;\n});\nWgslReflect._samplerTypes = TokenTypes.sampler_type.map((t) => {\n    return t.name;\n});\n\nexport { Alias, AliasInfo, Argument, ArrayIndex, ArrayInfo, ArrayType, Assign, AssignOperator, Attribute, BinaryOperator, BitcastExpr, Break, Call, CallExpr, Case, Const, ConstExpr, Continue, Continuing, CreateExpr, Default, Diagnostic, Discard, ElseIf, Enable, EntryFunctions, Expression, For, Function, FunctionInfo, GroupingExpr, If, Increment, IncrementOperator, InputInfo, Let, LiteralExpr, Loop, Member, MemberInfo, Node, Operator, OutputInfo, Override, OverrideInfo, ParseContext, PointerType, Requires, ResourceType, Return, SamplerType, Statement, StaticAssert, StringExpr, Struct, StructInfo, Switch, SwitchCase, TemplateInfo, TemplateType, Token, TokenClass, TokenType, TokenTypes, Type, TypeInfo, TypecastExpr, UnaryOperator, Var, VariableExpr, VariableInfo, WgslParser, WgslReflect, WgslScanner, While, _BlockEnd, _BlockStart };\n//# sourceMappingURL=wgsl_reflect.module.js.map\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\nimport { WgslReflect } from 'wgsl_reflect';\n/**\n * Parse a ShaderLayout from WGSL shader source code.\n * @param source WGSL source code (can contain both @vertex and @fragment entry points)\n * @returns\n */\nexport function getShaderLayoutFromWGSL(source) {\n    const shaderLayout = { attributes: [], bindings: [] };\n    let parsedWGSL;\n    try {\n        parsedWGSL = parseWGSL(source);\n    }\n    catch (error) {\n        log.error(error.message)();\n        return shaderLayout;\n    }\n    for (const uniform of parsedWGSL.uniforms) {\n        const members = [];\n        for (const attribute of uniform.type?.members || []) {\n            members.push({\n                name: attribute.name,\n                type: getType(attribute.type)\n            });\n        }\n        shaderLayout.bindings.push({\n            type: 'uniform',\n            name: uniform.name,\n            location: uniform.binding,\n            // @ts-expect-error\n            group: uniform.group,\n            members\n        });\n    }\n    const vertex = parsedWGSL.entry.vertex[0]; // \"main\"\n    // Vertex shader inputs\n    const attributeCount = vertex?.inputs.length || 0; // inputs to \"main\"\n    for (let i = 0; i < attributeCount; i++) {\n        const wgslAttribute = vertex.inputs[i];\n        // locationType can be \"builtin\"\n        if (wgslAttribute.locationType === 'location') {\n            const type = getType(wgslAttribute.type);\n            shaderLayout.attributes.push({\n                name: wgslAttribute.name,\n                location: Number(wgslAttribute.location),\n                type\n            });\n        }\n    }\n    return shaderLayout;\n}\n/** Get a valid shader attribute type string from a wgsl-reflect type */\nfunction getType(type) {\n    return type.format ? `${type.name}<${type.format.name}>` : type.name;\n}\nfunction parseWGSL(source) {\n    try {\n        return new WgslReflect(source);\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            throw error;\n        }\n        let message = 'WGSL parse error';\n        if (typeof error === 'object' && error?.message) {\n            message += `: ${error.message} `;\n        }\n        if (typeof error === 'object' && error?.token) {\n            message += error.token.line || '';\n        }\n        throw new Error(message, { cause: error });\n    }\n}\n","import { Buffer, uid, assert, getVertexFormatFromAttribute } from '@luma.gl/core';\nexport class GPUGeometry {\n    id;\n    userData = {};\n    /** Determines how vertices are read from the 'vertex' attributes */\n    topology;\n    bufferLayout = [];\n    vertexCount;\n    indices;\n    attributes;\n    constructor(props) {\n        this.id = props.id || uid('geometry');\n        this.topology = props.topology;\n        this.indices = props.indices || null;\n        this.attributes = props.attributes;\n        this.vertexCount = props.vertexCount;\n        this.bufferLayout = props.bufferLayout || [];\n        if (this.indices) {\n            assert(this.indices.usage === Buffer.INDEX);\n        }\n    }\n    destroy() {\n        this.indices?.destroy();\n        for (const attribute of Object.values(this.attributes)) {\n            attribute.destroy();\n        }\n    }\n    getVertexCount() {\n        return this.vertexCount;\n    }\n    getAttributes() {\n        return this.attributes;\n    }\n    getIndexes() {\n        return this.indices;\n    }\n    _calculateVertexCount(positions) {\n        // Assume that positions is a fully packed float32x3 buffer\n        const vertexCount = positions.byteLength / 12;\n        return vertexCount;\n    }\n}\nexport function makeGPUGeometry(device, geometry) {\n    if (geometry instanceof GPUGeometry) {\n        return geometry;\n    }\n    const indices = getIndexBufferFromGeometry(device, geometry);\n    const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);\n    return new GPUGeometry({\n        topology: geometry.topology || 'triangle-list',\n        bufferLayout,\n        vertexCount: geometry.vertexCount,\n        indices,\n        attributes\n    });\n}\nexport function getIndexBufferFromGeometry(device, geometry) {\n    if (!geometry.indices) {\n        return undefined;\n    }\n    const data = geometry.indices.value;\n    return device.createBuffer({ usage: Buffer.INDEX, data });\n}\nexport function getAttributeBuffersFromGeometry(device, geometry) {\n    const bufferLayout = [];\n    const attributes = {};\n    for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {\n        let name = attributeName;\n        // TODO Map some GLTF attribute names (is this still needed?)\n        switch (attributeName) {\n            case 'POSITION':\n                name = 'positions';\n                break;\n            case 'NORMAL':\n                name = 'normals';\n                break;\n            case 'TEXCOORD_0':\n                name = 'texCoords';\n                break;\n            case 'COLOR_0':\n                name = 'colors';\n                break;\n        }\n        attributes[name] = device.createBuffer({ data: attribute.value, id: `${attributeName}-buffer` });\n        const { value, size, normalized } = attribute;\n        bufferLayout.push({ name, format: getVertexFormatFromAttribute(value, size, normalized) });\n    }\n    const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);\n    return { attributes, bufferLayout, vertexCount };\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log, splitUniformsAndBindings } from '@luma.gl/core';\n// import type {ShaderUniformType, UniformValue, UniformFormat, UniformInfoDevice, Texture, Sampler} from '@luma.gl/core';\nimport { _resolveModules } from '@luma.gl/shadertools';\n/**\n * ShaderInputs holds uniform and binding values for one or more shader modules,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class ShaderInputs {\n    /**\n     * The map of modules\n     * @todo should should this include the resolved dependencies?\n     */\n    modules;\n    /** Stores the uniform values for each module */\n    moduleUniforms;\n    /** Stores the uniform bindings for each module  */\n    moduleBindings;\n    /** Tracks if uniforms have changed */\n    moduleUniformsChanged;\n    /**\n     * Create a new UniformStore instance\n     * @param modules\n     */\n    constructor(modules) {\n        // Extract modules with dependencies\n        const resolvedModules = _resolveModules(Object.values(modules).filter(module => module.dependencies));\n        for (const resolvedModule of resolvedModules) {\n            // @ts-ignore\n            modules[resolvedModule.name] = resolvedModule;\n        }\n        log.log(1, 'Creating ShaderInputs with modules', Object.keys(modules))();\n        // Store the module definitions and create storage for uniform values and binding values, per module\n        this.modules = modules;\n        this.moduleUniforms = {};\n        this.moduleBindings = {};\n        // Initialize the modules\n        for (const [name, module] of Object.entries(modules)) {\n            const moduleName = name;\n            // Get default uniforms from module\n            this.moduleUniforms[moduleName] = module.defaultUniforms || {};\n            this.moduleBindings[moduleName] = {};\n        }\n    }\n    /** Destroy */\n    destroy() { }\n    /**\n     * Set module props\n     */\n    setProps(props) {\n        for (const name of Object.keys(props)) {\n            const moduleName = name;\n            const moduleProps = props[moduleName];\n            const module = this.modules[moduleName];\n            if (!module) {\n                // Ignore props for unregistered modules\n                log.warn(`Module ${name} not found`)();\n                continue; // eslint-disable-line no-continue\n            }\n            const oldUniforms = this.moduleUniforms[moduleName];\n            const oldBindings = this.moduleBindings[moduleName];\n            const uniformsAndBindings = module.getUniforms?.(moduleProps, oldUniforms) || moduleProps;\n            const { uniforms, bindings } = splitUniformsAndBindings(uniformsAndBindings);\n            this.moduleUniforms[moduleName] = { ...oldUniforms, ...uniforms };\n            this.moduleBindings[moduleName] = { ...oldBindings, ...bindings };\n            // this.moduleUniformsChanged ||= moduleName;\n            // console.log(`setProps(${String(moduleName)}`, moduleName, this.moduleUniforms[moduleName])\n        }\n    }\n    /** Merges all bindings for the shader (from the various modules) */\n    // getUniformBlocks(): Record<string, Texture | Sampler> {\n    //   return this.moduleUniforms;\n    // }\n    /**\n     * Return the map of modules\n     * @todo should should this include the resolved dependencies?\n     */\n    getModules() {\n        return Object.values(this.modules);\n    }\n    /** Get all uniform values for all modules */\n    getUniformValues() {\n        return this.moduleUniforms;\n    }\n    /** Merges all bindings for the shader (from the various modules) */\n    getBindings() {\n        const bindings = {};\n        for (const moduleBindings of Object.values(this.moduleBindings)) {\n            Object.assign(bindings, moduleBindings);\n        }\n        return bindings;\n    }\n    getDebugTable() {\n        const table = {};\n        for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {\n            for (const [key, value] of Object.entries(module)) {\n                table[`${moduleName}.${key}`] = {\n                    type: this.modules[moduleName].uniformTypes?.[key],\n                    value: String(value)\n                };\n            }\n        }\n        return table;\n    }\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Resource } from \"./resource.js\";\n/**\n * A compiled and linked shader program for compute\n */\nexport class ComputePipeline extends Resource {\n    static defaultProps = {\n        ...Resource.defaultProps,\n        shader: undefined,\n        entryPoint: undefined,\n        constants: {},\n        shaderLayout: undefined\n    };\n    get [Symbol.toStringTag]() {\n        return 'ComputePipeline';\n    }\n    hash = '';\n    constructor(device, props) {\n        super(device, props, ComputePipeline.defaultProps);\n    }\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { RenderPipeline, ComputePipeline } from '@luma.gl/core';\n/**\n * Efficiently creates / caches pipelines\n */\nexport class PipelineFactory {\n    static defaultProps = { ...RenderPipeline.defaultProps };\n    device;\n    _hashCounter = 0;\n    _hashes = {};\n    _renderPipelineCache = {};\n    _computePipelineCache = {};\n    /** Get the singleton default pipeline factory for the specified device */\n    static getDefaultPipelineFactory(device) {\n        device._lumaData.defaultPipelineFactory =\n            device._lumaData.defaultPipelineFactory || new PipelineFactory(device);\n        return device._lumaData.defaultPipelineFactory;\n    }\n    constructor(device) {\n        this.device = device;\n    }\n    /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */\n    createRenderPipeline(props) {\n        const allProps = { ...RenderPipeline.defaultProps, ...props };\n        const hash = this._hashRenderPipeline(allProps);\n        if (!this._renderPipelineCache[hash]) {\n            const pipeline = this.device.createRenderPipeline({\n                ...allProps,\n                id: allProps.id ? `${allProps.id}-cached` : undefined\n            });\n            pipeline.hash = hash;\n            this._renderPipelineCache[hash] = { pipeline, useCount: 0 };\n        }\n        this._renderPipelineCache[hash].useCount++;\n        return this._renderPipelineCache[hash].pipeline;\n    }\n    createComputePipeline(props) {\n        const allProps = { ...ComputePipeline.defaultProps, ...props };\n        const hash = this._hashComputePipeline(allProps);\n        if (!this._computePipelineCache[hash]) {\n            const pipeline = this.device.createComputePipeline({\n                ...allProps,\n                id: allProps.id ? `${allProps.id}-cached` : undefined\n            });\n            pipeline.hash = hash;\n            this._computePipelineCache[hash] = { pipeline, useCount: 0 };\n        }\n        this._computePipelineCache[hash].useCount++;\n        return this._computePipelineCache[hash].pipeline;\n    }\n    release(pipeline) {\n        const hash = pipeline.hash;\n        const cache = pipeline instanceof ComputePipeline ? this._computePipelineCache : this._renderPipelineCache;\n        cache[hash].useCount--;\n        if (cache[hash].useCount === 0) {\n            cache[hash].pipeline.destroy();\n            delete cache[hash];\n        }\n    }\n    // PRIVATE\n    _hashComputePipeline(props) {\n        const shaderHash = this._getHash(props.shader.source);\n        return `${shaderHash}`;\n    }\n    /** Calculate a hash based on all the inputs for a render pipeline */\n    _hashRenderPipeline(props) {\n        const vsHash = this._getHash(props.vs.source);\n        const fsHash = props.fs ? this._getHash(props.fs.source) : 0;\n        // WebGL specific\n        // const {varyings = [], bufferMode = {}} = props;\n        // const varyingHashes = varyings.map((v) => this._getHash(v));\n        const varyingHash = '-'; // `${varyingHashes.join('/')}B${bufferMode}`\n        const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));\n        switch (this.device.type) {\n            case 'webgl':\n                // WebGL is more dynamic\n                return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;\n            default:\n                // On WebGPU we need to rebuild the pipeline if topology, parameters or bufferLayout change\n                const parameterHash = this._getHash(JSON.stringify(props.parameters));\n                // TODO - Can json.stringify() generate different strings for equivalent objects if order of params is different?\n                // create a deepHash() to deduplicate?\n                return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;\n        }\n    }\n    _getHash(key) {\n        if (this._hashes[key] === undefined) {\n            this._hashes[key] = this._hashCounter++;\n        }\n        return this._hashes[key];\n    }\n}\n","import { Shader } from '@luma.gl/core';\n/** Manages a cached pool of Shaders for reuse. */\nexport class ShaderFactory {\n    static defaultProps = { ...Shader.defaultProps };\n    device;\n    _cache = {};\n    /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */\n    static getDefaultShaderFactory(device) {\n        device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);\n        return device._lumaData.defaultShaderFactory;\n    }\n    /** @internal */\n    constructor(device) {\n        this.device = device;\n    }\n    /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */\n    createShader(props) {\n        const key = this._hashShader(props);\n        let cacheEntry = this._cache[key];\n        if (!cacheEntry) {\n            const shader = this.device.createShader({\n                ...props,\n                id: props.id ? `${props.id}-cached` : undefined\n            });\n            this._cache[key] = cacheEntry = { shader, useCount: 0 };\n        }\n        cacheEntry.useCount++;\n        return cacheEntry.shader;\n    }\n    /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */\n    release(shader) {\n        const key = this._hashShader(shader);\n        const cacheEntry = this._cache[key];\n        if (cacheEntry) {\n            cacheEntry.useCount--;\n            if (cacheEntry.useCount === 0) {\n                delete this._cache[key];\n                cacheEntry.shader.destroy();\n            }\n        }\n    }\n    // PRIVATE\n    _hashShader(value) {\n        return `${value.stage}:${value.source}`;\n    }\n}\n","// import {copyTextureToImage} from '../debug/copy-texture-to-image';\n/** Only works with 1st device? */\nlet canvas = null;\nlet ctx = null;\n// let targetImage: HTMLImageElement | null = null;\n/** Debug utility to draw FBO contents onto screen */\n// eslint-disable-next-line\nexport function debugFramebuffer(fbo, { id, minimap, opaque, top = '0', left = '0', rgbaScale = 1 }) {\n    if (!canvas) {\n        canvas = document.createElement('canvas');\n        canvas.id = id;\n        canvas.title = id;\n        canvas.style.zIndex = '100';\n        canvas.style.position = 'absolute';\n        canvas.style.top = top; // ⚠️\n        canvas.style.left = left; // ⚠️\n        canvas.style.border = 'blue 1px solid';\n        canvas.style.transform = 'scaleY(-1)';\n        document.body.appendChild(canvas);\n        ctx = canvas.getContext('2d');\n        // targetImage = new Image();\n    }\n    // const canvasHeight = (minimap ? 2 : 1) * fbo.height;\n    if (canvas.width !== fbo.width || canvas.height !== fbo.height) {\n        canvas.width = fbo.width / 2;\n        canvas.height = fbo.height / 2;\n        canvas.style.width = '400px';\n        canvas.style.height = '400px';\n    }\n    // const image = copyTextureToImage(fbo, {targetMaxHeight: 100, targetImage});\n    // ctx.drawImage(image, 0, 0);\n    const color = fbo.device.readPixelsToArrayWebGL(fbo);\n    const imageData = ctx.createImageData(fbo.width, fbo.height);\n    // Full map\n    const offset = 0;\n    // if (color.some((v) => v > 0)) {\n    //   console.error('THERE IS NON-ZERO DATA IN THE FBO!');\n    // }\n    for (let i = 0; i < color.length; i += 4) {\n        imageData.data[offset + i + 0] = color[i + 0] * rgbaScale;\n        imageData.data[offset + i + 1] = color[i + 1] * rgbaScale;\n        imageData.data[offset + i + 2] = color[i + 2] * rgbaScale;\n        imageData.data[offset + i + 3] = opaque ? 255 : color[i + 3] * rgbaScale;\n    }\n    ctx.putImageData(imageData, 0, 0);\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, Texture, TextureView, Sampler } from '@luma.gl/core';\nimport { RenderPipeline, UniformStore } from '@luma.gl/core';\nimport { log, uid, deepEqual, isObjectEmpty, splitUniformsAndBindings } from '@luma.gl/core';\nimport { getTypedArrayFromDataType, getAttributeInfosFromLayouts } from '@luma.gl/core';\nimport { ShaderAssembler, getShaderLayoutFromWGSL } from '@luma.gl/shadertools';\nimport { makeGPUGeometry } from \"../geometry/gpu-geometry.js\";\nimport { ShaderInputs } from \"../shader-inputs.js\";\nimport { PipelineFactory } from \"../lib/pipeline-factory.js\";\nimport { ShaderFactory } from \"../lib/shader-factory.js\";\nimport { getDebugTableForShaderLayout } from \"../debug/debug-shader-layout.js\";\nimport { debugFramebuffer } from \"../debug/debug-framebuffer.js\";\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Model {\n    static defaultProps = {\n        ...RenderPipeline.defaultProps,\n        source: null,\n        vs: null,\n        fs: null,\n        id: 'unnamed',\n        handle: undefined,\n        userData: {},\n        defines: {},\n        modules: [],\n        moduleSettings: undefined,\n        geometry: null,\n        indexBuffer: null,\n        attributes: {},\n        constantAttributes: {},\n        varyings: [],\n        isInstanced: undefined,\n        instanceCount: 0,\n        vertexCount: 0,\n        shaderInputs: undefined,\n        pipelineFactory: undefined,\n        shaderFactory: undefined,\n        transformFeedback: undefined,\n        shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n        debugShaders: undefined,\n        disableWarnings: undefined\n    };\n    device;\n    id;\n    source;\n    vs;\n    fs;\n    pipelineFactory;\n    shaderFactory;\n    userData = {};\n    // Fixed properties (change can trigger pipeline rebuild)\n    /** The render pipeline GPU parameters, depth testing etc */\n    parameters;\n    /** The primitive topology */\n    topology;\n    /** Buffer layout */\n    bufferLayout;\n    // Dynamic properties\n    /** Use instanced rendering */\n    isInstanced = undefined;\n    /** instance count. `undefined` means not instanced */\n    instanceCount = 0;\n    /** Vertex count */\n    vertexCount;\n    /** Index buffer */\n    indexBuffer = null;\n    /** Buffer-valued attributes */\n    bufferAttributes = {};\n    /** Constant-valued attributes */\n    constantAttributes = {};\n    /** Bindings (textures, samplers, uniform buffers) */\n    bindings = {};\n    /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/\n    uniforms = {};\n    /**\n     * VertexArray\n     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!\n     * @todo - allow application to define multiple vertex arrays?\n     * */\n    vertexArray;\n    /** TransformFeedback, WebGL 2 only. */\n    transformFeedback = null;\n    /** The underlying GPU \"program\". @note May be recreated if parameters change */\n    pipeline;\n    /** ShaderInputs instance */\n    shaderInputs;\n    _uniformStore;\n    _attributeInfos = {};\n    _gpuGeometry = null;\n    _getModuleUniforms;\n    props;\n    _pipelineNeedsUpdate = 'newly created';\n    _needsRedraw = 'initializing';\n    _destroyed = false;\n    /** \"Time\" of last draw. Monotonically increasing timestamp */\n    _lastDrawTimestamp = -1;\n    constructor(device, props) {\n        this.props = { ...Model.defaultProps, ...props };\n        props = this.props;\n        this.id = props.id || uid('model');\n        this.device = device;\n        Object.assign(this.userData, props.userData);\n        // Setup shader module inputs\n        const moduleMap = Object.fromEntries(this.props.modules?.map(module => [module.name, module]) || []);\n        this.setShaderInputs(props.shaderInputs || new ShaderInputs(moduleMap));\n        // Setup shader assembler\n        const platformInfo = getPlatformInfo(device);\n        // Extract modules from shader inputs if not supplied\n        const modules = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n        const isWebGPU = this.device.type === 'webgpu';\n        // WebGPU\n        // TODO - hack to support unified WGSL shader\n        // TODO - this is wrong, compile a single shader\n        if (isWebGPU && this.props.source) {\n            // WGSL\n            this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);\n            const { source, getUniforms } = this.props.shaderAssembler.assembleShader({\n                platformInfo,\n                ...this.props,\n                modules\n            });\n            this.source = source;\n            this._getModuleUniforms = getUniforms;\n        }\n        else {\n            // GLSL\n            const { vs, fs, getUniforms } = this.props.shaderAssembler.assembleShaderPair({\n                platformInfo,\n                ...this.props,\n                modules\n            });\n            this.vs = vs;\n            this.fs = fs;\n            this._getModuleUniforms = getUniforms;\n        }\n        this.vertexCount = this.props.vertexCount;\n        this.instanceCount = this.props.instanceCount;\n        this.topology = this.props.topology;\n        this.bufferLayout = this.props.bufferLayout;\n        this.parameters = this.props.parameters;\n        // Geometry, if provided, sets topology and vertex cound\n        if (props.geometry) {\n            this.setGeometry(props.geometry);\n        }\n        this.pipelineFactory =\n            props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n        this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n        // Create the pipeline\n        // @note order is important\n        this.pipeline = this._updatePipeline();\n        this.vertexArray = device.createVertexArray({\n            renderPipeline: this.pipeline\n        });\n        // Now we can apply geometry attributes\n        if (this._gpuGeometry) {\n            this._setGeometryAttributes(this._gpuGeometry);\n        }\n        // Apply any dynamic settings that will not trigger pipeline change\n        if ('isInstanced' in props) {\n            this.isInstanced = props.isInstanced;\n        }\n        if (props.instanceCount) {\n            this.setInstanceCount(props.instanceCount);\n        }\n        if (props.vertexCount) {\n            this.setVertexCount(props.vertexCount);\n        }\n        if (props.indexBuffer) {\n            this.setIndexBuffer(props.indexBuffer);\n        }\n        if (props.attributes) {\n            this.setAttributes(props.attributes);\n        }\n        if (props.constantAttributes) {\n            this.setConstantAttributes(props.constantAttributes);\n        }\n        if (props.bindings) {\n            this.setBindings(props.bindings);\n        }\n        if (props.uniforms) {\n            this.setUniforms(props.uniforms);\n        }\n        if (props.moduleSettings) {\n            // log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n            this.updateModuleSettings(props.moduleSettings);\n        }\n        if (props.transformFeedback) {\n            this.transformFeedback = props.transformFeedback;\n        }\n        // Catch any access to non-standard props\n        Object.seal(this);\n    }\n    destroy() {\n        if (this._destroyed)\n            return;\n        this.pipelineFactory.release(this.pipeline);\n        this.shaderFactory.release(this.pipeline.vs);\n        if (this.pipeline.fs) {\n            this.shaderFactory.release(this.pipeline.fs);\n        }\n        this._uniformStore.destroy();\n        // TODO - mark resource as managed and destroyIfManaged() ?\n        this._gpuGeometry?.destroy();\n        this._destroyed = true;\n    }\n    // Draw call\n    /** Query redraw status. Clears the status. */\n    needsRedraw() {\n        // Catch any writes to already bound resources\n        if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {\n            this.setNeedsRedraw('contents of bound textures or buffers updated');\n        }\n        const needsRedraw = this._needsRedraw;\n        this._needsRedraw = false;\n        return needsRedraw;\n    }\n    /** Mark the model as needing a redraw */\n    setNeedsRedraw(reason) {\n        this._needsRedraw ||= reason;\n    }\n    predraw() {\n        // Update uniform buffers if needed\n        this.updateShaderInputs();\n        // Check if the pipeline is invalidated\n        this.pipeline = this._updatePipeline();\n    }\n    draw(renderPass) {\n        this.predraw();\n        let drawSuccess;\n        try {\n            this._logDrawCallStart();\n            // Update the pipeline if invalidated\n            // TODO - inside RenderPass is likely the worst place to do this from performance perspective.\n            // Application can call Model.predraw() to avoid this.\n            this.pipeline = this._updatePipeline();\n            // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n            // Any caching needs to be done inside the pipeline functions\n            this.pipeline.setBindings(this.bindings, { disableWarnings: this.props.disableWarnings });\n            if (!isObjectEmpty(this.uniforms)) {\n                this.pipeline.setUniformsWebGL(this.uniforms);\n            }\n            const { indexBuffer } = this.vertexArray;\n            const indexCount = indexBuffer\n                ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2)\n                : undefined;\n            drawSuccess = this.pipeline.draw({\n                renderPass,\n                vertexArray: this.vertexArray,\n                isInstanced: this.isInstanced,\n                vertexCount: this.vertexCount,\n                instanceCount: this.instanceCount,\n                indexCount,\n                transformFeedback: this.transformFeedback || undefined,\n                // WebGL shares underlying cached pipelines even for models that have different parameters and topology,\n                // so we must provide our unique parameters to each draw\n                // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)\n                parameters: this.parameters,\n                topology: this.topology\n            });\n        }\n        finally {\n            this._logDrawCallEnd();\n        }\n        this._logFramebuffer(renderPass);\n        // Update needsRedraw flag\n        if (drawSuccess) {\n            this._lastDrawTimestamp = this.device.timestamp;\n            this._needsRedraw = false;\n        }\n        else {\n            this._needsRedraw = 'waiting for resource initialization';\n        }\n        return drawSuccess;\n    }\n    // Update fixed fields (can trigger pipeline rebuild)\n    /**\n     * Updates the optional geometry\n     * Geometry, set topology and bufferLayout\n     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n     */\n    setGeometry(geometry) {\n        this._gpuGeometry?.destroy();\n        const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);\n        if (gpuGeometry) {\n            this.setTopology(gpuGeometry.topology || 'triangle-list');\n            this.bufferLayout = mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);\n            if (this.vertexArray) {\n                this._setGeometryAttributes(gpuGeometry);\n            }\n        }\n        this._gpuGeometry = gpuGeometry;\n    }\n    /**\n     * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).\n     * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU\n     */\n    setTopology(topology) {\n        if (topology !== this.topology) {\n            this.topology = topology;\n            this._setPipelineNeedsUpdate('topology');\n        }\n    }\n    /**\n     * Updates the buffer layout.\n     * @note Triggers a pipeline rebuild / pipeline cache fetch\n     */\n    setBufferLayout(bufferLayout) {\n        this.bufferLayout = this._gpuGeometry\n            ? mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout)\n            : bufferLayout;\n        this._setPipelineNeedsUpdate('bufferLayout');\n        // Recreate the pipeline\n        this.pipeline = this._updatePipeline();\n        // vertex array needs to be updated if we update buffer layout,\n        // but not if we update parameters\n        this.vertexArray = this.device.createVertexArray({\n            renderPipeline: this.pipeline\n        });\n        // Reapply geometry attributes to the new vertex array\n        if (this._gpuGeometry) {\n            this._setGeometryAttributes(this._gpuGeometry);\n        }\n    }\n    /**\n     * Set GPU parameters.\n     * @note Can trigger a pipeline rebuild / pipeline cache fetch.\n     * @param parameters\n     */\n    setParameters(parameters) {\n        if (!deepEqual(parameters, this.parameters, 2)) {\n            this.parameters = parameters;\n            this._setPipelineNeedsUpdate('parameters');\n        }\n    }\n    // Update dynamic fields\n    /**\n     * Updates the instance count (used in draw calls)\n     * @note Any attributes with stepMode=instance need to be at least this big\n     */\n    setInstanceCount(instanceCount) {\n        this.instanceCount = instanceCount;\n        // luma.gl examples don't set props.isInstanced and rely on auto-detection\n        // but deck.gl sets instanceCount even for models that are not instanced.\n        if (this.isInstanced === undefined && instanceCount > 0) {\n            this.isInstanced = true;\n        }\n        this.setNeedsRedraw('instanceCount');\n    }\n    /**\n     * Updates the vertex count (used in draw calls)\n     * @note Any attributes with stepMode=vertex need to be at least this big\n     */\n    setVertexCount(vertexCount) {\n        this.vertexCount = vertexCount;\n        this.setNeedsRedraw('vertexCount');\n    }\n    /** Set the shader inputs */\n    setShaderInputs(shaderInputs) {\n        this.shaderInputs = shaderInputs;\n        this._uniformStore = new UniformStore(this.shaderInputs.modules);\n        // Create uniform buffer bindings for all modules\n        for (const moduleName of Object.keys(this.shaderInputs.modules)) {\n            const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n            this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n        }\n        this.setNeedsRedraw('shaderInputs');\n    }\n    /** Update uniform buffers from the model's shader inputs */\n    updateShaderInputs() {\n        this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n        this.setBindings(this.shaderInputs.getBindings());\n        // TODO - this is already tracked through buffer/texture update times?\n        this.setNeedsRedraw('shaderInputs');\n    }\n    /**\n     * Sets bindings (textures, samplers, uniform buffers)\n     */\n    setBindings(bindings) {\n        Object.assign(this.bindings, bindings);\n        this.setNeedsRedraw('bindings');\n    }\n    /**\n     * Updates optional transform feedback. WebGL only.\n     */\n    setTransformFeedback(transformFeedback) {\n        this.transformFeedback = transformFeedback;\n        this.setNeedsRedraw('transformFeedback');\n    }\n    /**\n     * Sets the index buffer\n     * @todo - how to unset it if we change geometry?\n     */\n    setIndexBuffer(indexBuffer) {\n        this.vertexArray.setIndexBuffer(indexBuffer);\n        this.setNeedsRedraw('indexBuffer');\n    }\n    /**\n     * Sets attributes (buffers)\n     * @note Overrides any attributes previously set with the same name\n     */\n    setAttributes(buffers, options) {\n        if (buffers.indices) {\n            log.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();\n        }\n        for (const [bufferName, buffer] of Object.entries(buffers)) {\n            const bufferLayout = this.bufferLayout.find(layout => getAttributeNames(layout).includes(bufferName));\n            if (!bufferLayout) {\n                log.warn(`Model(${this.id}): Missing layout for buffer \"${bufferName}\".`)();\n                continue; // eslint-disable-line no-continue\n            }\n            // For an interleaved attribute we may need to set multiple attributes\n            const attributeNames = getAttributeNames(bufferLayout);\n            let set = false;\n            for (const attributeName of attributeNames) {\n                const attributeInfo = this._attributeInfos[attributeName];\n                if (attributeInfo) {\n                    this.vertexArray.setBuffer(attributeInfo.location, buffer);\n                    set = true;\n                }\n            }\n            if (!set && !(options?.disableWarnings ?? this.props.disableWarnings)) {\n                log.warn(`Model(${this.id}): Ignoring buffer \"${buffer.id}\" for unknown attribute \"${bufferName}\"`)();\n            }\n        }\n        this.setNeedsRedraw('attributes');\n    }\n    /**\n     * Sets constant attributes\n     * @note Overrides any attributes previously set with the same name\n     * Constant attributes are only supported in WebGL, not in WebGPU\n     * Any attribute that is disabled in the current vertex array object\n     * is read from the context's global constant value for that attribute location.\n     * @param constantAttributes\n     */\n    setConstantAttributes(attributes, options) {\n        for (const [attributeName, value] of Object.entries(attributes)) {\n            const attributeInfo = this._attributeInfos[attributeName];\n            if (attributeInfo) {\n                this.vertexArray.setConstantWebGL(attributeInfo.location, value);\n            }\n            else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {\n                log.warn(`Model \"${this.id}: Ignoring constant supplied for unknown attribute \"${attributeName}\"`)();\n            }\n        }\n        this.setNeedsRedraw('constants');\n    }\n    // DEPRECATED METHODS\n    /**\n     * Sets individual uniforms\n     * @deprecated WebGL only, use uniform buffers for portability\n     * @param uniforms\n     */\n    setUniforms(uniforms) {\n        if (!isObjectEmpty(uniforms)) {\n            this.pipeline.setUniformsWebGL(uniforms);\n            Object.assign(this.uniforms, uniforms);\n        }\n        this.setNeedsRedraw('uniforms');\n    }\n    /**\n     * @deprecated Updates shader module settings (which results in uniforms being set)\n     */\n    updateModuleSettings(props) {\n        // log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n        const { bindings, uniforms } = splitUniformsAndBindings(this._getModuleUniforms(props));\n        Object.assign(this.bindings, bindings);\n        Object.assign(this.uniforms, uniforms);\n        this.setNeedsRedraw('moduleSettings');\n    }\n    // Internal methods\n    /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */\n    _getBindingsUpdateTimestamp() {\n        let timestamp = 0;\n        for (const binding of Object.values(this.bindings)) {\n            if (binding instanceof TextureView) {\n                timestamp = Math.max(timestamp, binding.texture.updateTimestamp);\n            }\n            else if (binding instanceof Buffer || binding instanceof Texture) {\n                timestamp = Math.max(timestamp, binding.updateTimestamp);\n            }\n            else if (!(binding instanceof Sampler)) {\n                timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);\n            }\n        }\n        return timestamp;\n    }\n    /**\n     * Updates the optional geometry attributes\n     * Geometry, sets several attributes, indexBuffer, and also vertex count\n     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n     */\n    _setGeometryAttributes(gpuGeometry) {\n        // Filter geometry attribute so that we don't issue warnings for unused attributes\n        const attributes = { ...gpuGeometry.attributes };\n        for (const [attributeName] of Object.entries(attributes)) {\n            if (!this.pipeline.shaderLayout.attributes.find(layout => layout.name === attributeName) &&\n                attributeName !== 'positions') {\n                delete attributes[attributeName];\n            }\n        }\n        // TODO - delete previous geometry?\n        this.vertexCount = gpuGeometry.vertexCount;\n        this.setIndexBuffer(gpuGeometry.indices || null);\n        this.setAttributes(gpuGeometry.attributes, { disableWarnings: true });\n        this.setAttributes(attributes, { disableWarnings: this.props.disableWarnings });\n        this.setNeedsRedraw('geometry attributes');\n    }\n    /** Mark pipeline as needing update */\n    _setPipelineNeedsUpdate(reason) {\n        this._pipelineNeedsUpdate ||= reason;\n        this.setNeedsRedraw(reason);\n    }\n    /** Update pipeline if needed */\n    _updatePipeline() {\n        if (this._pipelineNeedsUpdate) {\n            let prevShaderVs = null;\n            let prevShaderFs = null;\n            if (this.pipeline) {\n                log.log(1, `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`)();\n                prevShaderVs = this.pipeline.vs;\n                prevShaderFs = this.pipeline.fs;\n            }\n            this._pipelineNeedsUpdate = false;\n            const vs = this.shaderFactory.createShader({\n                id: `${this.id}-vertex`,\n                stage: 'vertex',\n                source: this.source || this.vs,\n                debug: this.props.debugShaders\n            });\n            let fs = null;\n            if (this.source) {\n                fs = vs;\n            }\n            else if (this.fs) {\n                fs = this.shaderFactory.createShader({\n                    id: `${this.id}-fragment`,\n                    stage: 'fragment',\n                    source: this.source || this.fs,\n                    debug: this.props.debugShaders\n                });\n            }\n            this.pipeline = this.pipelineFactory.createRenderPipeline({\n                ...this.props,\n                bufferLayout: this.bufferLayout,\n                topology: this.topology,\n                parameters: this.parameters,\n                vs,\n                fs\n            });\n            this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);\n            if (prevShaderVs)\n                this.shaderFactory.release(prevShaderVs);\n            if (prevShaderFs)\n                this.shaderFactory.release(prevShaderFs);\n        }\n        return this.pipeline;\n    }\n    /** Throttle draw call logging */\n    _lastLogTime = 0;\n    _logOpen = false;\n    _logDrawCallStart() {\n        // IF level is 4 or higher, log every frame.\n        const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n        if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n            return;\n        }\n        this._lastLogTime = Date.now();\n        this._logOpen = true;\n        log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, { collapsed: log.level <= 2 })();\n    }\n    _logDrawCallEnd() {\n        if (this._logOpen) {\n            const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);\n            // log.table(logLevel, attributeTable)();\n            // log.table(logLevel, uniformTable)();\n            log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n            const uniformTable = this.shaderInputs.getDebugTable();\n            // Add any global uniforms\n            for (const [name, value] of Object.entries(this.uniforms)) {\n                uniformTable[name] = { value };\n            }\n            log.table(LOG_DRAW_PRIORITY, uniformTable)();\n            const attributeTable = this._getAttributeDebugTable();\n            log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();\n            log.table(LOG_DRAW_PRIORITY, attributeTable)();\n            log.groupEnd(LOG_DRAW_PRIORITY)();\n            this._logOpen = false;\n        }\n    }\n    _drawCount = 0;\n    _logFramebuffer(renderPass) {\n        const debugFramebuffers = log.get('framebuffer');\n        this._drawCount++;\n        // Update first 3 frames and then every 60 frames\n        if (!debugFramebuffers || (this._drawCount++ > 3 && this._drawCount % 60)) {\n            return;\n        }\n        // TODO - display framebuffer output in debug window\n        const framebuffer = renderPass.props.framebuffer;\n        if (framebuffer) {\n            debugFramebuffer(framebuffer, { id: framebuffer.id, minimap: true });\n            // log.image({logLevel: LOG_DRAW_PRIORITY, message: `${framebuffer.id} %c sup?`, image})();\n        }\n    }\n    _getAttributeDebugTable() {\n        const table = {};\n        for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {\n            table[attributeInfo.location] = {\n                name,\n                type: attributeInfo.shaderType,\n                values: this._getBufferOrConstantValues(this.vertexArray.attributes[attributeInfo.location], attributeInfo.bufferDataType)\n            };\n        }\n        if (this.vertexArray.indexBuffer) {\n            const { indexBuffer } = this.vertexArray;\n            const values = indexBuffer.indexType === 'uint32'\n                ? new Uint32Array(indexBuffer.debugData)\n                : new Uint16Array(indexBuffer.debugData);\n            table.indices = {\n                name: 'indices',\n                type: indexBuffer.indexType,\n                values: values.toString()\n            };\n        }\n        return table;\n    }\n    // TODO - fix typing of luma data types\n    _getBufferOrConstantValues(attribute, dataType) {\n        const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n        const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n        return typedArray.toString();\n    }\n}\n// HELPERS\n/** TODO - move to core, document add tests */\nfunction mergeBufferLayouts(layouts1, layouts2) {\n    const layouts = [...layouts1];\n    for (const attribute of layouts2) {\n        const index = layouts.findIndex(attribute2 => attribute2.name === attribute.name);\n        if (index < 0) {\n            layouts.push(attribute);\n        }\n        else {\n            layouts[index] = attribute;\n        }\n    }\n    return layouts;\n}\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device) {\n    return {\n        type: device.type,\n        shaderLanguage: device.info.shadingLanguage,\n        shaderLanguageVersion: device.info.shadingLanguageVersion,\n        gpu: device.info.gpu,\n        // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n        features: device.features\n    };\n}\n/** Get attribute names from a BufferLayout */\nfunction getAttributeNames(bufferLayout) {\n    return bufferLayout.attributes\n        ? bufferLayout.attributes?.map(layout => layout.attribute)\n        : [bufferLayout.name];\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Extracts a table suitable for `console.table()` from a shader layout to assist in debugging.\n * @param layout shader layout\n * @param name app should provide the most meaningful name, usually the model or pipeline name / id.\n * @returns\n */\nexport function getDebugTableForShaderLayout(layout, name) {\n    const table = {};\n    const header = 'Values'; // '`Shader Layout for ${name}`;\n    if (layout.attributes.length === 0 && !layout.varyings?.length) {\n        return { 'No attributes or varyings': { [header]: 'N/A' } };\n    }\n    for (const attributeDeclaration of layout.attributes) {\n        if (attributeDeclaration) {\n            const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;\n            table[`in ${glslDeclaration}`] = { [header]: attributeDeclaration.stepMode || 'vertex' };\n        }\n    }\n    for (const varyingDeclaration of layout.varyings || []) {\n        const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;\n        table[`out ${glslDeclaration}`] = { [header]: JSON.stringify(varyingDeclaration.accessor) };\n    }\n    return table;\n}\n"],"names":["dataTypeFromTypedArray","getDataTypeFromTypedArray","getBufferAttributeLayout","name","accessor","attribute","format","size","type","byteOffset","offset","getStride","stride","bytesPerElement","resolveShaderAttribute","baseAccessor","shaderAttributeOptions","log","undefined","vertexOffset","elementOffset","DataColumn","constructor","device","opts","state","this","_buffer","id","logicalType","doublePrecision","bufferType","defaultValue","Number","isFinite","Array","fill","isIndexed","defaultType","Float64Array","Uint8ClampedArray","getTypedArrayFromDataType","typedArrayFromDataType","fp64","Float32Array","value","settings","normalized","includes","BYTES_PER_ELEMENT","externalBuffer","bufferAccessor","allocatedValue","numInstances","bounds","constant","isConstant","buffer","getAccessor","n","delete","typedArrayManager","getBuffer","getValue","attributeName","options","result","shaderAttributeDef","subarray","_getBufferLayout","attributes","byteStride","doubleShaderAttributeDefs","resolvedOptions","high","low","resolveDoublePrecisionShaderAttributes","push","setAccessor","getBounds","min","from","len","length","Infinity","max","i","j","v","setData","data","ArrayBuffer","isView","Buffer","replace","_normalizeValue","normalizeConstant","_areValuesEqual","_checkExternalBuffer","toDoublePrecisionArray","ArrayType","requiredBufferSize","byteLength","_createBuffer","write","updateSubBuffer","startOffset","endOffset","startIndex","endIndex","allocate","copy","oldValue","Error","illegalArrayType","map","x","out","start","value1","value2","destroy","createBuffer","props","usage","indexType","EMPTY_ARRAY","placeholderArray","isAsyncIterable","Symbol","asyncIterator","EMPTY","FULL","DEFAULT_TRANSITION_SETTINGS","interpolation","duration","easing","t","spring","stiffness","damping","normalizeTransitionSettings","userSettings","layerSettings","Attribute","super","startIndices","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","layoutChanged","updateRanges","range","update","_autoUpdater","Object","seal","_validateAttributeUpdaters","layout","clearChangedFlags","_a","accessor1","accessor2","getUpdateTriggers","concat","supportsTransition","Boolean","transition","getTransitionSetting","isArray","find","a","setNeedsUpdate","reason","dataRange","setNeedsRedraw","startRow","endRow","rangeList","newRangeList","insertPosition","range0","Math","splice","clearNeedsUpdate","noAlloc","updateBuffer","context","updated","call","getVertexOffset","_checkAttributeArray","setConstantValue","setExternalBuffer","setBinaryValue","transform","assert","needsNormalize","typedArray","nested","elementStride","vertexCount","floor","_","index","target","sourceIndex","targetIndex","getAccessorFromBuffer","row","shaderAttributeDefs","shaderAttributes","shaderAttributeName","assign","getBufferLayout","modelInfo","stepMode","isInstanced","accessorFunc","iterable","objectInfo","iterator","slice","createIterable","object","objectValue","numVertices","item","set","fillArray","source","count","limit","valid","FS300","getPassthroughFS","input","inputChannels","output","inputType","channels","channelCountToType","outputValue","variable","convertToVec4","BufferTransform","static","info","Model","isSupported","model","fs","topology","transformFeedback","createTransformFeedback","pipeline","shaderLayout","buffers","feedbackBuffers","setTransformFeedback","run","renderPass","beginRenderPass","draw","end","console","warn","varyingName","readAsync","fp64ify","hiPart","fround","loPart","fp64LowPart","fp64ifyMatrix4","matrix","matrixFP64","CONST_UNIFORMS","ONE","fp64arithmetic","vs","getUniforms","padArrayChunk","getData","sourceLength","targetLength","datum","getAttributeTypeFromSize","getFloat32VertexFormat","cycleBuffers","shift","matchBuffer","padBuffer","fromLength","toLength","fromStartIndices","precisionMultiplier","targetByteOffset","toStartIndices","hasStartIndices","toData","readSyncWebGL","getter","chunk","getMissingData","sourceStartIndices","targetStartIndices","getChunkData","nextSourceIndex","nextTargetIndex","padArray","GPUTransitionBase","timeline","currentLength","Transition","attributeInTransition","newAttribute","cloneAttribute","currentStartIndices","inProgress","transitionSettings","multiplier","maxVertexOffset","shaderAttribute","values","getAttributeBufferLength","onUpdate","setBuffer","cancel","vs64","useFp64","TRANSITION_TYPES","attributeSize","attributeType","inputFormat","bufferLayout","modules","defines","ATTRIBUTE_TYPE","ATTRIBUTE_SIZE","moduleSettings","varyings","bufferMode","disableWarnings","getTransform","prevLength","prevStartIndices","enter","setVertexCount","setAttributes","aFrom","setConstantAttributes","aTo","setBuffers","vCurrent","time","setUniforms","discard","texture","createTexture","Uint8Array","mipmaps","width","height","getTexture","framebuffer","createFramebuffer","colorAttachments","getFramebuffer","parameters","depthCompare","blendColorOperation","blendColorSrcFactor","blendColorDstFactor","blendAlphaOperation","blendAlphaSrcFactor","blendAlphaDstFactor","aPrev","aCur","vNext","viewport","clearColor","readPixelsToArrayWebGL","AttributeTransitionManager","transitions","finalize","_removeTransition","_updateAttribute","hasAttribute","getAttributes","animatedAttributes","isNew","TransitionType","TRACE_INVALIDATE","AttributeManager","stats","mergeBoundsMemoized","memoize","mergeBounds","updateTriggers","userData","attributeTransitionManager","getNeedsRedraw","clearRedrawFlags","redraw","add","_add","addInstanced","remove","attributeNameArray","invalidate","triggerName","invalidatedAttributes","_invalidateTrigger","debug","invalidateAll","get","timeStart","accessorName","timeEnd","updateTransition","transitionUpdated","attributeNames","getChangedAttributes","changedAttributes","getBufferLayouts","overrideOptions","_mapUpdateTriggersToAttributes","triggers","forEach","CPUInterpolationTransition","_value","_onUpdate","fromValue","toValue","lerp","EPSILON","updateSpringElement","prev","cur","dest","velocity","distance","distanceSquare","d","sqrt","abs","CPUSpringTransition","_currValue","_prevValue","nextValue","next","updateSpring","delta","UniformTransitionManager","Map","active","key","has","propsInTransition","clear","keys","diffProps","oldProps","propsChangedReason","compareProps","newProps","propTypes","PROP_TYPES_SYMBOL","ignoreProps","extensions","dataChangedReason","dataChanged","dataComparator","_dataDiff","diffDataProps","updateTriggersChangedReason","all","diffUpdateTrigger","changed","diffUpdateTriggers","propsChanged","updateTriggersChanged","extensionsChanged","diffExtensions","transitionsChanged","diffTransitions","propType","comparePropValues","hasOwnProperty","newProp","oldProp","equal","equals","oldExtensions","newTriggers","oldTriggers","ERR_NOT_OBJECT","ERR_NOT_CONTAINER","container","isPlainObject","mergeShaders","some","module","findIndex","inject","mergedInjection","DEFAULT_COORDINATE_ORIGIN","lngLatZToWorldPosition","lngLatZ","offsetMode","p","projectPosition","WebMercatorViewport","longitude","latitude","z","distanceScales","getDistanceScales","unitsPerMeter","getWorldPosition","position","modelMatrix","coordinateSystem","coordinateOrigin","y","vec4","COORDINATE_SYSTEM","addMetersToLngLat","isGeospatial","params","fromCoordinateSystem","fromCoordinateOrigin","normalizeParameters","autoOffset","geospatialOrigin","shaderCoordinateOrigin","getOffsetOrigin","worldPosition","positionCommonSpace","vec3","DEFAULT_TEXTURE_PARAMETERS","minFilter","mipmapFilter","magFilter","addressModeU","addressModeV","internalTextures","TYPE_DEFINITIONS","boolean","validate","number","color","optional","deepEqual","valueType","getTypeOf","array","compare","depth","isInteger","ignore","function","component","dataTransform","shape","endsWith","image","owner","sampler","Texture","samplerParameters","compressed","textureParameters","release","parsePropType","propDef","normalizePropDefinition","MergedDefaultPropsCacheKey","getPropsPrototype","componentClass","Component","cacheKey","extension","ExtensionClass","extensionName","defaultProps","getOwnProperty","parent","prototype","parentClass","getPrototypeOf","parentDefaultProps","componentDefaultProps","componentPropDefs","propDefs","deprecatedProps","propName","entries","deprecated","deprecatedFor","parsePropTypes","create","DEPRECATED_PROPS_SYMBOL","extensionDefaultProps","componentName","getComponentName","defineProperties","writable","createPropsPrototype","defaultValues","descriptors","async","getDescriptorForAsyncProp","ASYNC_DEFAULTS_SYMBOL","ASYNC_ORIGINAL_SYMBOL","addAsyncPropsToPropPrototype","defineProperty","enumerable","newValue","nameStr","newPropName","join","addDeprecatedPropsToPropPrototype","_propTypes","createPropsPrototypeAndTypes","Promise","ASYNC_RESOLVED_SYMBOL","COMPONENT_SYMBOL","internalState","hasAsyncProp","getAsyncProp","prop","counter","propObjects","propsPrototype","propsInstance","freeze","createProps","clone","asyncProps","EMPTY_PROPS","ComponentState","onAsyncPropUpdated","oldAsyncProps","asyncProp","resolvedValue","resetOldProps","getOldProps","isAsyncPropLoading","pendingLoadCount","resolvedLoadCount","reloadAsyncProp","_watchPromise","resolve","setAsyncProps","resolvedValues","originalValues","_createAsyncPropData","_updateAsyncProp","_fetch","url","_onResolve","_onError","error","_didAsyncInputValueChange","_resolveAsyncIterable","_setPropValue","_freezeAsyncOldProps","lastValue","_postProcessValue","_setAsyncPropValue","loadCount","promise","then","catch","LayerState","attributeManager","layer","subLayers","usesPickingColorCache","fetch","onDataLoad","raiseError","MAX_PICKING_COLOR_CACHE_SIZE","areViewportsEqual","oldViewport","pickingColorCache","__diff","onError","loaders","loadOptions","signal","resourceManager","getLoadOptions","inResourceManager","contains","resourceId","load","persistent","subscribe","onChange","consumerId","requestId","visible","pickable","opacity","operation","onHover","onClick","onDragStart","onDrag","onDragEnd","wrapLongitude","positionFormat","colorFormat","getPolygonOffset","layerIndex","highlightedObjectIndex","autoHighlight","highlightColor","Layer","arguments","lifecycle","LIFECYCLE","layerName","root","toString","className","project","xyz","worldToPixels","pixelProjectionMatrix","unproject","xy","isComposite","setState","partialState","setChangeFlags","stateChanged","layerManager","String","isLoaded","isPickable","getModels","models","setModuleParameters","moduleParameters","updateModuleSettings","setShaderModuleProps","shaderInputs","setProps","getAttributeManager","getCurrentLayer","use64bitPositions","pickingEvent","nullPickingColor","encodePickingColor","decodePickingColor","i1","i2","i3","getNumInstances","getStartIndices","getShaders","shaders","defaultShaderModules","shouldUpdateState","changeFlags","propsOrDataChanged","updateState","hasPickingBuffer","needsPickingBuffer","getNeedsPickingBuffer","pickingColors","instancePickingColors","pickingColorsAttribute","finalizeState","unsubscribe","uniformTransitions","getPickingInfo","mode","sourceLayer","message","cause","_getNeedsRedraw","hasUniformTransition","_getUpdateParams","activateViewport","viewportChanged","_update","invalidateAttribute","updateAttributes","bufferLayoutChanged","_setModelAttributes","_updateAttributes","_updateAttributeTransition","_updateUniformTransition","calculateInstancePickingColors","cacheSize","maxCount","newCacheSize","pickingColor","setBufferLayout","excludeAttributes","attributeBuffers","constantAttributes","setIndexBuffer","disablePickingIndex","objectIndex","_disablePickingIndex","colors","externalColorAttribute","objectColor","restorePickingColors","_initialize","_getAttributeManager","_clearChangeFlags","_onAsyncPropUpdated","bind","initializeState","_transferState","oldLayer","_diffProps","stateNeedsUpdate","currentProps","currentViewport","updateParams","oldModels","modelChanged","_postUpdate","_finalize","_drawLayer","uniforms","pow","isActive","isAttribute","picking","offsets","setParametersWebGL","polygonOffset","setParameters","withParametersWebGL","getChangeFlags","flags","flagChanged","prevDataChangedReason","somethingChanged","validateProps","updateAutoHighlight","_updateAutoHighlight","highlightedObjectColor","picked","forceUpdate","setInstanceCount","attributeManagerNeedsRedraw","onNeedsRedraw","uniformTypes","isHighlightActive","useFloatColors","defaultUniforms","order","injection","dependencies","DEFAULT_COLOR","getSourcePosition","sourcePosition","getTargetPosition","targetPosition","getSourceColor","getTargetColor","getWidth","getHeight","getTilt","greatCircle","numSegments","widthUnits","widthScale","widthMinPixels","widthMaxPixels","MAX_SAFE_INTEGER","ArcLayer","project32","instanceSourcePositions","instanceTargetPositions","instanceSourceColors","instanceTargetColors","instanceWidths","instanceHeights","instanceTilts","_getModel","UNIT","useShortestPath","positions","geometry","Geometry","radiusUnits","radiusScale","radiusMinPixels","radiusMaxPixels","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","stroked","filled","billboard","antialiasing","getPosition","getRadius","getFillColor","getLineColor","getLineWidth","strokeWidth","outline","getColor","ScatterplotLayer","instancePositions","instanceRadius","instanceFillColors","instanceLineColors","instanceLineWidths","arrayOrType","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","dataType","getVertexFormatFromAttribute","components","indices","uid","attributeValue","_print","_calculateVertexCount","getVertexCount","_setAttributes","UniformBlock","binding","bindings","uniformBlock","uniform","bindingLayout","_setUniform","getAllUniforms","modifiedUniforms","b","arrayA","isNumberArray","arrayB","arrayEqual","numberArray","arrayCopy","modified","UNIFORM_FORMATS","f32","i32","u32","decodeShaderUniformType","decoded","alignTo","UniformBufferLayout","uniformType","typeAndComponents","actualByteLength","uniformValues","bufferSize","arrayBuffer","getScratchArrayBuffer","typedArrays","f16","uniformLayout","numericArray","UniformStore","blocks","bufferName","block","uniformBufferName","uniformBufferLayout","uniformBufferLayouts","uniformBlocks","uniformBuffer","uniformBuffers","blockName","updateUniformBuffers","getUniformBufferByteLength","getUniformBufferData","createUniformBuffer","uniformBufferData","getManagedUniformBuffer","bufferReason","updateUniformBuffer","aKeys","bKeys","IncrementOperator","AssignOperator","TokenClass","ResourceType","ParseContext","constants","aliases","structs","Node","isAstNode","astNodeType","evaluate","evaluateString","search","callback","searchBlock","_BlockStart","instance","node","_BlockEnd","Statement","Function","args","returnType","body","startLine","endLine","calls","Set","StaticAssert","expression","While","condition","Continuing","For","init","increment","_b","_c","Var","storage","access","Override","Let","Const","parse","val","Increment","operator","Assign","Call","Loop","continuing","Switch","If","elseif","_else","else","Return","Enable","Requires","Diagnostic","severity","rule","Alias","Discard","Break","Continue","Type","isStruct","Struct","members","getMemberIndex","TemplateType","PointerType","SamplerType","Expression","StringExpr","CreateExpr","CallExpr","acos","acosh","asin","asinh","atan","atan2","atanh","ceil","cos","PI","exp","log2","round","sign","sin","sinh","tan","tanh","trunc","VariableExpr","postfix","ConstExpr","initializer","property","struct","memberIndex","LiteralExpr","BitcastExpr","TypecastExpr","GroupingExpr","contents","ArrayIndex","Operator","UnaryOperator","right","BinaryOperator","left","SwitchCase","Case","selector","Default","Argument","ElseIf","Member","TokenType","TokenTypes","none","reserved","eof","token","asm","bf16","do","enum","f64","handle","i8","i16","i64","mat","premerge","regardless","typedef","u8","u16","u64","unless","using","vec","void","keywords","keyword","atomic","bool","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","ptr","sampler_comparison","texture_1d","texture_2d","texture_2d_array","texture_3d","texture_cube","texture_cube_array","texture_multisampled_2d","texture_storage_1d","texture_storage_2d","texture_storage_2d_array","texture_storage_3d","texture_depth_2d","texture_depth_2d_array","texture_depth_cube","texture_depth_cube_array","texture_depth_multisampled_2d","texture_external","vec2","bitcast","break","case","continue","default","diagnostic","enable","fallthrough","false","fn","for","if","let","const","loop","while","private","read","read_write","return","requires","switch","true","alias","var","override","workgroup","r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm_srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm_srgb","rgb10a2unorm","rg11b10float","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","static_assert","tokens","decimal_float_literal","hex_float_literal","int_literal","uint_literal","ident","and","and_and","arrow","attr","forward_slash","bang","bracket_left","bracket_right","brace_left","brace_right","colon","comma","equal_equal","not_equal","greater_than","greater_than_equal","shift_right","less_than","less_than_equal","shift_left","modulo","minus","minus_minus","period","plus","plus_plus","or","or_or","paren_left","paren_right","semicolon","star","tilde","underscore","xor","plus_equal","minus_equal","times_equal","division_equal","modulo_equal","and_equal","or_equal","xor_equal","shift_right_equal","shift_left_equal","simpleTokens","literalTokens","regexTokens","storage_class","access_mode","sampler_type","sampled_texture_type","multisampled_texture_type","storage_texture_type","depth_texture_type","texture_external_type","any_texture_type","texel_format","const_literal","literal_or_ident","element_count_expression","template_types","attribute_name","assignment_operators","increment_operators","Token","lexeme","line","isTemplateType","indexOf","isArrayType","isArrayOrTemplateType","WgslScanner","_tokens","_start","_current","_line","_source","scanTokens","_isAtEnd","scanToken","_advance","_isWhitespace","_peekAhead","commentLevel","simpleToken","_addToken","matchType","isAlpha","_isAlpha","isUnderscore","_isAlphaNumeric","nextChar","matchedType","_findType","nextLexeme","ti","foundLessThan","lookAheadLexeme","lookAhead","maxLookAhead","li","_match","match","exec","c","amount","text","substring","WgslParser","_currentLine","_context","_deferArrayCountEval","tokensOrCode","statements","statement","_global_decl_or_directive","arrayDecl","arrayType","countNode","e","scanner","_error","_peek","types","_check","l","_consume","tk","_previous","_type_alias","directive","_diagnostic","_requires_directive","_enable_directive","attrs","_attribute","_var","_global_variable_decl","_override","_override_variable_decl","_let","_global_let_decl","_const","_global_const_decl","_struct","_struct_decl","_fn","_function_decl","argAttrs","typeAttrs","_type_decl","_return","_compound_statement","_statement","_if_statement","_switch_statement","_loop_statement","_for_statement","_while_statement","_continuing_statement","_static_assert_statement","_return_statement","_variable_statement","_increment_decrement_statement","_func_call_statement","_assignment_statement","_optional_paren_expression","_for_init","_short_circuit_or_expression","_for_increment","_variable_decl","savedPos","_unary_expression","decrement","_argument_expression_list","s","_switch_body","cases","_case_selectors","_case_body","_cases","selectors","_shift_expression","nextStatement","_match_elseif","_elseif_statement","expr","_short_circuit_and_expr","_inclusive_or_expression","_exclusive_or_expression","_and_expression","_equality_expression","_relational_expression","_additive_expression","_multiplicative_expression","_singular_expression","_primary_expression","_postfix_expression","arrayIndex","_getStruct","parseFloat","_paren_expression","arg","memberAttrs","memberName","memberType","structNode","_const_expression","_override_decl","valueExpr","constValue","aliasType","aliasNode","typeName","_texture_sampler_types","pointer","decl","countInt","parseInt","TypeInfo","isTemplate","MemberInfo","align","StructInfo","inUse","ArrayInfo","TemplateInfo","VariableInfo","group","resourceType","AliasInfo","_TypeSize","InputInfo","locationType","location","OutputInfo","FunctionInfo","stage","inputs","outputs","resources","EntryFunctions","vertex","fragment","compute","OverrideInfo","_FunctionResources","WgslReflect","code","textures","samplers","overrides","entry","functions","_types","_functions","_isStorageTexture","ast","_getTypeInfo","_getAliasInfo","_getAttributeNum","_isUniformVar","g","varInfo","Uniform","_isStorageVar","isStorageTexture","StorageTexture","Storage","_isTextureVar","_isSamplerVar","Sampler","vertexStage","_getAttribute","fragmentStage","computeStage","_findResources","_getInputs","_getOutputs","_addCalls","u","_markStructsInUse","m","_getAlias","findResource","_findResource","_markStructsFromAST","isEntry","self","varStack","pop","callFn","r","getBindGroups","groups","_makeRoom","_getStructOutputs","_getOutputInfo","typeInfo","locationValue","_parseInt","_getStructInputs","_getInputInfo","_parseString","isNaN","_updateTypeInfo","formatIsType","typeSize","_getTypeSize","formatInfo","_updateStructInfo","lastSize","lastOffset","structAlign","mi","ml","member","sizeInfo","_roundUp","explicitSize","explicitAlign","_typeInfo","divisor","E","_textureTypes","_samplerTypes","obj","k","getShaderLayoutFromWGSL","parsedWGSL","parseWGSL","getType","attributeCount","wgslAttribute","GPUGeometry","getIndexes","makeGPUGeometry","getIndexBufferFromGeometry","getAttributeBuffersFromGeometry","ShaderInputs","resolvedModules","_resolveModules","filter","resolvedModule","moduleUniforms","moduleBindings","moduleName","moduleProps","oldUniforms","oldBindings","uniformsAndBindings","splitUniformsAndBindings","getModules","getUniformValues","getBindings","getDebugTable","table","toStringTag","ComputePipeline","Resource","shader","entryPoint","PipelineFactory","_lumaData","defaultPipelineFactory","createRenderPipeline","allProps","RenderPipeline","hash","_hashRenderPipeline","_renderPipelineCache","useCount","createComputePipeline","_hashComputePipeline","_computePipelineCache","cache","shaderHash","_getHash","vsHash","fsHash","bufferLayoutHash","JSON","stringify","parameterHash","_hashes","_hashCounter","ShaderFactory","defaultShaderFactory","createShader","_hashShader","cacheEntry","_cache","Shader","canvas","ctx","moduleMap","fromEntries","setShaderInputs","platformInfo","shaderLanguage","shadingLanguage","shaderLanguageVersion","shadingLanguageVersion","gpu","features","getPlatformInfo","shaderAssembler","assembleShader","_getModuleUniforms","assembleShaderPair","instanceCount","setGeometry","pipelineFactory","getDefaultPipelineFactory","shaderFactory","getDefaultShaderFactory","_updatePipeline","vertexArray","createVertexArray","renderPipeline","_gpuGeometry","_setGeometryAttributes","indexBuffer","setBindings","_destroyed","_uniformStore","_getBindingsUpdateTimestamp","_lastDrawTimestamp","_needsRedraw","predraw","updateShaderInputs","drawSuccess","_logDrawCallStart","isObjectEmpty","setUniformsWebGL","indexCount","_logDrawCallEnd","_logFramebuffer","timestamp","gpuGeometry","setTopology","mergeBufferLayouts","_setPipelineNeedsUpdate","getAttributeNames","attributeInfo","_attributeInfos","setConstantWebGL","TextureView","updateTimestamp","_pipelineNeedsUpdate","prevShaderVs","prevShaderFs","debugShaders","getAttributeInfosFromLayouts","logDrawTimeout","Date","now","_lastLogTime","_logOpen","collapsed","shaderLayoutTable","header","attributeDeclaration","glslDeclaration","varyingDeclaration","getDebugTableForShaderLayout","uniformTable","attributeTable","_getAttributeDebugTable","debugFramebuffers","_drawCount","fbo","minimap","opaque","top","rgbaScale","document","createElement","title","style","zIndex","border","appendChild","getContext","imageData","createImageData","putImageData","debugFramebuffer","shaderType","_getBufferOrConstantValues","bufferDataType","debugData","TypedArrayConstructor","layouts1","layouts2","layouts","attribute2","ShaderAssembler"],"sourceRoot":""}
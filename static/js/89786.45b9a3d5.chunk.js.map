{"version":3,"file":"static/js/89786.45b9a3d5.chunk.js","mappings":"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","sources":["njslab/LabStarter/Starter-Mapbox-custom-canvas/MapboxGLWrapper/index.ts","njslab/LabStarter/Starter-Mapbox-custom-canvas/index.ts"],"sourcesContent":["import mapboxgl, { CustomLayerInterface } from \"mapbox-gl\";\r\n\r\nclass CanvasPolygonLayer implements mapboxgl.CustomLayerInterface {\r\n    id: string;\r\n    type: 'custom';\r\n    renderingMode: '2d';\r\n    map: mapboxgl.Map;\r\n    canvas: HTMLCanvasElement;\r\n    context: CanvasRenderingContext2D;\r\n    polygonsData: any;\r\n    popup?: mapboxgl.Popup;\r\n    hoveredPolygonId: number | null = null;\r\n\r\n    constructor(map: mapboxgl.Map, polygonsData: any) {\r\n        this.map = map;\r\n        this.id = 'polygon-layer';\r\n        this.type = 'custom';\r\n        this.renderingMode = '2d';\r\n        this.polygonsData = polygonsData;\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.style.position = 'absolute';\r\n        this.canvas.style.top = '0';\r\n        this.canvas.style.left = '0';\r\n        const context = this.canvas.getContext('2d');\r\n        if (!context) throw new Error('Failed to get 2D context');\r\n        this.context = context;\r\n\r\n        this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));\r\n        this.canvas.addEventListener('click', this.onClick.bind(this));\r\n\r\n        this.cachedScreenPolygon = [];\r\n    }\r\n\r\n    private onMouseMove(e: MouseEvent): void {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        const x = e.clientX - rect.left;\r\n        const y = e.clientY - rect.top;\r\n\r\n        this.hoveredPolygonId = null;\r\n        this.canvas.style.cursor = '';\r\n\r\n        this.polygonsData.features.forEach((feature: any, index: number) => {\r\n            if (this.isPointInPolygon([x, y], feature.geometry.coordinates)) {\r\n                this.hoveredPolygonId = index;\r\n                this.canvas.style.cursor = 'pointer';\r\n            }\r\n        });\r\n\r\n        this.map.triggerRepaint();\r\n    }\r\n\r\n    private onClick(e: MouseEvent): void {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        const x = e.clientX - rect.left;\r\n        const y = e.clientY - rect.top;\r\n\r\n\r\n\r\n        this.polygonsData.features.forEach((feature: any, index: number) => {\r\n            if (this.isPointInPolygon([x, y], feature.geometry.coordinates)) {\r\n                if (this.popup) {\r\n                    this.popup.remove();\r\n                }\r\n\r\n                this.popup = new mapboxgl.Popup()\r\n                    .setLngLat(feature.geometry.coordinates[0][0])\r\n                    .setHTML(`\r\n                        <div style=\"padding: 10px;\">\r\n                            <h3>Polygon Information</h3>\r\n                            <p>${feature.properties.description || 'No description'}</p>\r\n                        </div>\r\n                    `)\r\n                    .addTo(this.map);\r\n            }\r\n        });\r\n    }\r\n\r\n    // private isPointInPolygon(point: [number, number], polygon: number[][][]): boolean {\r\n    //     const [mouseX, mouseY] = point;\r\n    //     // let isInside = false;\r\n\r\n        \r\n    //     const screenPolygon = polygon[0].map(coord => this.map.project(coord));\r\n    //     console.log(mouseX, mouseY, screenPolygon)\r\n        \r\n    //     let isInside = false;\r\n    \r\n    //     // Ray-Casting 알고리즘을 사용하여 점이 폴리곤 내부에 있는지 확인\r\n    //     for (let i = 0, j = screenPolygon.length - 1; i < screenPolygon.length; j = i++) {\r\n    //         const { x: xi, y: yi } = screenPolygon[i];\r\n    //         const { x: xj, y: yj } = screenPolygon[j];\r\n    \r\n    //         const intersect = yi > mouseY !== yj > mouseY && \r\n    //             mouseX < ((xj - xi) * (mouseY - yi)) / (yj - yi) + xi;\r\n    \r\n    //         if (intersect) isInside = !isInside;\r\n    //     }\r\n    \r\n    //     return isInside;\r\n    // }\r\n    private cachedScreenPolygon: { polygonId: string; coordinates: { x: number; y: number }[] }[] = [];\r\n    private isPointInPolygon(point: [number, number], polygon: number[][][], polygonId: string): boolean {\r\n\r\n      // console.log(polygon)\r\n\r\n      if (polygon.length > 1) {\r\n        return this.isPointInPolygonMul(point, polygon)\r\n      }\r\n\r\n        const[mouseX, mouseY] = point;\r\n        const screenPolygon = polygon[0].map(coord => this.map.project(coord));\r\n\r\n        let isInside = false;\r\n        for (let i = 0, j = screenPolygon.length - 1; i < screenPolygon.length; j = i++) {\r\n            const { x: xi, y: yi } = screenPolygon[i];\r\n            const { x: xj, y: yj } = screenPolygon[j];\r\n        \r\n            const intersect = yi > mouseY !== yj > mouseY && mouseX < ((xj - xi) * (mouseY - yi)) / (yj - yi) + xi;\r\n\r\n            // console.log(`Edge (${i}-${j}): Intersect = ${intersect}`);\r\n        \r\n            if (intersect) isInside = !isInside;\r\n        }\r\n\r\n        return isInside;\r\n    }\r\n\r\n    private isPointInPolygonMul(point: [number, number], polygon: number[][][], polygonId: string): boolean {\r\n      // console.log(polygon);\r\n      \r\n      const [mouseX, mouseY] = point;\r\n      let isInside = false;\r\n  \r\n      for (const singlePolygon of polygon) {\r\n          const screenPolygon = singlePolygon.map(coord => {\r\n              // Ensure coord is in the correct format\r\n              if (Array.isArray(coord) && coord.length === 2) {\r\n                  return this.map.project(coord as [number, number]);\r\n              } else if (coord.lng !== undefined && coord.lat !== undefined) {\r\n                  return this.map.project({ lng: coord.lng, lat: coord.lat });\r\n              } else if (coord.lon !== undefined && coord.lat !== undefined) {\r\n                  return this.map.project({ lon: coord.lon, lat: coord.lat });\r\n              } else {\r\n                  console.warn('Invalid coordinate format:', coord);\r\n                  return null; // Handle invalid coordinate format\r\n              }\r\n          }).filter(coord => coord !== null); // Filter out invalid coordinates\r\n  \r\n          let currentPolygonInside = false;\r\n          for (let i = 0, j = screenPolygon.length - 1; i < screenPolygon.length; j = i++) {\r\n              const { x: xi, y: yi } = screenPolygon[i];\r\n              const { x: xj, y: yj } = screenPolygon[j];\r\n          \r\n              const intersect = yi > mouseY !== yj > mouseY && mouseX < ((xj - xi) * (mouseY - yi)) / (yj - yi) + xi;\r\n  \r\n              if (intersect) currentPolygonInside = !currentPolygonInside;\r\n          }\r\n  \r\n          if (currentPolygonInside) isInside = true;\r\n      }\r\n  \r\n      return isInside;\r\n  }\r\n  \r\n  \r\n\r\n    onAdd(map: mapboxgl.Map): void {\r\n        this.resizeCanvas();\r\n        map.getCanvasContainer().appendChild(this.canvas);\r\n        map.on('resize', this.resizeCanvas.bind(this));\r\n    }\r\n\r\n    // render(): boolean {\r\n    //     const context = this.context;\r\n\r\n    //     context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    //     this.polygonsData.features.forEach((feature: any, index: number) => {\r\n    //         const coordinates = feature.geometry.coordinates[0].map((coord: any) => this.map.project(coord));\r\n\r\n    //         console.log(coordinates)\r\n\r\n    //         context.beginPath();\r\n    //         coordinates.forEach((coord: mapboxgl.Point, i: number) => {\r\n    //             if (i === 0) {\r\n    //                 context.moveTo(coord.x, coord.y);\r\n    //             } else {\r\n    //                 context.lineTo(coord.x, coord.y);\r\n    //             }\r\n    //         });\r\n    //         context.closePath();\r\n\r\n    //         if (this.hoveredPolygonId === index) {\r\n    //             context.fillStyle = 'rgba(255, 0, 0, 0.5)';\r\n    //         } else {\r\n    //             context.fillStyle = 'rgba(0, 0, 255, 0.5)';\r\n    //         }\r\n\r\n    //         context.fill();\r\n    //         context.strokeStyle = '#FFFFFF';\r\n    //         context.lineWidth = 2;\r\n    //         context.stroke();\r\n    //     });\r\n\r\n    //     return true;\r\n    // }\r\n      render(): boolean {\r\n        const context = this.context;\r\n    \r\n        context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    \r\n        this.polygonsData.features.forEach((feature: any, index: number) => {\r\n            // Check if it's a MultiPolygon\r\n            if (feature.geometry.type === 'MultiPolygon') {\r\n                feature.geometry.coordinates.forEach((polygon: any) => {\r\n                    const coordinates = polygon[0].map((coord: any) => this.map.project(coord));\r\n    \r\n                    context.beginPath();\r\n                    coordinates.forEach((coord: mapboxgl.Point, i: number) => {\r\n                        if (i === 0) {\r\n                            context.moveTo(coord.x, coord.y);\r\n                        } else {\r\n                            context.lineTo(coord.x, coord.y);\r\n                        }\r\n                    });\r\n                    context.closePath();\r\n    \r\n                    if (this.hoveredPolygonId === index) {\r\n                        context.fillStyle = 'rgba(255, 0, 0, 0.5)';\r\n                    } else {\r\n                        context.fillStyle = 'rgba(0, 0, 255, 0.5)';\r\n                    }\r\n    \r\n                    context.fill();\r\n                    context.strokeStyle = '#FFFFFF';\r\n                    context.lineWidth = 2;\r\n                    context.stroke();\r\n                });\r\n            } else if (feature.geometry.type === 'Polygon') {\r\n                // Handle normal polygons\r\n                const coordinates = feature.geometry.coordinates[0].map((coord: any) => this.map.project(coord));\r\n    \r\n                context.beginPath();\r\n                coordinates.forEach((coord: mapboxgl.Point, i: number) => {\r\n                    if (i === 0) {\r\n                        context.moveTo(coord.x, coord.y);\r\n                    } else {\r\n                        context.lineTo(coord.x, coord.y);\r\n                    }\r\n                });\r\n                context.closePath();\r\n    \r\n                if (this.hoveredPolygonId === index) {\r\n                    context.fillStyle = 'rgba(255, 0, 0, 0.5)';\r\n                } else {\r\n                    context.fillStyle = 'rgba(0, 0, 255, 0.5)';\r\n                }\r\n    \r\n                context.fill();\r\n                context.strokeStyle = '#FFFFFF';\r\n                context.lineWidth = 2;\r\n                context.stroke();\r\n            }\r\n        });\r\n    \r\n        return true;\r\n    }\r\n  \r\n\r\n    onRemove(): void {\r\n        if (this.popup) {\r\n            this.popup.remove();\r\n        }\r\n        if (this.canvas.parentNode) {\r\n            this.canvas.parentNode.removeChild(this.canvas);\r\n        }\r\n        this.map.off('resize', this.resizeCanvas);\r\n    }\r\n\r\n    private resizeCanvas(): void {\r\n        const mapCanvas = this.map.getCanvas();\r\n        this.canvas.width = mapCanvas.width;\r\n        this.canvas.height = mapCanvas.height;\r\n    }\r\n}\r\n\r\n\r\nclass CanvasPointLayer implements CustomLayerInterface {\r\n    id: string;\r\n    type: 'custom';\r\n    renderingMode: '2d';\r\n    map: mapboxgl.Map;\r\n    canvas: HTMLCanvasElement;\r\n    context: CanvasRenderingContext2D;\r\n    pointsData: any;\r\n    popup?: mapboxgl.Popup;\r\n    hoveredPointId: number | null = null;\r\n    animationStartTime: number;\r\n\r\n    constructor(map: mapboxgl.Map, pointsData: any) {\r\n        this.map = map;\r\n        this.id = 'points-layer';\r\n        this.type = 'custom';\r\n        this.renderingMode = '2d';\r\n        this.pointsData = pointsData;\r\n        this.animationStartTime = Date.now();\r\n        \r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.style.position = 'absolute';\r\n        this.canvas.style.top = '0';\r\n        this.canvas.style.left = '0';\r\n        const context = this.canvas.getContext('2d');\r\n        if (!context) throw new Error('Failed to get 2D context');\r\n        this.context = context;\r\n\r\n        this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));\r\n        this.canvas.addEventListener('click', this.onClick.bind(this));\r\n\r\n        this.animate();\r\n    }\r\n\r\n    private animate = () => {\r\n        this.map.triggerRepaint();\r\n        requestAnimationFrame(this.animate);\r\n    }\r\n\r\n    private getAnimatedSize(baseSize: number, index: number): number {\r\n        const time = Date.now() - this.animationStartTime;\r\n\r\n        const phase = index * (Math.PI / 4);\r\n        const scale = 1 + (Math.sin(time * 0.002 + phase) * 0.2);\r\n        return baseSize * scale;\r\n    }\r\n\r\n    private getHoverColor(baseColor: string): string {\r\n        const time = Date.now() - this.animationStartTime;\r\n        const hue = (time * 0.1) % 360;\r\n        return `hsl(${hue}, 100%, 50%)`;\r\n    }\r\n    private onMouseMove(e: MouseEvent): void {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        const x = e.clientX - rect.left;\r\n        const y = e.clientY - rect.top;\r\n\r\n        this.canvas.style.cursor = '';\r\n        \r\n        this.hoveredPointId = null;\r\n        for (let i = 0; i < this.pointsData.features.length; i++) {\r\n            const feature = this.pointsData.features[i];\r\n            if (this.isPointUnderMouse(\r\n                feature.geometry.coordinates, \r\n                x, \r\n                y, \r\n                feature.properties.size ? feature.properties.size : 5\r\n            )) {\r\n                this.hoveredPointId = i;\r\n                this.canvas.style.cursor = 'pointer';\r\n                break;\r\n            }\r\n        }\r\n\r\n        this.map.triggerRepaint();\r\n    }\r\n    private onClick(e: MouseEvent): void {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        const x = e.clientX - rect.left;\r\n        const y = e.clientY - rect.top;\r\n\r\n        for (let i = 0; i < this.pointsData.features.length; i++) {\r\n            const feature = this.pointsData.features[i];\r\n            if (this.isPointUnderMouse(\r\n                feature.geometry.coordinates, \r\n                x, \r\n                y, \r\n                feature.properties.size\r\n            )) {\r\n                // console.log('feature.properties.size')\r\n\r\n                if (this.popup) {\r\n                    this.popup.remove();\r\n                }\r\n\r\n                this.popup = new mapboxgl.Popup()\r\n                    .setLngLat(feature.geometry.coordinates)\r\n                    .setHTML(`\r\n                        <div style=\"padding: 10px;\">\r\n                            <h3>Point Information</h3>\r\n                            <p>Size: ${feature.properties.size}</p>\r\n                            <p>Color: ${feature.properties.color}</p>\r\n                            ${feature.properties.description ? \r\n                                `<p>${feature.properties.description}</p>` : \r\n                                ''}\r\n                        </div>\r\n                    `)\r\n                    .addTo(this.map);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    private isPointUnderMouse(point: number[], mouseX: number, mouseY: number, radius: number): boolean {\r\n        const pixel = this.map.project(point);\r\n        const distance = Math.sqrt(\r\n            Math.pow(pixel.x - mouseX, 2) + \r\n            Math.pow(pixel.y - mouseY, 2)\r\n        );\r\n        // console.log(distance, radius)\r\n        return distance <= radius;\r\n    }\r\n      onAdd(map: mapboxgl.Map): void {\r\n        this.resizeCanvas();\r\n        map.getCanvasContainer().appendChild(this.canvas);\r\n        map.on('resize', this.resizeCanvas.bind(this));\r\n    }\r\n    render(): boolean {\r\n        const context = this.context;\r\n\r\n        // console.log(this.hoveredPointId);\r\n        \r\n        context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n\r\n        this.pointsData.features.forEach((feature, index) => {\r\n          const point = feature.geometry.coordinates;\r\n          const properties = feature.properties;\r\n          \r\n          \r\n          const pixel = this.map.project(point);\r\n          const animatedSize = this.getAnimatedSize(properties.size? properties.size : 5, index);\r\n        \r\n            // console.log(pixel)\r\n\r\n            context.beginPath();\r\n            context.arc(\r\n                pixel.x,\r\n                pixel.y,\r\n                animatedSize,\r\n                0,\r\n                2 * Math.PI\r\n            );\r\n\r\n\r\n            if (this.hoveredPointId === index) {\r\n                context.fillStyle = '#f00' // this.getHoverColor(properties.color);\r\n                \r\n                context.shadowColor = 'white';\r\n                context.shadowBlur = 20;\r\n            } else {\r\n                context.fillStyle = '#00f'  // properties.color;\r\n                context.shadowBlur = 0;\r\n            }\r\n            \r\n            context.fill();\r\n\r\n            context.strokeStyle = '#FFFFFF';\r\n            context.lineWidth = 2;\r\n            context.stroke();\r\n\r\n            context.shadowBlur = 0;\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    onRemove(): void {\r\n        if (this.popup) {\r\n            this.popup.remove();\r\n        }\r\n        if (this.canvas.parentNode) {\r\n            this.canvas.parentNode.removeChild(this.canvas);\r\n        }\r\n        this.map.off('resize', this.resizeCanvas);\r\n    }\r\n        private resizeCanvas(): void {\r\n        const mapCanvas = this.map.getCanvas();\r\n        this.canvas.width = mapCanvas.width;\r\n        this.canvas.height = mapCanvas.height;\r\n    }\r\n}\r\n\r\n\r\n\r\nexport class MapboxGLWrapper {\r\n  public map: mapboxgl.Map;\r\n  constructor(id: string) {\r\n\r\n\r\n    \r\n    const pointsData = {\r\n      type: \"FeatureCollection\",\r\n      features: [\r\n        {\r\n          type: \"Feature\",\r\n          properties: {\r\n            size: 10,\r\n            color: \"#FF0000\",\r\n          },\r\n          geometry: {\r\n            type: \"Point\",\r\n            coordinates: [-71.093507, 42.358959],\r\n          },\r\n        },\r\n        {\r\n          type: \"Feature\",\r\n          properties: {\r\n            size: 15,\r\n            color: \"#00FF00\",\r\n          },\r\n          geometry: {\r\n            type: \"Point\",\r\n            coordinates: [127.0216985, 37.5742135],\r\n          },\r\n        },\r\n        {\r\n          type: \"Feature\",\r\n          properties: {\r\n            size: 12,\r\n            color: \"#0000FF\",\r\n          },\r\n          geometry: {\r\n            type: \"Point\",\r\n            coordinates: [126.9816985, 37.5542135],\r\n          },\r\n        },\r\n      ],\r\n    };\r\n\r\n\r\n    const fetchDataPoint = async () => {\r\n      try {\r\n        const response = await fetch(process.env.PUBLIC_URL + '/static/dataDummyReady/underserved_locations.geojson');\r\n        if (!response.ok) {\r\n          throw new Error('Failed to load GeoJSON data');\r\n        }\r\n\r\n        const dataPoint = await response.json();\r\n        console.log(dataPoint);\r\n\r\n\r\n        \r\n        const canvasLayer = new CanvasPointLayer(this.map, dataPoint);\r\n        this.map.addLayer(canvasLayer);\r\n\r\n      } catch (error) {\r\n        console.error('Error fetching GeoJSON:', error);\r\n      }\r\n    };\r\n    fetchDataPoint();\r\n\r\n\r\n\r\n\r\n    \r\n    // const polygonsData = {\r\n    //     type: 'FeatureCollection',\r\n    //     features: [\r\n    //         {\r\n    //             type: 'Feature',\r\n    //             geometry: {\r\n    //                 type: 'Polygon',\r\n    //                 coordinates: [[[0, 0], [0, 20], [20, 20], [20, 0]]]\r\n    //             },\r\n    //             properties: {\r\n    //                 description: 'Sample Polygon 1'\r\n    //             }\r\n    //         }\r\n    //        \r\n    //     ]\r\n    // };\r\n    const fetchDataPolygon = async () => {\r\n      try {\r\n        // \r\n        // const response = await fetch(process.env.PUBLIC_URL + '/static/data/gz_2010_us_050_00_20m.json'); \r\n        const response = await fetch(process.env.PUBLIC_URL + '/static/data/us_counties.geojson'); \r\n\r\n        if (!response.ok) {\r\n          throw new Error('Failed to load GeoJSON data');\r\n        }\r\n\r\n        const polygonsData = await response.json();\r\n        console.log(polygonsData);\r\n\r\n        \r\n        const polygonLayer = new CanvasPolygonLayer(this.map, polygonsData);\r\n        this.map.addLayer(polygonLayer);\r\n\r\n      } catch (error) {\r\n        console.error('Error fetching GeoJSON:', error);\r\n      }\r\n    };\r\n    fetchDataPolygon();\r\n\r\n    this.initMap(id);\r\n  }\r\n  private initMap(id: string) {\r\n    mapboxgl.accessToken = process.env.REACT_APP_MAPBOX;\r\n    this.map = new mapboxgl.Map({\r\n      container: id,\r\n      zoom: 5,\r\n      // minZoom: 10,\r\n      center: [-71.093161, 42.358871],\r\n      style: \"mapbox://styles/mapbox/dark-v10\", // 'mapbox://styles/mapbox/streets-v11'\r\n    });\r\n    this.map.dragRotate.disable();\r\n\r\n    this.map.on(\"mousemove\", (e) => {\r\n      this.mouseMove(e);\r\n    });\r\n    this.map.on(\"click\", (e) => {\r\n      this.mouseClick(e);\r\n    });\r\n    this.map.on(\"mousedown\", (e) => {\r\n      this.mouseDown(e);\r\n    });\r\n    this.map.on(\"dblclick\", (e) => {\r\n      this.mouseDClick(e);\r\n    });\r\n    this.map.on(\"mouseup\", (e) => {\r\n      this.mouseUp(e);\r\n    });\r\n\r\n    let div = document.getElementsByClassName(\r\n      \"mapboxgl-canvas\"\r\n    )[0] as HTMLDivElement;\r\n    div.style.position = \"absolute\";\r\n\r\n    div = document.getElementsByClassName(\r\n      \"mapboxgl-control-container\"\r\n    )[0] as HTMLDivElement;\r\n    div.style.display = \"none\";\r\n\r\n\r\n    this.map.on(\"load\", () => {\r\n      // const canvasLayer = new CanvasPointLayer(this.map, pointsData);\r\n      // this.map.addLayer(canvasLayer);\r\n\r\n\r\n      this.map.on(\"move\", () => {\r\n        this.map.triggerRepaint();\r\n      });\r\n    });\r\n\r\n\r\n\r\n\r\n  }\r\n  public center = (lng: number = -99.292649, lat: number = 39.043903) => {\r\n    this.map.setCenter({ lat, lng });\r\n  };\r\n  public toMap = (x: number, y: number) => {\r\n    const p = this.map.unproject({ x, y } as any);\r\n    return [p.lng, p.lat];\r\n  };\r\n  public toScreen = (lon: number, lat: number) => {\r\n    const p = this.map.project([lon, lat]);\r\n    return [p.x, p.y];\r\n  };\r\n  public mouseDown = (e) => {\r\n    // console.log(this.toScreen(-71.093161, 42.358871))\r\n    // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n  };\r\n  public mouseUp = (e) => {\r\n    // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n  };\r\n  public mouseMove = (e) => {\r\n    // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n  };\r\n  public mouseClick = (e) => {\r\n    // console.log(e)\r\n    // console.log(this.toMap(100, 100));\r\n    // console.log(e.point)\r\n    // this.center()\r\n    // this.map.zoomTo(0)\r\n    // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n  };\r\n  public mouseDClick = (e) => {\r\n    // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n  };\r\n}\r\n","import { MapboxGLWrapper } from './MapboxGLWrapper';\r\n\r\n\r\nexport class Solution {\r\n    public divHost: HTMLDivElement;\r\n    public mapboxWrapper: MapboxGLWrapper;\r\n\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id) as HTMLDivElement;\r\n        this.divHost.style.position = 'relative';\r\n\r\n        this.mapboxWrapper = new MapboxGLWrapper(this.divHost.id);\r\n        this.mapboxWrapper.mouseDown = this.mouseDown\r\n        this.mapboxWrapper.mouseUp = this.mouseUp\r\n        this.mapboxWrapper.mouseClick = this.mouseClick\r\n        this.mapboxWrapper.mouseMove = this.mouseMove\r\n\r\n    }\r\n    public mouseDown = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseUp = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseDrag = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseClick = (e) => {\r\n        // TODO\r\n        // console.log(e);\r\n        // console.log(e['lngLat']);\r\n        // this.renderer.pts.push([e['lngLat']['lng'], e['lngLat']['lat']])\r\n    }\r\n    public mouseMove = (e)  =>{\r\n        // TODO\r\n    }\r\n    public keyDown(k: KeyboardEvent) {\r\n        // TODO\r\n    }\r\n    public destroy() {\r\n\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n"],"names":["CanvasPolygonLayer","constructor","map","polygonsData","id","type","renderingMode","canvas","context","popup","hoveredPolygonId","cachedScreenPolygon","this","document","createElement","style","position","top","left","getContext","Error","addEventListener","onMouseMove","bind","onClick","e","rect","getBoundingClientRect","x","clientX","y","clientY","cursor","features","forEach","feature","index","isPointInPolygon","geometry","coordinates","triggerRepaint","remove","mapboxgl","setLngLat","setHTML","properties","description","addTo","point","polygon","polygonId","length","isPointInPolygonMul","mouseX","mouseY","screenPolygon","coord","project","isInside","i","j","xi","yi","xj","yj","singlePolygon","Array","isArray","undefined","lng","lat","lon","console","warn","filter","currentPolygonInside","onAdd","resizeCanvas","getCanvasContainer","appendChild","on","render","clearRect","width","height","beginPath","moveTo","lineTo","closePath","fillStyle","fill","strokeStyle","lineWidth","stroke","onRemove","parentNode","removeChild","off","mapCanvas","getCanvas","CanvasPointLayer","pointsData","hoveredPointId","animationStartTime","animate","requestAnimationFrame","Date","now","getAnimatedSize","baseSize","time","phase","Math","PI","sin","getHoverColor","baseColor","isPointUnderMouse","size","color","radius","pixel","sqrt","pow","animatedSize","arc","shadowColor","shadowBlur","MapboxGLWrapper","center","setCenter","toMap","p","unproject","toScreen","mouseDown","mouseUp","mouseMove","mouseClick","mouseDClick","async","response","fetch","process","ok","dataPoint","json","log","canvasLayer","addLayer","error","fetchDataPoint","polygonLayer","fetchDataPolygon","initMap","container","zoom","dragRotate","disable","div","getElementsByClassName","display","Solution","divHost","mapboxWrapper","mouseDrag","getElementById","keyDown","k","destroy","lastElementChild"],"sourceRoot":""}